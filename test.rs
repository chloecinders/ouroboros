#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2024::*;
#[macro_use]
extern crate std;
use std::{
    env, fs, sync::{Arc, OnceLock},
    time::{Duration, Instant},
};
use serenity::{
    Client, all::{GatewayIntents, Settings, ShardManager},
    prelude::TypeMapKey,
};
use sqlx::{PgPool, postgres::PgPoolOptions};
use tokio::{fs::File, io::AsyncReadExt, sync::Mutex, time::sleep};
use tracing::{error, warn};
use crate::{
    config::{Config, Environment},
    event_handler::Handler, utils::GuildSettings,
};
use std::process::Command as SystemCommand;
pub struct ShardManagerContainer;
impl TypeMapKey for ShardManagerContainer {
    type Value = Arc<ShardManager>;
}
mod commands {
    use core::fmt;
    use std::{
        collections::HashMap, fmt::Debug, iter::Peekable, pin::Pin, sync::Arc,
        vec::IntoIter,
    };
    use crate::{
        event_handler::{CommandError, MissingArgumentError},
        lexer::Token,
    };
    use serenity::{
        all::{Context, GuildChannel, Member, Message, Permissions, User},
        async_trait,
    };
    #[allow(clippy::large_enum_variant)]
    pub enum TransformerError {
        CommandError(CommandError),
        MissingArgumentError(MissingArgumentError),
    }
    pub type TransformerReturn<'a> = Pin<
        Box<dyn Future<Output = Result<Token, TransformerError>> + Send + 'a>,
    >;
    pub type TransformerFn = dyn for<'a> Fn(
        &'a Context,
        &'a Message,
        &'a mut Peekable<IntoIter<Token>>,
    ) -> TransformerReturn<'a> + Send + Sync;
    pub type TransformerFnArc = Arc<TransformerFn>;
    #[allow(non_camel_case_types)]
    pub enum CommandArgument {
        String(String),
        User(User),
        Member(Member),
        Duration(chrono::Duration),
        None,
        i32(i32),
        GuildChannel(GuildChannel),
        bool(bool),
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for CommandArgument {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                CommandArgument::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
                CommandArgument::User(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "User",
                        &__self_0,
                    )
                }
                CommandArgument::Member(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Member",
                        &__self_0,
                    )
                }
                CommandArgument::Duration(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Duration",
                        &__self_0,
                    )
                }
                CommandArgument::None => ::core::fmt::Formatter::write_str(f, "None"),
                CommandArgument::i32(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "i32",
                        &__self_0,
                    )
                }
                CommandArgument::GuildChannel(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "GuildChannel",
                        &__self_0,
                    )
                }
                CommandArgument::bool(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "bool",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(non_camel_case_types)]
    impl ::core::clone::Clone for CommandArgument {
        #[inline]
        fn clone(&self) -> CommandArgument {
            match self {
                CommandArgument::String(__self_0) => {
                    CommandArgument::String(::core::clone::Clone::clone(__self_0))
                }
                CommandArgument::User(__self_0) => {
                    CommandArgument::User(::core::clone::Clone::clone(__self_0))
                }
                CommandArgument::Member(__self_0) => {
                    CommandArgument::Member(::core::clone::Clone::clone(__self_0))
                }
                CommandArgument::Duration(__self_0) => {
                    CommandArgument::Duration(::core::clone::Clone::clone(__self_0))
                }
                CommandArgument::None => CommandArgument::None,
                CommandArgument::i32(__self_0) => {
                    CommandArgument::i32(::core::clone::Clone::clone(__self_0))
                }
                CommandArgument::GuildChannel(__self_0) => {
                    CommandArgument::GuildChannel(::core::clone::Clone::clone(__self_0))
                }
                CommandArgument::bool(__self_0) => {
                    CommandArgument::bool(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    pub enum CommandSyntax {
        Consume(&'static str),
        User(&'static str, bool),
        Member(&'static str, bool),
        Channel(&'static str, bool),
        String(&'static str, bool),
        Duration(&'static str, bool),
        Reason(&'static str),
        Number(&'static str, bool),
        Filters,
        Or(Box<CommandSyntax>, Box<CommandSyntax>),
    }
    pub struct CommandParameter<'a> {
        pub name: &'a str,
        pub short: &'a str,
        pub transformer: &'a TransformerFn,
        pub desc: &'a str,
    }
    pub enum CommandCategory {
        Misc,
        Utilities,
        Moderation,
        Admin,
        Developer,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CommandCategory {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CommandCategory {
        #[inline]
        fn eq(&self, other: &CommandCategory) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for CommandCategory {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for CommandCategory {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    impl fmt::Display for CommandCategory {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(
                format_args!(
                    "{0}",
                    match self {
                        CommandCategory::Misc => "Misc",
                        CommandCategory::Utilities => "Utilities",
                        CommandCategory::Moderation => "Moderation",
                        CommandCategory::Admin => "Admin",
                        CommandCategory::Developer => "Developer",
                    },
                ),
            )
        }
    }
    impl CommandSyntax {
        pub fn get_def(&self) -> String {
            let (inner, required) = match self {
                Self::Consume(name) | Self::Reason(name) => {
                    (
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("...[{0}]", name))
                        }),
                        None,
                    )
                }
                Self::Or(a, b) => {
                    (
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("({0} || {1})", a.get_def(), b.get_def()),
                            )
                        }),
                        None,
                    )
                }
                Self::User(name, opt) => {
                    (
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("{0}: Discord User", name))
                        }),
                        Some(opt),
                    )
                }
                Self::Member(name, opt) => {
                    (
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("{0}: Discord Member", name),
                            )
                        }),
                        Some(opt),
                    )
                }
                Self::String(name, opt) => {
                    (
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("{0}: String", name))
                        }),
                        Some(opt),
                    )
                }
                Self::Duration(name, opt) => {
                    (
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("{0}: Duration", name))
                        }),
                        Some(opt),
                    )
                }
                Self::Number(name, opt) => {
                    (
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("{0}: Number", name))
                        }),
                        Some(opt),
                    )
                }
                Self::Filters => (String::from("...[filters]"), None),
                Self::Channel(name, opt) => {
                    (
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("{0}: Channel", name))
                        }),
                        Some(opt),
                    )
                }
            };
            if let Some(is_required) = required {
                if *is_required {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("<{0}>", inner))
                    })
                } else {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("[{0}]", inner))
                    })
                }
            } else {
                inner
            }
        }
        pub fn get_example(&self) -> String {
            match self {
                CommandSyntax::Consume(_) => String::from("Some Text"),
                CommandSyntax::User(_, _) => String::from("123456789"),
                CommandSyntax::Member(_, _) => String::from("123456789"),
                CommandSyntax::String(_, _) => String::from("\"something\""),
                CommandSyntax::Duration(_, _) => String::from("15m"),
                CommandSyntax::Reason(_) => String::from("user broke a rule"),
                CommandSyntax::Number(_, _) => String::from("5"),
                CommandSyntax::Channel(_, _) => String::from("#some-channel"),
                CommandSyntax::Filters => String::from("+user @ouroboros"),
                CommandSyntax::Or(a, b) => {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "({0} || {1})",
                                a.get_example(),
                                b.get_example(),
                            ),
                        )
                    })
                }
            }
        }
    }
    pub struct CommandPermissions {
        pub required: Vec<Permissions>,
        pub one_of: Vec<Permissions>,
    }
    #[automatically_derived]
    impl ::core::default::Default for CommandPermissions {
        #[inline]
        fn default() -> CommandPermissions {
            CommandPermissions {
                required: ::core::default::Default::default(),
                one_of: ::core::default::Default::default(),
            }
        }
    }
    pub trait Command: Send + Sync {
        fn get_name(&self) -> &'static str;
        fn get_short(&self) -> &'static str;
        fn get_full(&self) -> &'static str;
        fn get_syntax(&self) -> Vec<CommandSyntax>;
        fn get_category(&self) -> CommandCategory;
        fn get_args(&self) -> Vec<&'static CommandParameter<'static>>;
        #[must_use]
        #[allow(
            elided_named_lifetimes,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds
        )]
        fn run<'life0, 'life1, 'async_trait>(
            &'life0 self,
            ctx: Context,
            msg: Message,
            args: Vec<Token>,
            params: HashMap<&'life1 str, CommandArgument>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), CommandError>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
        fn get_transformers(&self) -> Vec<TransformerFnArc> {
            ::alloc::vec::Vec::new()
        }
        fn get_permissions(&self) -> CommandPermissions {
            Default::default()
        }
    }
    mod ping {
        use std::time::{Duration, Instant};
        use reqwest::{Client, redirect::Policy};
        use serenity::{
            all::{
                Context, CreateAllowedMentions, CreateEmbed, CreateMessage,
                Message as DiscordMessage,
            },
            async_trait,
        };
        use tracing::warn;
        use crate::{
            ShardManagerContainer,
            commands::{Command, CommandCategory, CommandParameter, CommandSyntax},
            constants::BRAND_BLUE, event_handler::CommandError, lexer::Token,
        };
        pub struct Ping;
        impl Ping {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Ping {
            fn get_name(&self) -> &'static str {
                "ping"
            }
            fn get_short(&self) -> &'static str {
                "Gets the bots current latency"
            }
            fn get_full(&self) -> &'static str {
                "Gets the bots HTTP and gateway latency. Useful for checking if the bot is lagging."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                ::alloc::vec::Vec::new()
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Misc
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn run<'life0, 'async_trait>(
                &'life0 self,
                ctx: Context,
                msg: DiscordMessage,
                _args: Vec<Token>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let _args = _args;
                    let __ret: Result<(), CommandError> = {
                        let http = {
                            let start = Instant::now();
                            let _ = ctx.http.get_current_user().await;
                            start.elapsed().as_millis()
                        };
                        let gateway = {
                            let data_read = ctx.data.read().await;
                            let shard_manager = data_read
                                .get::<ShardManagerContainer>()
                                .unwrap()
                                .clone();
                            let runners = shard_manager.runners.lock().await;
                            let shard_info = runners.get(&ctx.shard_id).unwrap();
                            shard_info.latency.unwrap_or(Duration::default()).as_millis()
                        };
                        let ping = {
                            let client = Client::builder()
                                .redirect(Policy::none())
                                .build()
                                .unwrap();
                            let start = Instant::now();
                            let _ = client
                                .get("https://discord.com/api/v10/gateway")
                                .send()
                                .await;
                            start.elapsed().as_millis()
                        };
                        let message = CreateMessage::new()
                            .embed(
                                CreateEmbed::new()
                                    .description(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "HTTP: {0}ms\nGateway: {1}ms\nPing: {2}ms",
                                                    http,
                                                    gateway,
                                                    ping,
                                                ),
                                            )
                                        }),
                                    )
                                    .color(BRAND_BLUE),
                            )
                            .reference_message(&msg)
                            .allowed_mentions(
                                CreateAllowedMentions::new().replied_user(false),
                            );
                        if let Err(e) = msg
                            .channel_id
                            .send_message(&ctx.http, message)
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\ping.rs:98",
                                            "Ouroboros::commands::ping",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\ping.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(98u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::ping",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Could not send message; err = {0:?}", e)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Could not send message; err = {0:?}", e)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
    }
    pub use ping::Ping;
    mod stats {
        use std::time::Instant;
        use serenity::{
            all::{Context, CreateAllowedMentions, CreateEmbed, CreateMessage, Message},
            async_trait,
        };
        use sysinfo::System;
        use tracing::warn;
        use crate::{
            START_TIME,
            commands::{Command, CommandCategory, CommandParameter, CommandSyntax},
            constants::BRAND_BLUE, event_handler::CommandError, lexer::Token,
        };
        pub struct Stats;
        impl Stats {
            pub fn new() -> Self {
                Self
            }
        }
        impl Command for Stats {
            fn get_name(&self) -> &'static str {
                "stats"
            }
            fn get_short(&self) -> &'static str {
                "Gets various bot statistics"
            }
            fn get_full(&self) -> &'static str {
                "Shows various statistics of the bot. Useful for nerds!"
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                ::alloc::vec::Vec::new()
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Misc
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn run<'life0, 'async_trait>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                _args: Vec<Token>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let _args = _args;
                    let __ret: Result<(), CommandError> = {
                        let guild_count = ctx.cache.guild_count();
                        let uptime = {
                            let elapsed = START_TIME
                                .get()
                                .unwrap_or(&Instant::now())
                                .elapsed();
                            let seconds = elapsed.as_secs();
                            (seconds / 3600, (seconds % 3600) / 60, seconds % 60)
                        };
                        let memory = {
                            let mut sys = System::new_all();
                            sys.refresh_all();
                            sys.process((std::process::id() as usize).into())
                                .map(|p| p.memory() as f64 / 1024.0 / 1024.0)
                                .unwrap_or(0.0)
                        };
                        let description = {
                            let uptime = if uptime.0 != 0 {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}h {1}m {2}s", uptime.0, uptime.1, uptime.2),
                                    )
                                })
                            } else if uptime.1 != 0 {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}m {1}s", uptime.1, uptime.2),
                                    )
                                })
                            } else {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(format_args!("{0}s", uptime.2))
                                })
                            };
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "**STATS**\nServers: {0}\nUptime: {1}\nMemory: {2:.2}MB",
                                        guild_count,
                                        uptime,
                                        memory,
                                    ),
                                )
                            })
                        };
                        let reply = CreateMessage::new()
                            .add_embed(
                                CreateEmbed::new()
                                    .description(description)
                                    .color(BRAND_BLUE),
                            )
                            .reference_message(&msg)
                            .allowed_mentions(
                                CreateAllowedMentions::new().replied_user(false),
                            );
                        if let Err(e) = msg
                            .channel_id
                            .send_message(&ctx.http, reply)
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\stats.rs:93",
                                            "Ouroboros::commands::stats",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\stats.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(93u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::stats",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Could not send message; err = {0:?}", e)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Could not send message; err = {0:?}", e)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
    }
    pub use stats::Stats;
    mod warn {
        use std::sync::Arc;
        use serenity::{
            all::{
                Context, CreateEmbed, CreateMessage, Mentionable, Message, Permissions,
            },
            async_trait,
        };
        use sqlx::query;
        use tracing::warn;
        use crate::{
            SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError,
            lexer::{InferType, Token},
            transformers::Transformers,
            utils::{LogType, guild_log, message_and_dm, tinyid},
        };
        use ouroboros_macros::command;
        pub struct Warn;
        impl Warn {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Warn {
            fn get_name(&self) -> &'static str {
                "warn"
            }
            fn get_short(&self) -> &'static str {
                "Warns a member of the server"
            }
            fn get_full(&self) -> &'static str {
                "Warns a member, storing a note in the users log."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::Member("user", true),
                        CommandSyntax::Consume("reason"),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let member = {
                    let Some(Token { contents: Some(CommandArgument::Member(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("member", Some("Member")))
                        })
                    };
                    b
                };
                let reason: Option<String> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::String(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let member = member;
                    let reason = reason;
                    let __ret: Result<(), CommandError> = {
                        let inferred = args
                            .first()
                            .map(|a| match a.inferred {
                                Some(InferType::Message) => true,
                                _ => false,
                            })
                            .unwrap_or(false);
                        let mut reason = reason
                            .map(|s| {
                                if s.is_empty() || s.chars().all(char::is_whitespace) {
                                    String::from("No reason provided")
                                } else {
                                    s
                                }
                            })
                            .unwrap_or(String::from("No reason provided"));
                        if reason.len() > 500 {
                            reason.truncate(500);
                            reason.push_str("...");
                        }
                        let db_id = tinyid().await;
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(db_id);
                                    let arg1 = &(msg
                                        .guild_id
                                        .map(|g| g.get() as i64)
                                        .unwrap_or(0));
                                    let arg2 = &(member.user.id.get() as i64);
                                    let arg3 = &(msg.author.id.get() as i64);
                                    let arg4 = &(reason.as_str());
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg1);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            i64,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg4);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            5usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg2)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg3)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg4),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg2).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg3).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg4).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                        "INSERT INTO actions (id, type, guild_id, user_id, moderator_id, reason) VALUES ($1, 'warn', $2, $3, $4, $5)",
                                        query_args,
                                    )
                                }
                            }
                        }
                            .execute(SQL.get().unwrap())
                            .await;
                        if let Err(err) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\warn.rs:99",
                                            "Ouroboros::commands::warn",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\warn.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(99u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::warn",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while warning; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while warning; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not warn member"),
                                hint: Some(String::from("please try again later")),
                                arg: None,
                            });
                        }
                        if inferred && let Some(reply) = msg.referenced_message.clone() {
                            let _ = reply.delete(&ctx.http).await;
                        }
                        message_and_dm(
                                &ctx,
                                &msg,
                                &member.user,
                                |a| {
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "**{0} WARNED**\n-# Log ID: `{1}`{2}\n```\n{3}\n```",
                                                member.mention(),
                                                db_id,
                                                a,
                                                reason,
                                            ),
                                        )
                                    })
                                },
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "**WARNED**\n-# Server: {0}\n```\n{1}\n```",
                                            msg
                                                .guild(&ctx.cache)
                                                .map(|g| g.name.clone())
                                                .unwrap_or(String::from("UNKNOWN_GUILD")),
                                            reason,
                                        ),
                                    )
                                }),
                                inferred,
                                false,
                            )
                            .await;
                        guild_log(
                                &ctx.http,
                                LogType::MemberWarn,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**MEMBER WARNED**\n-# Log ID: `{4}` | Actor: {0} `{1}` | Target: {2} `{3}`\n```\n{5}\n```",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            member.mention(),
                                                            member.user.id.get(),
                                                            db_id,
                                                            reason,
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::reply_member),
                        Arc::new(Transformers::reply_consume),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::MANAGE_NICKNAMES]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use warn::Warn;
    mod log {
        use std::{time::Duration, vec};
        use chrono::Utc;
        use serenity::{
            all::{
                ButtonStyle, Context, CreateActionRow, CreateAllowedMentions,
                CreateButton, CreateEmbed, CreateInteractionResponse,
                CreateInteractionResponseMessage, CreateMessage, EditMessage, Message,
                Permissions,
            },
            async_trait,
        };
        use sqlx::{query, query_as};
        use tracing::warn;
        use crate::{
            SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, database::ActionType, event_handler::CommandError,
            lexer::Token, transformers::Transformers,
        };
        struct LogRecord {
            id: String,
            r#type: ActionType,
            moderator_id: i64,
            created_at: sqlx::types::chrono::NaiveDateTime,
            updated_at: ::std::option::Option<sqlx::types::chrono::NaiveDateTime>,
            expires_at: ::std::option::Option<sqlx::types::chrono::NaiveDateTime>,
            reason: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LogRecord {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "type",
                    "moderator_id",
                    "created_at",
                    "updated_at",
                    "expires_at",
                    "reason",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.r#type,
                    &self.moderator_id,
                    &self.created_at,
                    &self.updated_at,
                    &self.expires_at,
                    &&self.reason,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "LogRecord",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LogRecord {
            #[inline]
            fn clone(&self) -> LogRecord {
                LogRecord {
                    id: ::core::clone::Clone::clone(&self.id),
                    r#type: ::core::clone::Clone::clone(&self.r#type),
                    moderator_id: ::core::clone::Clone::clone(&self.moderator_id),
                    created_at: ::core::clone::Clone::clone(&self.created_at),
                    updated_at: ::core::clone::Clone::clone(&self.updated_at),
                    expires_at: ::core::clone::Clone::clone(&self.expires_at),
                    reason: ::core::clone::Clone::clone(&self.reason),
                }
            }
        }
        pub struct Log;
        impl Log {
            pub fn new() -> Self {
                Self {}
            }
            async fn get_one_response(
                &self,
                guild_id: i64,
                log: String,
            ) -> Result<String, CommandError> {
                let res = {
                    {
                        #[allow(clippy::all)]
                        {
                            use ::sqlx::Arguments as _;
                            let arg0 = &(guild_id);
                            let arg1 = &(log);
                            #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                            if false {
                                use ::sqlx::ty_match::{
                                    WrapSameExt as _, MatchBorrowExt as _,
                                };
                                let expr = ::sqlx::ty_match::dupe_value(arg0);
                                let ty_check = ::sqlx::ty_match::WrapSame::<
                                    i64,
                                    _,
                                >::new(&expr)
                                    .wrap_same();
                                let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                    ty_check,
                                    &expr,
                                );
                                _ty_check = match_borrow.match_borrow();
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                );
                            }
                            #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                            if false {
                                use ::sqlx::ty_match::{
                                    WrapSameExt as _, MatchBorrowExt as _,
                                };
                                let expr = ::sqlx::ty_match::dupe_value(arg1);
                                let ty_check = ::sqlx::ty_match::WrapSame::<
                                    &str,
                                    _,
                                >::new(&expr)
                                    .wrap_same();
                                let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                    ty_check,
                                    &expr,
                                );
                                _ty_check = match_borrow.match_borrow();
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                );
                            }
                            let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                '_,
                            >::default();
                            query_args
                                .reserve(
                                    2usize,
                                    0
                                        + ::sqlx::encode::Encode::<
                                            sqlx::postgres::Postgres,
                                        >::size_hint(arg0)
                                        + ::sqlx::encode::Encode::<
                                            sqlx::postgres::Postgres,
                                        >::size_hint(arg1),
                                );
                            let query_args = ::core::result::Result::<
                                _,
                                ::sqlx::error::BoxDynError,
                            >::Ok(query_args)
                                .and_then(move |mut query_args| {
                                    query_args.add(arg0).map(move |()| query_args)
                                })
                                .and_then(move |mut query_args| {
                                    query_args.add(arg1).map(move |()| query_args)
                                });
                            #[allow(non_snake_case)]
                            struct Record {
                                id: String,
                                r#type: ActionType,
                                moderator_id: i64,
                                user_id: i64,
                                created_at: sqlx::types::chrono::NaiveDateTime,
                                updated_at: ::std::option::Option<
                                    sqlx::types::chrono::NaiveDateTime,
                                >,
                                active: bool,
                                expires_at: ::std::option::Option<
                                    sqlx::types::chrono::NaiveDateTime,
                                >,
                                reason: String,
                            }
                            #[automatically_derived]
                            #[allow(non_snake_case)]
                            impl ::core::fmt::Debug for Record {
                                #[inline]
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let names: &'static _ = &[
                                        "id",
                                        "type",
                                        "moderator_id",
                                        "user_id",
                                        "created_at",
                                        "updated_at",
                                        "active",
                                        "expires_at",
                                        "reason",
                                    ];
                                    let values: &[&dyn ::core::fmt::Debug] = &[
                                        &self.id,
                                        &self.r#type,
                                        &self.moderator_id,
                                        &self.user_id,
                                        &self.created_at,
                                        &self.updated_at,
                                        &self.active,
                                        &self.expires_at,
                                        &&self.reason,
                                    ];
                                    ::core::fmt::Formatter::debug_struct_fields_finish(
                                        f,
                                        "Record",
                                        names,
                                        values,
                                    )
                                }
                            }
                            ::sqlx::__query_with_result::<
                                sqlx::postgres::Postgres,
                                _,
                            >(
                                    "\n                SELECT id, type as \"type!: ActionType\", moderator_id, user_id, created_at, updated_at, active, expires_at, reason FROM actions WHERE guild_id = $1 AND id = $2;\n            ",
                                    query_args,
                                )
                                .try_map(|row: sqlx::postgres::PgRow| {
                                    use ::sqlx::Row as _;
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_id = row
                                        .try_get_unchecked::<String, _>(0usize)?
                                        .into();
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_type = row
                                        .try_get_unchecked::<ActionType, _>(1usize)?
                                        .into();
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_moderator_id = row
                                        .try_get_unchecked::<i64, _>(2usize)?
                                        .into();
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_user_id = row
                                        .try_get_unchecked::<i64, _>(3usize)?
                                        .into();
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_created_at = row
                                        .try_get_unchecked::<
                                            sqlx::types::chrono::NaiveDateTime,
                                            _,
                                        >(4usize)?
                                        .into();
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_updated_at = row
                                        .try_get_unchecked::<
                                            ::std::option::Option<sqlx::types::chrono::NaiveDateTime>,
                                            _,
                                        >(5usize)?
                                        .into();
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_active = row
                                        .try_get_unchecked::<bool, _>(6usize)?
                                        .into();
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_expires_at = row
                                        .try_get_unchecked::<
                                            ::std::option::Option<sqlx::types::chrono::NaiveDateTime>,
                                            _,
                                        >(7usize)?
                                        .into();
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_reason = row
                                        .try_get_unchecked::<String, _>(8usize)?
                                        .into();
                                    ::std::result::Result::Ok(Record {
                                        id: sqlx_query_as_id,
                                        r#type: sqlx_query_as_type,
                                        moderator_id: sqlx_query_as_moderator_id,
                                        user_id: sqlx_query_as_user_id,
                                        created_at: sqlx_query_as_created_at,
                                        updated_at: sqlx_query_as_updated_at,
                                        active: sqlx_query_as_active,
                                        expires_at: sqlx_query_as_expires_at,
                                        reason: sqlx_query_as_reason,
                                    })
                                })
                        }
                    }
                }
                    .fetch_optional(SQL.get().unwrap())
                    .await;
                let data = match res {
                    Ok(d) => d,
                    Err(err) => {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src\\commands\\log.rs:58",
                                        "Ouroboros::commands::log",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "src\\commands\\log.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(58u32),
                                        ::tracing_core::__macro_support::Option::Some(
                                            "Ouroboros::commands::log",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &value_set,
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!("Couldn\'t fetch log data; err = {0:?}", err)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                                            __CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                            ::tracing::__macro_support::Option::Some(
                                                                                &format_args!("Couldn\'t fetch log data; err = {0:?}", err)
                                                                                    as &dyn Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            }
                        };
                        return Err(CommandError {
                            title: String::from("Unable to query the database"),
                            hint: Some(String::from("try again later")),
                            arg: None,
                        });
                    }
                };
                let Some(data) = data else {
                    return Err(CommandError {
                        title: String::from("Log not found"),
                        hint: Some(
                            String::from("check if you have copied the ID correctly!"),
                        ),
                        arg: None,
                    });
                };
                let update_string = if let Some(t) = data.updated_at {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                " | Updated <t:{0}:d> <t:{0}:T>",
                                t.and_utc().timestamp(),
                            ),
                        )
                    })
                } else {
                    String::new()
                };
                let response = if let Some(expiry) = data.expires_at {
                    let now = Utc::now().naive_utc();
                    let expire_tag = if expiry < now { "Expired" } else { "Expires" };
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "**{0}**\n-# Mod: <@{1}> | At: <t:{2}:d> <t:{2}:T>{7} | {3} <t:{4}:d> <t:{4}:T>\n`{5}`\n```\n{6}\n```\n\n",
                                data.r#type.to_string().to_uppercase(),
                                data.moderator_id,
                                data.created_at.and_utc().timestamp(),
                                expire_tag,
                                expiry.and_utc().timestamp(),
                                data.id,
                                data.reason.replace("```", "\\`\\`\\`"),
                                update_string,
                            ),
                        )
                    })
                } else {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "**{0}**\n-# Mod: <@{1}> | At <t:{2}:d> <t:{2}:T>{5}\n`{3}`\n```\n{4}\n```\n\n",
                                data.r#type.to_string().to_uppercase(),
                                data.moderator_id,
                                data.created_at.and_utc().timestamp(),
                                data.id,
                                data.reason,
                                update_string,
                            ),
                        )
                    })
                };
                Ok(response)
            }
            async fn run_one(
                &self,
                ctx: Context,
                msg: Message,
                log: String,
            ) -> Result<(), CommandError> {
                let reply = CreateMessage::new()
                    .add_embed(
                        CreateEmbed::new()
                            .description(
                                self
                                    .get_one_response(msg.guild_id.unwrap().get() as i64, log)
                                    .await?,
                            )
                            .color(BRAND_BLUE),
                    )
                    .reference_message(&msg)
                    .allowed_mentions(CreateAllowedMentions::new().replied_user(false));
                if let Err(err) = msg.channel_id.send_message(&ctx.http, reply).await {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\commands\\log.rs:125",
                                    "Ouroboros::commands::log",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\commands\\log.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(125u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::commands::log",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!("Could not send message; err = {0:?}", err)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!("Could not send message; err = {0:?}", err)
                                                                                as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                }
                Ok(())
            }
            fn create_chunked_response(&self, chunk: &[LogRecord]) -> String {
                let mut response = String::new();
                chunk
                    .iter()
                    .for_each(|data| {
                        let mut record = data.clone();
                        if record.reason.len() > 100 {
                            record.reason.truncate(100);
                            record.reason.push_str("...");
                        }
                        let reason = if record.reason.chars().all(char::is_whitespace)
                            || record.reason.is_empty()
                        {
                            String::new()
                        } else {
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("```\n{0}\n```\n", record.reason),
                                )
                            })
                        };
                        let update_string = if let Some(t) = record.updated_at {
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        " | Updated <t:{0}:d> <t:{0}:T>",
                                        t.and_utc().timestamp(),
                                    ),
                                )
                            })
                        } else {
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        " | At <t:{0}:d> <t:{0}:T>",
                                        record.created_at.and_utc().timestamp(),
                                    ),
                                )
                            })
                        };
                        if let Some(expiry) = record.expires_at {
                            let now = Utc::now().naive_utc();
                            let expire_tag = if expiry < now {
                                "Expired"
                            } else {
                                "Expires"
                            };
                            response
                                .push_str(
                                    ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "**{0}**\n-# Mod: <@{1}>{6} | {2}: <t:{3}:d> <t:{3}:T>\n`{4}`\n{5}\n",
                                                    record.r#type.to_string().to_uppercase(),
                                                    record.moderator_id,
                                                    expire_tag,
                                                    expiry.and_utc().timestamp(),
                                                    record.id,
                                                    reason,
                                                    update_string,
                                                ),
                                            )
                                        })
                                        .as_str(),
                                );
                        } else {
                            response
                                .push_str(
                                    ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "**{0}**\n-# Mod: <@{1}>{4}\n`{2}`\n```\n{3}\n```\n",
                                                    record.r#type.to_string().to_uppercase(),
                                                    record.moderator_id,
                                                    record.id,
                                                    record.reason,
                                                    update_string,
                                                ),
                                            )
                                        })
                                        .as_str(),
                                );
                        }
                    });
                response
            }
        }
        impl Command for Log {
            fn get_name(&self) -> &'static str {
                "log"
            }
            fn get_short(&self) -> &'static str {
                "Shows actions taken on a member"
            }
            fn get_full(&self) -> &'static str {
                "Shows the moderation actions taken on a member. This includes warns, bans, kicks, etc."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::Or(
                            Box::new(CommandSyntax::User("user", true)),
                            Box::new(CommandSyntax::String("id", false)),
                        ),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn run<'life0, 'async_trait>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let args = args;
                    let __ret: Result<(), CommandError> = {
                        let mut args_iter = args.clone().into_iter().peekable();
                        let Ok(token) = Transformers::user(&ctx, &msg, &mut args_iter)
                            .await else {
                            match Transformers::string(
                                    &ctx,
                                    &msg,
                                    &mut args.into_iter().peekable(),
                                )
                                .await
                            {
                                Ok(log) => {
                                    let Some(CommandArgument::String(id)) = log.contents else {
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        )
                                    };
                                    return __self.run_one(ctx, msg, id).await;
                                }
                                Err(_) => {
                                    return Err(
                                        CommandError::arg_not_found(
                                            "user or id",
                                            Some("User || String"),
                                        ),
                                    );
                                }
                            }
                        };
                        let Token { contents: Some(CommandArgument::User(user)), .. } = token
                        else {
                            return Err(
                                CommandError::arg_not_found(
                                    "user or id",
                                    Some("User || String"),
                                ),
                            );
                        };
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(user.id.get() as i64);
                                    let arg1 = &(msg.guild_id.map(|g| g.get()).unwrap_or(0)
                                        as i64);
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            2usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                            "\n                SELECT id, type as \"type!: ActionType\", moderator_id, created_at, updated_at, expires_at, reason FROM actions WHERE user_id = $1 AND guild_id = $2;\n            ",
                                            query_args,
                                        )
                                        .try_map(|row: sqlx::postgres::PgRow| {
                                            use ::sqlx::Row as _;
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_id = row
                                                .try_get_unchecked::<String, _>(0usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_type = row
                                                .try_get_unchecked::<ActionType, _>(1usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_moderator_id = row
                                                .try_get_unchecked::<i64, _>(2usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_created_at = row
                                                .try_get_unchecked::<
                                                    sqlx::types::chrono::NaiveDateTime,
                                                    _,
                                                >(3usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_updated_at = row
                                                .try_get_unchecked::<
                                                    ::std::option::Option<sqlx::types::chrono::NaiveDateTime>,
                                                    _,
                                                >(4usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_expires_at = row
                                                .try_get_unchecked::<
                                                    ::std::option::Option<sqlx::types::chrono::NaiveDateTime>,
                                                    _,
                                                >(5usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_reason = row
                                                .try_get_unchecked::<String, _>(6usize)?
                                                .into();
                                            ::std::result::Result::Ok(LogRecord {
                                                id: sqlx_query_as_id,
                                                r#type: sqlx_query_as_type,
                                                moderator_id: sqlx_query_as_moderator_id,
                                                created_at: sqlx_query_as_created_at,
                                                updated_at: sqlx_query_as_updated_at,
                                                expires_at: sqlx_query_as_expires_at,
                                                reason: sqlx_query_as_reason,
                                            })
                                        })
                                }
                            }
                        }
                            .fetch_all(SQL.get().unwrap())
                            .await;
                        let data = match res {
                            Ok(d) => d,
                            Err(err) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\log.rs:266",
                                                "Ouroboros::commands::log",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\log.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(266u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::log",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Couldn\'t fetch log data; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Couldn\'t fetch log data; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Err(CommandError {
                                    title: String::from("Unable to query the database"),
                                    hint: Some(String::from("try again later")),
                                    arg: None,
                                });
                            }
                        };
                        let chunks: Vec<Vec<LogRecord>> = data
                            .chunks(5)
                            .map(|c| c.to_vec())
                            .collect();
                        let Some(chunk) = chunks.first() else {
                            let reply = CreateMessage::new()
                                .add_embed(
                                    CreateEmbed::new()
                                        .description("No log entries found.")
                                        .color(BRAND_BLUE),
                                )
                                .reference_message(&msg)
                                .allowed_mentions(
                                    CreateAllowedMentions::new().replied_user(false),
                                );
                            if let Err(err) = msg
                                .channel_id
                                .send_message(&ctx.http, reply)
                                .await
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\log.rs:288",
                                                "Ouroboros::commands::log",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\log.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(288u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::log",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            return Ok(());
                        };
                        let mut page_buttons = <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                CreateButton::new("first")
                                    .style(ButtonStyle::Secondary)
                                    .label("<<")
                                    .disabled(true),
                                CreateButton::new("prev")
                                    .style(ButtonStyle::Secondary)
                                    .label("<")
                                    .disabled(true),
                                CreateButton::new("page")
                                    .style(ButtonStyle::Secondary)
                                    .label(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("1/{0}", chunks.len()))
                                        }),
                                    )
                                    .disabled(true),
                                CreateButton::new("next")
                                    .style(ButtonStyle::Secondary)
                                    .label(">"),
                                CreateButton::new("last")
                                    .style(ButtonStyle::Secondary)
                                    .label(">>"),
                            ]),
                        );
                        let mut log_buttons = <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                CreateButton::new("1")
                                    .style(ButtonStyle::Secondary)
                                    .label("1")
                                    .disabled(chunk.is_empty()),
                                CreateButton::new("2")
                                    .style(ButtonStyle::Secondary)
                                    .label("2")
                                    .disabled(chunk.get(1).is_none()),
                                CreateButton::new("3")
                                    .style(ButtonStyle::Secondary)
                                    .label("3")
                                    .disabled(chunk.get(2).is_none()),
                                CreateButton::new("4")
                                    .style(ButtonStyle::Secondary)
                                    .label("4")
                                    .disabled(chunk.get(3).is_none()),
                                CreateButton::new("5")
                                    .style(ButtonStyle::Secondary)
                                    .label("5")
                                    .disabled(chunk.get(4).is_none()),
                            ]),
                        );
                        if chunks.len() == 1 {
                            page_buttons = page_buttons
                                .into_iter()
                                .map(|b| b.disabled(true))
                                .collect();
                        }
                        let response = __self.create_chunked_response(chunk);
                        let reply = CreateMessage::new()
                            .add_embed(
                                CreateEmbed::new().description(response).color(BRAND_BLUE),
                            )
                            .components(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        CreateActionRow::Buttons(page_buttons.clone()),
                                        CreateActionRow::Buttons(log_buttons.clone()),
                                    ]),
                                ),
                            )
                            .reference_message(&msg)
                            .allowed_mentions(
                                CreateAllowedMentions::new().replied_user(false),
                            );
                        let mut new_msg = match msg
                            .channel_id
                            .send_message(&ctx.http, reply.clone())
                            .await
                        {
                            Ok(m) => m,
                            Err(err) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\log.rs:355",
                                                "Ouroboros::commands::log",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\log.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(355u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::log",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Ok(());
                            }
                        };
                        let mut page = 0;
                        let get_updated_buttons = |
                            page: usize,
                            disabled: [bool; 4],
                        | -> Vec<CreateButton> {
                            let disabled: [bool; 5] = [
                                disabled[0],
                                disabled[1],
                                true,
                                disabled[2],
                                disabled[3],
                            ];
                            let mut new = page_buttons.clone();
                            new = new
                                .into_iter()
                                .enumerate()
                                .map(|(i, mut d)| {
                                    if i == 2 {
                                        d = d
                                            .label(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("{0}/{1}", page + 1, chunks.len()),
                                                    )
                                                }),
                                            );
                                    }
                                    d.disabled(disabled[i])
                                })
                                .collect();
                            new
                        };
                        let get_updated_logs = |page: usize| -> Vec<CreateButton> {
                            let chunk = chunks.get(page).unwrap();
                            let disabled: [bool; 5] = [
                                chunk.is_empty(),
                                chunk.get(1).is_none(),
                                chunk.get(2).is_none(),
                                chunk.get(3).is_none(),
                                chunk.get(4).is_none(),
                            ];
                            let mut new = log_buttons.clone();
                            new = new
                                .into_iter()
                                .enumerate()
                                .map(|(i, d)| d.disabled(disabled[i]))
                                .collect();
                            new
                        };
                        loop {
                            let interaction = match new_msg
                                .await_component_interaction(&ctx.shard)
                                .timeout(Duration::from_secs(60 * 5))
                                .await
                            {
                                Some(i) => i,
                                None => {
                                    page_buttons = page_buttons
                                        .into_iter()
                                        .map(|b| b.disabled(true))
                                        .collect();
                                    log_buttons = log_buttons
                                        .into_iter()
                                        .map(|b| b.disabled(true))
                                        .collect();
                                    let _ = new_msg
                                        .edit(
                                            &ctx.http,
                                            EditMessage::new()
                                                .components(
                                                    <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            CreateActionRow::Buttons(page_buttons),
                                                            CreateActionRow::Buttons(log_buttons),
                                                        ]),
                                                    ),
                                                ),
                                        )
                                        .await;
                                    return Ok(());
                                }
                            };
                            if interaction.user.id.get() != msg.author.id.get() {
                                if let Err(e) = interaction
                                    .create_response(
                                        &ctx.http,
                                        CreateInteractionResponse::Message(
                                            CreateInteractionResponseMessage::new()
                                                .content("You are not the author of the original message!")
                                                .ephemeral(true),
                                        ),
                                    )
                                    .await
                                {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src\\commands\\log.rs:436",
                                                    "Ouroboros::commands::log",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "src\\commands\\log.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(436u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "Ouroboros::commands::log",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                if match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            use ::tracing::log;
                                                            let level = match ::tracing::Level::WARN {
                                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                _ => ::tracing::log::Level::Trace,
                                                            };
                                                            if level <= log::max_level() {
                                                                let meta = __CALLSITE.metadata();
                                                                let log_meta = log::Metadata::builder()
                                                                    .level(level)
                                                                    .target(meta.target())
                                                                    .build();
                                                                let logger = log::logger();
                                                                if logger.enabled(&log_meta) {
                                                                    ::tracing::__macro_support::__tracing_log(
                                                                        meta,
                                                                        logger,
                                                                        log_meta,
                                                                        &value_set,
                                                                    )
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Could not send message; err = {0:?}", e)
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &{
                                                                        #[allow(unused_imports)]
                                                                        use ::tracing::field::{debug, display, Value};
                                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                                        __CALLSITE
                                                                            .metadata()
                                                                            .fields()
                                                                            .value_set(
                                                                                &[
                                                                                    (
                                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                                        ::tracing::__macro_support::Option::Some(
                                                                                            &format_args!("Could not send message; err = {0:?}", e)
                                                                                                as &dyn Value,
                                                                                        ),
                                                                                    ),
                                                                                ],
                                                                            )
                                                                    },
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        }
                                    };
                                }
                                continue;
                            }
                            match interaction.data.custom_id.as_str() {
                                "first" => {
                                    page = 0;
                                    let response = __self
                                        .create_chunked_response(chunks.first().unwrap());
                                    if interaction
                                        .create_response(
                                            &ctx.http,
                                            CreateInteractionResponse::UpdateMessage(
                                                CreateInteractionResponseMessage::default()
                                                    .add_embed(
                                                        CreateEmbed::new().description(response).color(BRAND_BLUE),
                                                    )
                                                    .components(
                                                        <[_]>::into_vec(
                                                            ::alloc::boxed::box_new([
                                                                CreateActionRow::Buttons(
                                                                    get_updated_buttons(page, [true, true, false, false]),
                                                                ),
                                                                CreateActionRow::Buttons(get_updated_logs(page)),
                                                            ]),
                                                        ),
                                                    ),
                                            ),
                                        )
                                        .await
                                        .is_err()
                                    {
                                        return Ok(());
                                    }
                                }
                                "prev" => {
                                    page -= 1;
                                    let response = __self
                                        .create_chunked_response(chunks.get(page).unwrap());
                                    let none_prev = if page == 0 {
                                        true
                                    } else {
                                        chunks.get(page - 1).is_none()
                                    };
                                    if interaction
                                        .create_response(
                                            &ctx.http,
                                            CreateInteractionResponse::UpdateMessage(
                                                CreateInteractionResponseMessage::default()
                                                    .add_embed(
                                                        CreateEmbed::new().description(response).color(BRAND_BLUE),
                                                    )
                                                    .components(
                                                        <[_]>::into_vec(
                                                            ::alloc::boxed::box_new([
                                                                CreateActionRow::Buttons(
                                                                    get_updated_buttons(
                                                                        page,
                                                                        [none_prev, none_prev, false, false],
                                                                    ),
                                                                ),
                                                                CreateActionRow::Buttons(get_updated_logs(page)),
                                                            ]),
                                                        ),
                                                    ),
                                            ),
                                        )
                                        .await
                                        .is_err()
                                    {
                                        return Ok(());
                                    }
                                }
                                "next" => {
                                    page += 1;
                                    let response = __self
                                        .create_chunked_response(chunks.get(page).unwrap());
                                    let none_next = chunks.get(page + 1).is_none();
                                    if interaction
                                        .create_response(
                                            &ctx.http,
                                            CreateInteractionResponse::UpdateMessage(
                                                CreateInteractionResponseMessage::default()
                                                    .add_embed(
                                                        CreateEmbed::new().description(response).color(BRAND_BLUE),
                                                    )
                                                    .components(
                                                        <[_]>::into_vec(
                                                            ::alloc::boxed::box_new([
                                                                CreateActionRow::Buttons(
                                                                    get_updated_buttons(
                                                                        page,
                                                                        [false, false, none_next, none_next],
                                                                    ),
                                                                ),
                                                                CreateActionRow::Buttons(get_updated_logs(page)),
                                                            ]),
                                                        ),
                                                    ),
                                            ),
                                        )
                                        .await
                                        .is_err()
                                    {
                                        return Ok(());
                                    }
                                }
                                "last" => {
                                    page = chunks.len() - 1;
                                    let response = __self
                                        .create_chunked_response(chunks.last().unwrap());
                                    if interaction
                                        .create_response(
                                            &ctx.http,
                                            CreateInteractionResponse::UpdateMessage(
                                                CreateInteractionResponseMessage::default()
                                                    .add_embed(
                                                        CreateEmbed::new().description(response).color(BRAND_BLUE),
                                                    )
                                                    .components(
                                                        <[_]>::into_vec(
                                                            ::alloc::boxed::box_new([
                                                                CreateActionRow::Buttons(
                                                                    get_updated_buttons(page, [false, false, true, true]),
                                                                ),
                                                                CreateActionRow::Buttons(get_updated_logs(page)),
                                                            ]),
                                                        ),
                                                    ),
                                            ),
                                        )
                                        .await
                                        .is_err()
                                    {
                                        return Ok(());
                                    }
                                }
                                "1" | "2" | "3" | "4" | "5" => {
                                    let log = interaction
                                        .data
                                        .custom_id
                                        .parse::<usize>()
                                        .unwrap();
                                    let id = chunks
                                        .get(page)
                                        .unwrap()
                                        .get(log - 1)
                                        .unwrap()
                                        .id
                                        .to_string();
                                    let response = __self
                                        .get_one_response(
                                            interaction.guild_id.unwrap().get() as i64,
                                            id,
                                        )
                                        .await?;
                                    if interaction
                                        .create_response(
                                            &ctx.http,
                                            CreateInteractionResponse::Message(
                                                CreateInteractionResponseMessage::new()
                                                    .add_embed(
                                                        CreateEmbed::new().description(response).color(BRAND_BLUE),
                                                    ),
                                            ),
                                        )
                                        .await
                                        .is_err()
                                    {
                                        return Ok(());
                                    }
                                }
                                _ => {}
                            };
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                ::alloc::vec::Vec::new()
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: ::alloc::vec::Vec::new(),
                    one_of: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            Permissions::MANAGE_NICKNAMES,
                            Permissions::KICK_MEMBERS,
                            Permissions::MODERATE_MEMBERS,
                            Permissions::BAN_MEMBERS,
                        ]),
                    ),
                }
            }
        }
    }
    pub use log::Log;
    mod kick {
        use std::sync::Arc;
        use serenity::{
            all::{
                Context, CreateEmbed, CreateMessage, Mentionable, Message, Permissions,
            },
            async_trait,
        };
        use sqlx::query;
        use tracing::{error, warn};
        use crate::{
            SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError,
            lexer::{InferType, Token},
            transformers::Transformers,
            utils::{LogType, guild_log, message_and_dm, tinyid},
        };
        use ouroboros_macros::command;
        pub struct Kick;
        impl Kick {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Kick {
            fn get_name(&self) -> &'static str {
                "kick"
            }
            fn get_short(&self) -> &'static str {
                "Kicks a member from the server"
            }
            fn get_full(&self) -> &'static str {
                "Kicks a member from the server and leaves a note in the users log."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::Member("member", true),
                        CommandSyntax::Reason("reason"),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let member = {
                    let Some(Token { contents: Some(CommandArgument::Member(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("member", Some("Member")))
                        })
                    };
                    b
                };
                let reason: Option<String> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::String(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let member = member;
                    let reason = reason;
                    let __ret: Result<(), CommandError> = {
                        let inferred = args
                            .first()
                            .map(|a| match a.inferred {
                                Some(InferType::Message) => true,
                                _ => false,
                            })
                            .unwrap_or(false);
                        let mut reason = reason
                            .map(|s| {
                                if s.is_empty() || s.chars().all(char::is_whitespace) {
                                    String::from("No reason provided")
                                } else {
                                    s
                                }
                            })
                            .unwrap_or(String::from("No reason provided"));
                        if reason.len() > 500 {
                            reason.truncate(500);
                            reason.push_str("...");
                        }
                        let db_id = tinyid().await;
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(db_id);
                                    let arg1 = &(msg
                                        .guild_id
                                        .map(|g| g.get() as i64)
                                        .unwrap_or(0));
                                    let arg2 = &(member.user.id.get() as i64);
                                    let arg3 = &(msg.author.id.get() as i64);
                                    let arg4 = &(reason.as_str());
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg1);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            i64,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg4);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            5usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg2)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg3)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg4),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg2).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg3).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg4).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                        "INSERT INTO actions (id, type, guild_id, user_id, moderator_id, reason) VALUES ($1, 'kick', $2, $3, $4, $5)",
                                        query_args,
                                    )
                                }
                            }
                        }
                            .execute(SQL.get().unwrap())
                            .await;
                        if let Err(err) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\kick.rs:99",
                                            "Ouroboros::commands::kick",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\kick.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(99u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::kick",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while kicking; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while kicking; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not kick member"),
                                hint: Some(String::from("please try again later")),
                                arg: None,
                            });
                        }
                        if let Err(err) = member
                            .kick_with_reason(&ctx.http, &reason)
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\kick.rs:108",
                                            "Ouroboros::commands::kick",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\kick.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(108u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::kick",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while kicking; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while kicking; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            if {
                                {
                                    #[allow(clippy::all)]
                                    {
                                        use ::sqlx::Arguments as _;
                                        let arg0 = &(db_id);
                                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                        if false {
                                            use ::sqlx::ty_match::{
                                                WrapSameExt as _, MatchBorrowExt as _,
                                            };
                                            let expr = ::sqlx::ty_match::dupe_value(arg0);
                                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                                &str,
                                                _,
                                            >::new(&expr)
                                                .wrap_same();
                                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                ty_check,
                                                &expr,
                                            );
                                            _ty_check = match_borrow.match_borrow();
                                            ::core::panicking::panic(
                                                "internal error: entered unreachable code",
                                            );
                                        }
                                        let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                            '_,
                                        >::default();
                                        query_args
                                            .reserve(
                                                1usize,
                                                0
                                                    + ::sqlx::encode::Encode::<
                                                        sqlx::postgres::Postgres,
                                                    >::size_hint(arg0),
                                            );
                                        let query_args = ::core::result::Result::<
                                            _,
                                            ::sqlx::error::BoxDynError,
                                        >::Ok(query_args)
                                            .and_then(move |mut query_args| {
                                                query_args.add(arg0).map(move |()| query_args)
                                            });
                                        ::sqlx::__query_with_result::<
                                            sqlx::postgres::Postgres,
                                            _,
                                        >("DELETE FROM actions WHERE id = $1", query_args)
                                    }
                                }
                            }
                                .execute(SQL.get().unwrap())
                                .await
                                .is_err()
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\kick.rs:115",
                                                "Ouroboros::commands::kick",
                                                ::tracing::Level::ERROR,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\kick.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(115u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::kick",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::ERROR {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Got an error while kicking and an error with the database! Stray kick entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                    db_id,
                                                                    err,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::ERROR {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!(
                                                                                            "Got an error while kicking and an error with the database! Stray kick entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                                            db_id,
                                                                                            err,
                                                                                        ) as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            return Err(CommandError {
                                title: String::from("Could not kick member"),
                                hint: Some(
                                    String::from(
                                        "check if the bot has the kick members permission or try again later",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        if inferred && let Some(reply) = msg.referenced_message.clone() {
                            let _ = reply.delete(&ctx.http).await;
                        }
                        message_and_dm(
                                &ctx,
                                &msg,
                                &member.user,
                                |a| {
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "**{0} KICKED**\n-# Log ID: `{1}`{2}\n```\n{3}\n```",
                                                member.mention(),
                                                db_id,
                                                a,
                                                reason,
                                            ),
                                        )
                                    })
                                },
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "**KICKED**\n-# Server: {0}\n```\n{1}\n```",
                                            msg
                                                .guild(&ctx.cache)
                                                .map(|g| g.name.clone())
                                                .unwrap_or(String::from("UNKNOWN_GUILD")),
                                            reason,
                                        ),
                                    )
                                }),
                                inferred,
                                false,
                            )
                            .await;
                        guild_log(
                                &ctx.http,
                                LogType::MemberKick,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**MEMBER KICKED**\n-# Log ID: `{4}` | Actor: {0} `{1}` | Target: {2} `{3}`\n```\n{5}\n```",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            member.mention(),
                                                            member.user.id.get(),
                                                            db_id,
                                                            reason,
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::reply_member),
                        Arc::new(Transformers::reply_consume),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::KICK_MEMBERS]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use kick::Kick;
    mod softban {
        use std::sync::Arc;
        use serenity::{
            all::{
                Context, CreateEmbed, CreateMessage, Mentionable, Message, Permissions,
            },
            async_trait,
        };
        use sqlx::query;
        use tracing::{error, warn};
        use crate::{
            SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError,
            lexer::{InferType, Token},
            transformers::Transformers,
            utils::{LogType, guild_log, message_and_dm, tinyid},
        };
        use ouroboros_macros::command;
        pub struct Softban;
        impl Softban {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Softban {
            fn get_name(&self) -> &'static str {
                "softban"
            }
            fn get_short(&self) -> &'static str {
                "Softbans a member from the server"
            }
            fn get_full(&self) -> &'static str {
                "Bans and immediately unbans a member from the server and leaves a note in the users log. \
        Useful for clearing out messages without permanent consequences. \
        Clears 1 day of messages."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::Member("user", true),
                        CommandSyntax::Consume("reason"),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let member = {
                    let Some(Token { contents: Some(CommandArgument::Member(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("member", Some("Member")))
                        })
                    };
                    b
                };
                let reason: Option<String> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::String(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let member = member;
                    let reason = reason;
                    let __ret: Result<(), CommandError> = {
                        let inferred = args
                            .first()
                            .map(|a| match a.inferred {
                                Some(InferType::Message) => true,
                                _ => false,
                            })
                            .unwrap_or(false);
                        let mut reason = reason
                            .map(|s| {
                                if s.is_empty() || s.chars().all(char::is_whitespace) {
                                    String::from("No reason provided")
                                } else {
                                    s
                                }
                            })
                            .unwrap_or(String::from("No reason provided"));
                        if reason.len() > 500 {
                            reason.truncate(500);
                            reason.push_str("...");
                        }
                        let db_id = tinyid().await;
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(db_id);
                                    let arg1 = &(msg
                                        .guild_id
                                        .map(|g| g.get() as i64)
                                        .unwrap_or(0));
                                    let arg2 = &(member.user.id.get() as i64);
                                    let arg3 = &(msg.author.id.get() as i64);
                                    let arg4 = &(reason.as_str());
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg1);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            i64,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg4);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            5usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg2)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg3)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg4),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg2).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg3).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg4).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                        "INSERT INTO actions (id, type, guild_id, user_id, moderator_id, reason) VALUES ($1, 'softban', $2, $3, $4, $5)",
                                        query_args,
                                    )
                                }
                            }
                        }
                            .execute(SQL.get().unwrap())
                            .await;
                        if let Err(err) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\softban.rs:101",
                                            "Ouroboros::commands::softban",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\softban.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(101u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::softban",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Got error while softbanning; err = {0:?}",
                                                                err,
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!(
                                                                                        "Got error while softbanning; err = {0:?}",
                                                                                        err,
                                                                                    ) as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not softban member"),
                                hint: Some(String::from("please try again later")),
                                arg: None,
                            });
                        }
                        if let Err(err) = member
                            .ban_with_reason(&ctx.http, 1, &reason)
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\softban.rs:110",
                                            "Ouroboros::commands::softban",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\softban.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(110u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::softban",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Got error while softbanning; err = {0:?}",
                                                                err,
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!(
                                                                                        "Got error while softbanning; err = {0:?}",
                                                                                        err,
                                                                                    ) as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            if {
                                {
                                    #[allow(clippy::all)]
                                    {
                                        use ::sqlx::Arguments as _;
                                        let arg0 = &(db_id);
                                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                        if false {
                                            use ::sqlx::ty_match::{
                                                WrapSameExt as _, MatchBorrowExt as _,
                                            };
                                            let expr = ::sqlx::ty_match::dupe_value(arg0);
                                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                                &str,
                                                _,
                                            >::new(&expr)
                                                .wrap_same();
                                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                ty_check,
                                                &expr,
                                            );
                                            _ty_check = match_borrow.match_borrow();
                                            ::core::panicking::panic(
                                                "internal error: entered unreachable code",
                                            );
                                        }
                                        let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                            '_,
                                        >::default();
                                        query_args
                                            .reserve(
                                                1usize,
                                                0
                                                    + ::sqlx::encode::Encode::<
                                                        sqlx::postgres::Postgres,
                                                    >::size_hint(arg0),
                                            );
                                        let query_args = ::core::result::Result::<
                                            _,
                                            ::sqlx::error::BoxDynError,
                                        >::Ok(query_args)
                                            .and_then(move |mut query_args| {
                                                query_args.add(arg0).map(move |()| query_args)
                                            });
                                        ::sqlx::__query_with_result::<
                                            sqlx::postgres::Postgres,
                                            _,
                                        >("DELETE FROM actions WHERE id = $1", query_args)
                                    }
                                }
                            }
                                .execute(SQL.get().unwrap())
                                .await
                                .is_err()
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\softban.rs:117",
                                                "Ouroboros::commands::softban",
                                                ::tracing::Level::ERROR,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\softban.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(117u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::softban",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::ERROR {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Got an error while softbanning and an error with the database! Stray softban entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                    db_id,
                                                                    err,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::ERROR {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!(
                                                                                            "Got an error while softbanning and an error with the database! Stray softban entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                                            db_id,
                                                                                            err,
                                                                                        ) as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            return Err(CommandError {
                                title: String::from("Could not softban member"),
                                hint: Some(
                                    String::from(
                                        "check if the bot has the ban members permission or try again later",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        if let Err(err) = member.unban(&ctx.http).await {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\softban.rs:132",
                                            "Ouroboros::commands::softban",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\softban.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(132u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::softban",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Got error while softunbanning; err = {0:?}",
                                                                err,
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!(
                                                                                        "Got error while softunbanning; err = {0:?}",
                                                                                        err,
                                                                                    ) as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from(
                                    "Member banned, but bot ran into an error trying to unban",
                                ),
                                hint: Some(
                                    String::from(
                                        "manually unban the member and check if the bot has the ban members permission",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        if inferred && let Some(reply) = msg.referenced_message.clone() {
                            let _ = reply.delete(&ctx.http).await;
                        }
                        message_and_dm(
                                &ctx,
                                &msg,
                                &member.user,
                                |a| {
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "**{0} SOFTBANNED**\n-# Log ID: `{1}`{2}\n```\n{3}\n```",
                                                member.mention(),
                                                db_id,
                                                a,
                                                reason,
                                            ),
                                        )
                                    })
                                },
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "**KICKED**\n-# Server: {0}\n```\n{1}\n```",
                                            msg
                                                .guild(&ctx.cache)
                                                .map(|g| g.name.clone())
                                                .unwrap_or(String::from("UNKNOWN_GUILD")),
                                            reason,
                                        ),
                                    )
                                }),
                                inferred,
                                false,
                            )
                            .await;
                        guild_log(
                                &ctx.http,
                                LogType::MemberSoftban,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**MEMBER SOFTBANNED**\n-# Log ID: `{4}` | Actor: {0} `{1}` | Target: {2} `{3}`\n```\n{5}\n```",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            member.mention(),
                                                            member.user.id.get(),
                                                            db_id,
                                                            reason,
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::reply_member),
                        Arc::new(Transformers::reply_consume),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::KICK_MEMBERS]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use softban::Softban;
    mod ban {
        use std::sync::Arc;
        use chrono::{Duration, Utc};
        use serenity::{
            all::{
                Context, CreateEmbed, CreateMessage, Mentionable, Message, Permissions,
            },
            async_trait,
        };
        use sqlx::query;
        use tracing::{error, warn};
        use crate::{
            SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError,
            lexer::{InferType, Token},
            transformers::Transformers,
            utils::{LogType, get_args, guild_log, message_and_dm, tinyid},
        };
        use ouroboros_macros::command;
        pub struct Ban;
        impl Ban {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Ban {
            fn get_name(&self) -> &'static str {
                "ban"
            }
            fn get_short(&self) -> &'static str {
                "Bans a member from the server and deletes their messages"
            }
            fn get_full(&self) -> &'static str {
                "Bans from the server and leaves a note in the users log. \
        Defaults to permanent if no duration is provided. \
        Use 0 for the duration to make the ban permanent. \
        If the duration cannot be resolved it will default to permanent. \
        Ban expiry is checked every 5 minutes."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::Member("member", true),
                        CommandSyntax::Duration("duration", false),
                        CommandSyntax::Number("days", false),
                        CommandSyntax::Reason("reason"),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        &CommandParameter {
                            name: "clear",
                            short: "c",
                            transformer: &Transformers::i32,
                            desc: "Amount of messages to clear (in days 0-7)",
                        },
                        &CommandParameter {
                            name: "silent",
                            short: "s",
                            transformer: &Transformers::none,
                            desc: "Disables DMing the target with a reason",
                        },
                    ]),
                )
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let user = {
                    let Some(Token { contents: Some(CommandArgument::User(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("user", Some("User")))
                        })
                    };
                    b
                };
                let duration: Option<Duration> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::Duration(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                let reason: Option<String> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::String(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let user = user;
                    let duration = duration;
                    let reason = reason;
                    let __ret: Result<(), CommandError> = {
                        let inferred = args
                            .first()
                            .map(|a| match a.inferred {
                                Some(InferType::Message) => true,
                                _ => false,
                            })
                            .unwrap_or(false);
                        let duration = duration.unwrap_or(Duration::zero());
                        let reason = reason
                            .map(|s| {
                                if s.is_empty() || s.chars().all(char::is_whitespace) {
                                    String::new()
                                } else {
                                    s
                                }
                            })
                            .unwrap_or(String::new());
                        let (args, mut reason) = get_args(
                                &ctx,
                                &msg,
                                reason,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        ("c", "clear", &Transformers::i32),
                                        ("clear", "clear", &Transformers::i32),
                                        ("s", "silent", &Transformers::none),
                                        ("silent", "silent", &Transformers::none),
                                    ]),
                                ),
                            )
                            .await
                            .unwrap_or_default();
                        if reason.is_empty() {
                            reason = String::from("No reason provided");
                        }
                        let days = {
                            if let Some(arg) = args.get("clear") {
                                if !arg.0 {
                                    0
                                } else if let CommandArgument::i32(days) = arg.1 {
                                    days.clamp(0, 7) as u8
                                } else {
                                    1
                                }
                            } else {
                                1
                            }
                        };
                        if reason.len() > 500 {
                            reason.truncate(500);
                            reason.push_str("...");
                        }
                        let db_id = tinyid().await;
                        let time_string = if !duration.is_zero() {
                            let (time, mut unit) = match () {
                                _ if (duration.num_days() as f64 / 365.0).fract() == 0.0
                                    && duration.num_days() >= 365 => {
                                    (duration.num_days() / 365, String::from("year"))
                                }
                                _ if (duration.num_days() as f64 / 30.0).fract() == 0.0
                                    && duration.num_days() >= 30 => {
                                    (duration.num_days() / 30, String::from("month"))
                                }
                                _ if duration.num_days() != 0 => {
                                    (duration.num_days(), String::from("day"))
                                }
                                _ if duration.num_hours() != 0 => {
                                    (duration.num_hours(), String::from("hour"))
                                }
                                _ if duration.num_minutes() != 0 => {
                                    (duration.num_minutes(), String::from("minute"))
                                }
                                _ if duration.num_seconds() != 0 => {
                                    (duration.num_seconds(), String::from("second"))
                                }
                                _ => (0, String::new()),
                            };
                            if time > 1 {
                                unit += "s";
                            }
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("for {0} {1}", time, unit),
                                )
                            })
                        } else {
                            String::from("permanent")
                        };
                        let duration = if duration.is_zero() {
                            None
                        } else {
                            Some((Utc::now() + duration).naive_utc())
                        };
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(msg
                                        .guild_id
                                        .map(|g| g.get() as i64)
                                        .unwrap_or(0));
                                    let arg1 = &(user.id.get() as i64);
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            i64,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            2usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                        "UPDATE actions SET active = false WHERE guild_id = $1 AND user_id = $2 AND type = 'ban'",
                                        query_args,
                                    )
                                }
                            }
                        }
                            .execute(SQL.get().unwrap())
                            .await;
                        if let Err(err) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\ban.rs:170",
                                            "Ouroboros::commands::ban",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\ban.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(170u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::ban",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while banning; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while banning; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not ban member"),
                                hint: Some(String::from("please try again later")),
                                arg: None,
                            });
                        }
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(db_id);
                                    let arg1 = &(msg
                                        .guild_id
                                        .map(|g| g.get() as i64)
                                        .unwrap_or(0));
                                    let arg2 = &(user.id.get() as i64);
                                    let arg3 = &(msg.author.id.get() as i64);
                                    let arg4 = &(reason.as_str());
                                    let arg5 = &(duration);
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg1);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            i64,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg4);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg5);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            sqlx::types::chrono::NaiveDateTime,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            6usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg2)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg3)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg4)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg5),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg2).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg3).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg4).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg5).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                        "INSERT INTO actions (id, type, guild_id, user_id, moderator_id, reason, expires_at) VALUES ($1, 'ban', $2, $3, $4, $5, $6)",
                                        query_args,
                                    )
                                }
                            }
                        }
                            .execute(SQL.get().unwrap())
                            .await;
                        if let Err(err) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\ban.rs:189",
                                            "Ouroboros::commands::ban",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\ban.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(189u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::ban",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while banning; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while banning; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not ban member"),
                                hint: Some(String::from("please try again later")),
                                arg: None,
                            });
                        }
                        if let Err(err) = msg
                            .guild_id
                            .unwrap()
                            .ban_with_reason(&ctx.http, &user, days, &reason)
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\ban.rs:203",
                                            "Ouroboros::commands::ban",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\ban.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(203u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::ban",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while banning; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while banning; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            if {
                                {
                                    #[allow(clippy::all)]
                                    {
                                        use ::sqlx::Arguments as _;
                                        let arg0 = &(db_id);
                                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                        if false {
                                            use ::sqlx::ty_match::{
                                                WrapSameExt as _, MatchBorrowExt as _,
                                            };
                                            let expr = ::sqlx::ty_match::dupe_value(arg0);
                                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                                &str,
                                                _,
                                            >::new(&expr)
                                                .wrap_same();
                                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                ty_check,
                                                &expr,
                                            );
                                            _ty_check = match_borrow.match_borrow();
                                            ::core::panicking::panic(
                                                "internal error: entered unreachable code",
                                            );
                                        }
                                        let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                            '_,
                                        >::default();
                                        query_args
                                            .reserve(
                                                1usize,
                                                0
                                                    + ::sqlx::encode::Encode::<
                                                        sqlx::postgres::Postgres,
                                                    >::size_hint(arg0),
                                            );
                                        let query_args = ::core::result::Result::<
                                            _,
                                            ::sqlx::error::BoxDynError,
                                        >::Ok(query_args)
                                            .and_then(move |mut query_args| {
                                                query_args.add(arg0).map(move |()| query_args)
                                            });
                                        ::sqlx::__query_with_result::<
                                            sqlx::postgres::Postgres,
                                            _,
                                        >("DELETE FROM actions WHERE id = $1", query_args)
                                    }
                                }
                            }
                                .execute(SQL.get().unwrap())
                                .await
                                .is_err()
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\ban.rs:210",
                                                "Ouroboros::commands::ban",
                                                ::tracing::Level::ERROR,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\ban.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(210u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::ban",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::ERROR {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Got an error while banning and an error with the database! Stray ban entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                    db_id,
                                                                    err,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::ERROR {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!(
                                                                                            "Got an error while banning and an error with the database! Stray ban entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                                            db_id,
                                                                                            err,
                                                                                        ) as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            return Err(CommandError {
                                title: String::from("Could not ban member"),
                                hint: Some(
                                    String::from(
                                        "check if the bot has the ban members permission or try again later",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        if inferred && let Some(reply) = msg.referenced_message.clone() {
                            let _ = reply.delete(&ctx.http).await;
                        }
                        let mut clear_msg = String::new();
                        if days != 0 {
                            clear_msg = ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(" | Cleared {0} days of messages", days),
                                )
                            });
                        }
                        message_and_dm(
                                &ctx,
                                &msg,
                                &user,
                                |a| ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "**{0} BANNED**\n-# Log ID: `{1}` | Duration: {2}{3}{4}\n```\n{5}\n```",
                                            user.mention(),
                                            db_id,
                                            time_string,
                                            clear_msg,
                                            a,
                                            reason,
                                        ),
                                    )
                                }),
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "**BANNED**\n-# Server: {0} | Duration: {1}\n```\n{2}\n```",
                                            msg
                                                .guild(&ctx.cache)
                                                .map(|g| g.name.clone())
                                                .unwrap_or(String::from("UNKNOWN_GUILD")),
                                            time_string,
                                            reason,
                                        ),
                                    )
                                }),
                                inferred,
                                args.get("silent").is_some(),
                            )
                            .await;
                        guild_log(
                                &ctx.http,
                                LogType::MemberBan,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**MEMBER BANNED**\n-# Log ID: `{4}` | Actor: {0} `{1}` | Target: {2} `{3}` | Duration: {5}{6}\n```\n{7}\n```",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            user.mention(),
                                                            user.id.get(),
                                                            db_id,
                                                            time_string,
                                                            clear_msg,
                                                            reason,
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::reply_user),
                        Arc::new(Transformers::maybe_duration),
                        Arc::new(Transformers::consume),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::BAN_MEMBERS]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use ban::Ban;
    mod mute {
        use std::sync::Arc;
        use chrono::{Duration, Utc};
        use serenity::{
            all::{
                Context, CreateEmbed, CreateMessage, EditMember, Mentionable, Message,
                Permissions,
            },
            async_trait,
        };
        use sqlx::query;
        use tracing::{error, warn};
        use crate::{
            SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError,
            lexer::{InferType, Token},
            transformers::Transformers,
            utils::{LogType, guild_log, message_and_dm, tinyid},
        };
        use ouroboros_macros::command;
        pub struct Mute;
        impl Mute {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Mute {
            fn get_name(&self) -> &'static str {
                "mute"
            }
            fn get_short(&self) -> &'static str {
                "Uses the Discord timeout feature on a member"
            }
            fn get_full(&self) -> &'static str {
                "Uses the Discord timeout feature on a member and leaves a note in the users log. \
        Has a max duration of 28 days. Duration (including the removal of the timeout) is managed by Discord"
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::Member("member", true),
                        CommandSyntax::Duration("duration", true),
                        CommandSyntax::Reason("reason"),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let member = {
                    let Some(Token { contents: Some(CommandArgument::Member(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("member", Some("Member")))
                        })
                    };
                    b
                };
                let duration: Option<Duration> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::Duration(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                let reason: Option<String> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::String(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let member = member;
                    let duration = duration;
                    let reason = reason;
                    let __ret: Result<(), CommandError> = {
                        let inferred = args
                            .first()
                            .map(|a| match a.inferred {
                                Some(InferType::Message) => true,
                                _ => false,
                            })
                            .unwrap_or(false);
                        let duration = duration.unwrap_or(Duration::zero());
                        let mut reason = reason
                            .map(|s| {
                                if s.is_empty() || s.chars().all(char::is_whitespace) {
                                    String::from("No reason provided")
                                } else {
                                    s
                                }
                            })
                            .unwrap_or(String::from("No reason provided"));
                        if reason.len() > 500 {
                            reason.truncate(500);
                            reason.push_str("...");
                        }
                        let db_id = tinyid().await;
                        let time_string = if !duration.is_zero() {
                            let (time, mut unit) = match () {
                                _ if (duration.num_days() as f64 / 365.0).fract() == 0.0
                                    && duration.num_days() >= 365 => {
                                    (duration.num_days() / 365, String::from("year"))
                                }
                                _ if (duration.num_days() as f64 / 30.0).fract() == 0.0
                                    && duration.num_days() >= 30 => {
                                    (duration.num_days() / 30, String::from("month"))
                                }
                                _ if duration.num_days() != 0 => {
                                    (duration.num_days(), String::from("day"))
                                }
                                _ if duration.num_hours() != 0 => {
                                    (duration.num_hours(), String::from("hour"))
                                }
                                _ if duration.num_minutes() != 0 => {
                                    (duration.num_minutes(), String::from("minute"))
                                }
                                _ if duration.num_seconds() != 0 => {
                                    (duration.num_seconds(), String::from("second"))
                                }
                                _ => (0, String::new()),
                            };
                            if time > 1 {
                                unit += "s";
                            }
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(format_args!("{0} {1}", time, unit))
                            })
                        } else {
                            String::from("permanent")
                        };
                        let duration = if duration.is_zero() {
                            None
                        } else {
                            Some(Utc::now() + duration)
                        };
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(db_id);
                                    let arg1 = &(msg
                                        .guild_id
                                        .map(|g| g.get() as i64)
                                        .unwrap_or(0));
                                    let arg2 = &(member.user.id.get() as i64);
                                    let arg3 = &(msg.author.id.get() as i64);
                                    let arg4 = &(reason.as_str());
                                    let arg5 = &(duration.map(|d| d.naive_utc()));
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg1);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            i64,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg4);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg5);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            sqlx::types::chrono::NaiveDateTime,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            6usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg2)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg3)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg4)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg5),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg2).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg3).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg4).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg5).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                        "INSERT INTO actions (id, type, guild_id, user_id, moderator_id, reason, expires_at, last_reapplied_at) VALUES ($1, 'mute', $2, $3, $4, $5, $6, NOW())",
                                        query_args,
                                    )
                                }
                            }
                        }
                            .execute(SQL.get().unwrap())
                            .await;
                        if let Err(err) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\mute.rs:143",
                                            "Ouroboros::commands::mute",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\mute.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(143u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::mute",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Got error while timing out; err = {0:?}",
                                                                err,
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!(
                                                                                        "Got error while timing out; err = {0:?}",
                                                                                        err,
                                                                                    ) as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not time member out"),
                                hint: Some(String::from("please try again later")),
                                arg: None,
                            });
                        }
                        let audit_reason = ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Ouroboros Managed Mute: log id `{0}`. Please use Ouroboros to unmute to avoid accidental re-application!",
                                    db_id,
                                ),
                            )
                        });
                        let edit = if let Some(duration) = duration {
                            EditMember::new()
                                .audit_log_reason(audit_reason.as_str())
                                .disable_communication_until_datetime(duration.into())
                        } else {
                            EditMember::new()
                                .audit_log_reason(&reason)
                                .disable_communication_until_datetime(
                                    (Utc::now() + Duration::days(27)).into(),
                                )
                        };
                        if let Err(err) = member
                            .guild_id
                            .edit_member(&ctx.http, &member, edit)
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\mute.rs:166",
                                            "Ouroboros::commands::mute",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\mute.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(166u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::mute",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Got error while timinng out; err = {0:?}",
                                                                err,
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!(
                                                                                        "Got error while timinng out; err = {0:?}",
                                                                                        err,
                                                                                    ) as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            if {
                                {
                                    #[allow(clippy::all)]
                                    {
                                        use ::sqlx::Arguments as _;
                                        let arg0 = &(db_id);
                                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                        if false {
                                            use ::sqlx::ty_match::{
                                                WrapSameExt as _, MatchBorrowExt as _,
                                            };
                                            let expr = ::sqlx::ty_match::dupe_value(arg0);
                                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                                &str,
                                                _,
                                            >::new(&expr)
                                                .wrap_same();
                                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                ty_check,
                                                &expr,
                                            );
                                            _ty_check = match_borrow.match_borrow();
                                            ::core::panicking::panic(
                                                "internal error: entered unreachable code",
                                            );
                                        }
                                        let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                            '_,
                                        >::default();
                                        query_args
                                            .reserve(
                                                1usize,
                                                0
                                                    + ::sqlx::encode::Encode::<
                                                        sqlx::postgres::Postgres,
                                                    >::size_hint(arg0),
                                            );
                                        let query_args = ::core::result::Result::<
                                            _,
                                            ::sqlx::error::BoxDynError,
                                        >::Ok(query_args)
                                            .and_then(move |mut query_args| {
                                                query_args.add(arg0).map(move |()| query_args)
                                            });
                                        ::sqlx::__query_with_result::<
                                            sqlx::postgres::Postgres,
                                            _,
                                        >("DELETE FROM actions WHERE id = $1", query_args)
                                    }
                                }
                            }
                                .execute(SQL.get().unwrap())
                                .await
                                .is_err()
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\mute.rs:173",
                                                "Ouroboros::commands::mute",
                                                ::tracing::Level::ERROR,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\mute.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(173u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::mute",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::ERROR {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Got an error while timing out and an error with the database! Stray timeout entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                    db_id,
                                                                    err,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::ERROR {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!(
                                                                                            "Got an error while timing out and an error with the database! Stray timeout entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                                            db_id,
                                                                                            err,
                                                                                        ) as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            return Err(CommandError {
                                title: String::from("Could not time member out"),
                                hint: Some(
                                    String::from(
                                        "check if the bot has the timeout members permission or try again later",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        if inferred && let Some(reply) = msg.referenced_message.clone() {
                            let _ = reply.delete(&ctx.http).await;
                        }
                        message_and_dm(
                                &ctx,
                                &msg,
                                &member.user,
                                |a| ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "**{0} TIMEOUT**\n-# Log ID: `{1}` | Duration: {2}{3}\n```\n{4}\n```",
                                            member.mention(),
                                            db_id,
                                            time_string,
                                            a,
                                            reason,
                                        ),
                                    )
                                }),
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "**TIMEOUT**\n-# Server: {0} | Duration: {1}\n```\n{2}\n```",
                                            msg
                                                .guild(&ctx.cache)
                                                .map(|g| g.name.clone())
                                                .unwrap_or(String::from("UNKNOWN_GUILD")),
                                            time_string,
                                            reason,
                                        ),
                                    )
                                }),
                                inferred,
                                false,
                            )
                            .await;
                        guild_log(
                                &ctx.http,
                                LogType::MemberMute,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**MEMBER TIMEOUT**\n-# Log ID: `{4}` | Actor: {0} `{1}` | Target: {2} `{3}` | Duration: {5}\n```\n{6}\n```",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            member.mention(),
                                                            member.user.id.get(),
                                                            db_id,
                                                            time_string,
                                                            reason,
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::reply_member),
                        Arc::new(Transformers::maybe_duration),
                        Arc::new(Transformers::reply_consume),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::MODERATE_MEMBERS]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use mute::Mute;
    mod unban {
        use std::{sync::Arc, time::Duration};
        use ouroboros_macros::command;
        use serenity::{
            all::{
                Context, CreateAllowedMentions, CreateEmbed, CreateMessage, Mentionable,
                Message, Permissions,
            },
            async_trait,
        };
        use sqlx::query;
        use tokio::time::sleep;
        use tracing::{error, warn};
        use crate::{
            SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError,
            lexer::{InferType, Token},
            transformers::Transformers, utils::{LogType, guild_log, tinyid},
        };
        pub struct Unban;
        impl Unban {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Unban {
            fn get_name(&self) -> &'static str {
                "unban"
            }
            fn get_short(&self) -> &'static str {
                "Unbans a member from the server"
            }
            fn get_full(&self) -> &'static str {
                "Unbans a member from the server."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::User("user", true),
                        CommandSyntax::String("reason", false),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let user = {
                    let Some(Token { contents: Some(CommandArgument::User(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("user", Some("User")))
                        })
                    };
                    b
                };
                let reason: Option<String> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::String(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let user = user;
                    let reason = reason;
                    let __ret: Result<(), CommandError> = {
                        let inferred = args
                            .first()
                            .map(|a| match a.inferred {
                                Some(InferType::Message) => true,
                                _ => false,
                            })
                            .unwrap_or(false);
                        let mut reason = reason
                            .map(|s| {
                                if s.is_empty() || s.chars().all(char::is_whitespace) {
                                    String::from("No reason provided")
                                } else {
                                    s
                                }
                            })
                            .unwrap_or(String::from("No reason provided"));
                        if reason.len() > 500 {
                            reason.truncate(500);
                            reason.push_str("...");
                        }
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(msg
                                        .guild_id
                                        .map(|g| g.get() as i64)
                                        .unwrap_or(0));
                                    let arg1 = &(user.id.get() as i64);
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            i64,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            2usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                        "UPDATE actions SET active = false, expires_at = NULL WHERE guild_id = $1 AND user_id = $2 AND type = 'ban' AND active = true;",
                                        query_args,
                                    )
                                }
                            }
                        }
                            .execute(SQL.get().unwrap())
                            .await;
                        if let Err(err) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\unban.rs:98",
                                            "Ouroboros::commands::unban",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\unban.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(98u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::unban",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while unbanning; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while unbanning; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not unban member"),
                                hint: Some(String::from("please try again later")),
                                arg: None,
                            });
                        }
                        let db_id = tinyid().await;
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(db_id);
                                    let arg1 = &(msg
                                        .guild_id
                                        .map(|g| g.get() as i64)
                                        .unwrap_or(0));
                                    let arg2 = &(user.id.get() as i64);
                                    let arg3 = &(msg.author.id.get() as i64);
                                    let arg4 = &(reason.clone());
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg1);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            i64,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg4);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            5usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg2)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg3)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg4),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg2).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg3).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg4).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                        "INSERT INTO actions (id, type, guild_id, user_id, moderator_id, reason) VALUES ($1, 'unban', $2, $3, $4, $5)",
                                        query_args,
                                    )
                                }
                            }
                        }
                            .execute(SQL.get().unwrap())
                            .await;
                        if let Err(err) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\unban.rs:118",
                                            "Ouroboros::commands::unban",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\unban.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(118u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::unban",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while unbanning; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while unbanning; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not unban member"),
                                hint: Some(String::from("please try again later")),
                                arg: None,
                            });
                        }
                        if let Err(err) = ctx
                            .http
                            .as_ref()
                            .remove_ban(msg.guild_id.unwrap(), user.id, Some(&reason))
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\unban.rs:132",
                                            "Ouroboros::commands::unban",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\unban.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(132u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::unban",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while unbanning; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while unbanning; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            if {
                                {
                                    #[allow(clippy::all)]
                                    {
                                        use ::sqlx::Arguments as _;
                                        let arg0 = &(db_id);
                                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                        if false {
                                            use ::sqlx::ty_match::{
                                                WrapSameExt as _, MatchBorrowExt as _,
                                            };
                                            let expr = ::sqlx::ty_match::dupe_value(arg0);
                                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                                &str,
                                                _,
                                            >::new(&expr)
                                                .wrap_same();
                                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                ty_check,
                                                &expr,
                                            );
                                            _ty_check = match_borrow.match_borrow();
                                            ::core::panicking::panic(
                                                "internal error: entered unreachable code",
                                            );
                                        }
                                        let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                            '_,
                                        >::default();
                                        query_args
                                            .reserve(
                                                1usize,
                                                0
                                                    + ::sqlx::encode::Encode::<
                                                        sqlx::postgres::Postgres,
                                                    >::size_hint(arg0),
                                            );
                                        let query_args = ::core::result::Result::<
                                            _,
                                            ::sqlx::error::BoxDynError,
                                        >::Ok(query_args)
                                            .and_then(move |mut query_args| {
                                                query_args.add(arg0).map(move |()| query_args)
                                            });
                                        ::sqlx::__query_with_result::<
                                            sqlx::postgres::Postgres,
                                            _,
                                        >("DELETE FROM actions WHERE id = $1", query_args)
                                    }
                                }
                            }
                                .execute(SQL.get().unwrap())
                                .await
                                .is_err()
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\unban.rs:139",
                                                "Ouroboros::commands::unban",
                                                ::tracing::Level::ERROR,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\unban.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(139u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::unban",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::ERROR {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Got an error while unbanning and an error with the database! Stray unban entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                    db_id,
                                                                    err,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::ERROR {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!(
                                                                                            "Got an error while unbanning and an error with the database! Stray unban entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                                            db_id,
                                                                                            err,
                                                                                        ) as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            return Err(CommandError {
                                title: String::from("Could not unban member"),
                                hint: Some(
                                    String::from(
                                        "check if the bot has the ban members permission or try again later",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        let reply = CreateMessage::new()
                            .add_embed(
                                CreateEmbed::new()
                                    .description(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "**{0} UNBANNED**\n-# Log ID: `{1}`\n```\n{2}\n```",
                                                    user.mention(),
                                                    db_id,
                                                    reason,
                                                ),
                                            )
                                        }),
                                    )
                                    .color(BRAND_BLUE),
                            )
                            .reference_message(&msg)
                            .allowed_mentions(
                                CreateAllowedMentions::new().replied_user(false),
                            );
                        let reply_msg = msg
                            .channel_id
                            .send_message(&ctx.http, reply)
                            .await;
                        guild_log(
                                &ctx.http,
                                LogType::MemberUnban,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**MEMBER UNBANNED**\n-# Log ID: `{4}` | Actor: {0} `{1}` | Target: {2} `{3}`\n```\n{5}\n```",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            user.mention(),
                                                            user.id.get(),
                                                            db_id,
                                                            reason,
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        let reply_msg = match reply_msg {
                            Ok(m) => m,
                            Err(err) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\unban.rs:188",
                                                "Ouroboros::commands::unban",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\unban.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(188u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::unban",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Ok(());
                            }
                        };
                        if inferred && let Some(reply) = msg.referenced_message.clone() {
                            let _ = reply.delete(&ctx.http).await;
                        }
                        if inferred {
                            let http = ctx.http.clone();
                            tokio::spawn(async move {
                                sleep(Duration::from_secs(5)).await;
                                let _ = msg.delete(&http).await;
                                let _ = reply_msg.delete(&http).await;
                            });
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::reply_user),
                        Arc::new(Transformers::reply_consume),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::BAN_MEMBERS]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use unban::Unban;
    mod unmute {
        use std::{sync::Arc, time::Duration};
        use ouroboros_macros::command;
        use serenity::{
            all::{
                Context, CreateAllowedMentions, CreateEmbed, CreateMessage, Mentionable,
                Message, Permissions,
            },
            async_trait,
        };
        use sqlx::query;
        use tokio::time::sleep;
        use tracing::{error, warn};
        use crate::{
            SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError,
            lexer::{InferType, Token},
            transformers::Transformers, utils::{LogType, guild_log, tinyid},
        };
        pub struct Unmute;
        impl Unmute {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Unmute {
            fn get_name(&self) -> &'static str {
                "unmute"
            }
            fn get_short(&self) -> &'static str {
                "Unmutes a member in the server"
            }
            fn get_full(&self) -> &'static str {
                "Unmutes a member in the server."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::Member("member", true),
                        CommandSyntax::String("reason", false),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let member = {
                    let Some(Token { contents: Some(CommandArgument::Member(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("member", Some("Member")))
                        })
                    };
                    b
                };
                let reason: Option<String> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::String(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let mut member = member;
                    let reason = reason;
                    let __ret: Result<(), CommandError> = {
                        let inferred = args
                            .first()
                            .map(|a| match a.inferred {
                                Some(InferType::Message) => true,
                                _ => false,
                            })
                            .unwrap_or(false);
                        let mut reason = reason
                            .map(|s| {
                                if s.is_empty() || s.chars().all(char::is_whitespace) {
                                    String::from("No reason provided")
                                } else {
                                    s
                                }
                            })
                            .unwrap_or(String::from("No reason provided"));
                        if reason.len() > 500 {
                            reason.truncate(500);
                            reason.push_str("...");
                        }
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(msg
                                        .guild_id
                                        .map(|g| g.get() as i64)
                                        .unwrap_or(0));
                                    let arg1 = &(member.user.id.get() as i64);
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            i64,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            2usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                        "UPDATE actions SET active = false, expires_at = NULL WHERE guild_id = $1 AND user_id = $2 AND type = 'mute' AND active = true;",
                                        query_args,
                                    )
                                }
                            }
                        }
                            .execute(SQL.get().unwrap())
                            .await;
                        if let Err(err) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\unmute.rs:98",
                                            "Ouroboros::commands::unmute",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\unmute.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(98u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::unmute",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while unmuting; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while unmuting; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not unmute member"),
                                hint: Some(String::from("please try again later")),
                                arg: None,
                            });
                        }
                        let db_id = tinyid().await;
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(db_id);
                                    let arg1 = &(msg
                                        .guild_id
                                        .map(|g| g.get() as i64)
                                        .unwrap_or(0));
                                    let arg2 = &(member.user.id.get() as i64);
                                    let arg3 = &(msg.author.id.get() as i64);
                                    let arg4 = &(reason.clone());
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg1);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            i64,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg4);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            5usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg2)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg3)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg4),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg2).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg3).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg4).map(move |()| query_args)
                                        });
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                        "INSERT INTO actions (id, type, guild_id, user_id, moderator_id, reason) VALUES ($1, 'unmute', $2, $3, $4, $5)",
                                        query_args,
                                    )
                                }
                            }
                        }
                            .execute(SQL.get().unwrap())
                            .await;
                        if let Err(err) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\unmute.rs:118",
                                            "Ouroboros::commands::unmute",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\unmute.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(118u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::unmute",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while unmuting; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while unmuting; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not unmute member"),
                                hint: Some(String::from("please try again later")),
                                arg: None,
                            });
                        }
                        if let Err(err) = member.enable_communication(&ctx.http).await {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\unmute.rs:127",
                                            "Ouroboros::commands::unmute",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\unmute.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(127u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::unmute",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while unmuting; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while unmuting; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            if {
                                {
                                    #[allow(clippy::all)]
                                    {
                                        use ::sqlx::Arguments as _;
                                        let arg0 = &(db_id);
                                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                        if false {
                                            use ::sqlx::ty_match::{
                                                WrapSameExt as _, MatchBorrowExt as _,
                                            };
                                            let expr = ::sqlx::ty_match::dupe_value(arg0);
                                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                                &str,
                                                _,
                                            >::new(&expr)
                                                .wrap_same();
                                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                ty_check,
                                                &expr,
                                            );
                                            _ty_check = match_borrow.match_borrow();
                                            ::core::panicking::panic(
                                                "internal error: entered unreachable code",
                                            );
                                        }
                                        let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                            '_,
                                        >::default();
                                        query_args
                                            .reserve(
                                                1usize,
                                                0
                                                    + ::sqlx::encode::Encode::<
                                                        sqlx::postgres::Postgres,
                                                    >::size_hint(arg0),
                                            );
                                        let query_args = ::core::result::Result::<
                                            _,
                                            ::sqlx::error::BoxDynError,
                                        >::Ok(query_args)
                                            .and_then(move |mut query_args| {
                                                query_args.add(arg0).map(move |()| query_args)
                                            });
                                        ::sqlx::__query_with_result::<
                                            sqlx::postgres::Postgres,
                                            _,
                                        >("DELETE FROM actions WHERE id = $1", query_args)
                                    }
                                }
                            }
                                .execute(SQL.get().unwrap())
                                .await
                                .is_err()
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\unmute.rs:134",
                                                "Ouroboros::commands::unmute",
                                                ::tracing::Level::ERROR,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\unmute.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(134u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::unmute",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::ERROR {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Got an error while unmuting and an error with the database! Stray unmute entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                    db_id,
                                                                    err,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::ERROR {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!(
                                                                                            "Got an error while unmuting and an error with the database! Stray unmute entry in DB & manual action required; id = {0}; err = {1:?}",
                                                                                            db_id,
                                                                                            err,
                                                                                        ) as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            return Err(CommandError {
                                title: String::from("Could not unmute member"),
                                hint: Some(
                                    String::from(
                                        "check if the bot has the timeout members permission or try again later",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        let reply = CreateMessage::new()
                            .add_embed(
                                CreateEmbed::new()
                                    .description(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "**{0} UNMUTED**\n-# Log ID: `{1}`\n```\n{2}\n```",
                                                    member.mention(),
                                                    db_id,
                                                    reason,
                                                ),
                                            )
                                        }),
                                    )
                                    .color(BRAND_BLUE),
                            )
                            .reference_message(&msg)
                            .allowed_mentions(
                                CreateAllowedMentions::new().replied_user(false),
                            );
                        let reply_msg = msg
                            .channel_id
                            .send_message(&ctx.http, reply)
                            .await;
                        guild_log(
                                &ctx.http,
                                LogType::MemberUnmute,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**MEMBER UNMUTED**\n-# Log ID: `{4}` | Actor: {0} `{1}` | Target: {2} `{3}`\n```\n{5}\n```",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            member.mention(),
                                                            member.user.id.get(),
                                                            db_id,
                                                            reason,
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        let reply_msg = match reply_msg {
                            Ok(m) => m,
                            Err(err) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\unmute.rs:183",
                                                "Ouroboros::commands::unmute",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\unmute.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(183u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::unmute",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Ok(());
                            }
                        };
                        if inferred && let Some(reply) = msg.referenced_message.clone() {
                            let _ = reply.delete(&ctx.http).await;
                        }
                        if inferred {
                            let http = ctx.http.clone();
                            tokio::spawn(async move {
                                sleep(Duration::from_secs(5)).await;
                                let _ = msg.delete(&http).await;
                                let _ = reply_msg.delete(&http).await;
                            });
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::reply_member),
                        Arc::new(Transformers::reply_consume),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::MODERATE_MEMBERS]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use unmute::Unmute;
    mod purge {
        use std::{collections::HashMap, sync::Arc};
        use chrono::{Duration, Utc};
        use serenity::{
            all::{
                Context, CreateEmbed, CreateMessage, GetMessages, Mentionable, Message,
                Permissions,
            },
            async_trait,
        };
        use tracing::warn;
        use crate::{
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError, lexer::{Token, lex},
            transformers::Transformers, utils::{LogType, guild_log},
        };
        use ouroboros_macros::command;
        pub struct Purge;
        impl Purge {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Purge {
            fn get_name(&self) -> &'static str {
                "purge"
            }
            fn get_short(&self) -> &'static str {
                "Mass deletes a specific amount of messages"
            }
            fn get_full(&self) -> &'static str {
                "Mass deletes a specific amount of messages from a channel. \
        Messages older than 2 weeks are ignored. \
        Count must be between 2 and 99. \
        Optional filters can be applied after the count: \
        \n`+user/+u @ouroboros` -> Message Author \
        \n`+string/+s \"content\"` -> Message Content"
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::Number("count", true),
                        CommandSyntax::Filters,
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let count = {
                    let Some(Token { contents: Some(CommandArgument::i32(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("count", Some("i32")))
                        })
                    };
                    b
                };
                let filters = {
                    let Some(Token { contents: Some(CommandArgument::String(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("filters", Some("String")))
                        })
                    };
                    b
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let count = count;
                    let filters = filters;
                    let __ret: Result<(), CommandError> = {
                        if !(2..=99).contains(&count) {
                            return Err(CommandError {
                                title: String::from(
                                    "Message count must be between 2 and 99",
                                ),
                                hint: None,
                                arg: Some(args.first().unwrap().clone()),
                            });
                        }
                        let mut lex = lex(filters).into_iter().peekable();
                        let mut filters: HashMap<&str, CommandArgument> = HashMap::new();
                        while let Some(token) = lex.next() {
                            match token.raw.as_str() {
                                "+u" | "+user" => {
                                    if let Ok(Token { contents: Some(cmd_arg), .. }) = Transformers::user(
                                            &ctx,
                                            &msg,
                                            &mut lex,
                                        )
                                        .await
                                    {
                                        filters.insert("user", cmd_arg);
                                    }
                                }
                                "+s" | "+string" => {
                                    filters
                                        .insert(
                                            "string",
                                            CommandArgument::String(
                                                lex.next().map(|t| t.raw).unwrap_or_default(),
                                            ),
                                        );
                                }
                                _ => {}
                            }
                        }
                        let mut messages = match msg
                            .channel_id
                            .messages(&ctx.http, GetMessages::new().limit(100))
                            .await
                        {
                            Ok(m) => m,
                            Err(err) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\purge.rs:110",
                                                "Ouroboros::commands::purge",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\purge.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(110u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::purge",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Got error while fetching messages; err = {0:?}",
                                                                    err,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!(
                                                                                            "Got error while fetching messages; err = {0:?}",
                                                                                            err,
                                                                                        ) as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Err(CommandError {
                                    title: String::from("Could not get channel messages"),
                                    hint: Some(
                                        String::from(
                                            "there is currently a bug where this command fails if the last 100 messages in the channel have messages with components in them. Will be fixed soon sorry!",
                                        ),
                                    ),
                                    arg: None,
                                });
                            }
                        };
                        let now = Utc::now();
                        let two_weeks = Duration::weeks(2);
                        messages.remove(0);
                        let mut filtered = messages
                            .iter()
                            .filter(|m| {
                                let diff = (now - *m.timestamp).num_seconds().abs();
                                if diff <= two_weeks.num_seconds() {
                                    return true;
                                }
                                false
                            })
                            .collect::<Vec<_>>();
                        if let Some(CommandArgument::User(user)) = filters.get("user") {
                            filtered = filtered
                                .into_iter()
                                .filter(|m| {
                                    if m.author.id.get() == user.id.get() {
                                        return true;
                                    }
                                    false
                                })
                                .collect::<Vec<_>>();
                        }
                        if let Some(CommandArgument::String(content)) = filters
                            .get("string")
                        {
                            filtered = filtered
                                .into_iter()
                                .filter(|m| {
                                    if m.content.contains(content) {
                                        return true;
                                    }
                                    false
                                })
                                .collect::<Vec<_>>();
                        }
                        let ids = filtered
                            .clone()
                            .into_iter()
                            .map(|m| m.id.get().to_string())
                            .collect::<Vec<_>>();
                        let final_count = ids.len();
                        if msg
                            .channel_id
                            .delete_messages(&ctx.http, filtered)
                            .await
                            .is_err()
                        {
                            return Err(CommandError {
                                title: String::from("Could not delete channel messages"),
                                hint: Some(
                                    String::from(
                                        "make sure the bot has enough permissions to delete the messages of this channel",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        guild_log(
                                &ctx.http,
                                LogType::MessageDelete,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**MESSAGES PURGED**\n-# Actor: {0} `{1}` | Channel: <#{2}> | Count: {3}\n```\n{4}\n```",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            msg.channel_id.get(),
                                                            final_count,
                                                            ids.join("\n"),
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        let _ = msg.delete(&ctx.http).await;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::i32),
                        Arc::new(Transformers::consume),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::MANAGE_MESSAGES]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use purge::Purge;
    mod msgdbg {
        use serenity::{
            all::{Context, CreateAttachment, CreateMessage, Message},
            async_trait,
        };
        use tracing::warn;
        use crate::{
            commands::{
                Command, CommandCategory, CommandParameter, CommandPermissions,
                CommandSyntax, TransformerFnArc,
            },
            event_handler::CommandError, lexer::{Token, lex},
            utils::is_developer,
        };
        use ouroboros_macros::command;
        pub struct MsgDbg;
        impl MsgDbg {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for MsgDbg {
            fn get_name(&self) -> &'static str {
                "msgdbg"
            }
            fn get_short(&self) -> &'static str {
                "Gets message debug information"
            }
            fn get_full(&self) -> &'static str {
                "Reply to a message with this command to return debug information. Will be sent as a file in Discord and directly printed into the stdout."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                ::alloc::vec::Vec::new()
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Developer
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let __ret: Result<(), CommandError> = {
                        if is_developer(&msg.author) {
                            let Some(reply) = msg.referenced_message.clone() else {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\msgdbg.rs:53",
                                                "Ouroboros::commands::msgdbg",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\msgdbg.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(53u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::msgdbg",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("no reply found") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("no reply found") as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Ok(());
                            };
                            let r = CreateMessage::new()
                                .add_file(
                                    CreateAttachment::bytes(
                                        ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!(
                                                        "{0:?}\n{1:#?}",
                                                        lex(reply.content.clone())
                                                            .into_iter()
                                                            .map(|t| t.raw)
                                                            .collect::<Vec<_>>(),
                                                        reply,
                                                    ),
                                                )
                                            })
                                            .as_bytes(),
                                        "msg.rs",
                                    ),
                                );
                            match reply {
                                tmp => {
                                    {
                                        ::std::io::_eprint(
                                            format_args!(
                                                "[{0}:{1}:{2}] {3} = {4:#?}\n",
                                                "src\\commands\\msgdbg.rs",
                                                69u32,
                                                13u32,
                                                "reply",
                                                &tmp,
                                            ),
                                        );
                                    };
                                    tmp
                                }
                            };
                            let _ = msg.channel_id.send_message(&ctx.http, r).await;
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                ::alloc::vec::Vec::new()
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: ::alloc::vec::Vec::new(),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use msgdbg::MsgDbg;
    mod colon_three {
        use serenity::{
            all::{Context, Message},
            async_trait,
        };
        use crate::{
            commands::{
                Command, CommandCategory, CommandParameter, CommandPermissions,
                CommandSyntax, TransformerFnArc,
            },
            event_handler::CommandError, lexer::Token,
        };
        use ouroboros_macros::command;
        pub struct ColonThree;
        impl ColonThree {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for ColonThree {
            fn get_name(&self) -> &'static str {
                ":3"
            }
            fn get_short(&self) -> &'static str {
                ""
            }
            fn get_full(&self) -> &'static str {
                ":3"
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                ::alloc::vec::Vec::new()
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Misc
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let __ret: Result<(), CommandError> = {
                        let _ = msg.reply(&ctx.http, ":3").await;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                ::alloc::vec::Vec::new()
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: ::alloc::vec::Vec::new(),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use colon_three::ColonThree;
    mod reason {
        use std::sync::Arc;
        use ouroboros_macros::command;
        use serenity::{
            all::{
                Context, CreateAllowedMentions, CreateEmbed, CreateMessage, Mentionable,
                Message, Permissions,
            },
            async_trait,
        };
        use sqlx::query;
        use tracing::warn;
        use crate::{
            SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError, lexer::Token,
            transformers::Transformers, utils::{LogType, guild_log},
        };
        pub struct Reason;
        impl Reason {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Reason {
            fn get_name(&self) -> &'static str {
                "reason"
            }
            fn get_short(&self) -> &'static str {
                "Modifies the reason of a moderation action"
            }
            fn get_full(&self) -> &'static str {
                "Modifies the reason of a moderation action. Run the log command for the id."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::String("id", false),
                        CommandSyntax::Consume("reason"),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let id = {
                    let Some(Token { contents: Some(CommandArgument::String(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("id", Some("String")))
                        })
                    };
                    b
                };
                let reason: Option<String> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::String(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let id = id;
                    let reason = reason;
                    let __ret: Result<(), CommandError> = {
                        let mut reason = reason
                            .map(|s| {
                                if s.is_empty() || s.chars().all(char::is_whitespace) {
                                    String::from("No reason provided")
                                } else {
                                    s
                                }
                            })
                            .unwrap_or(String::from("No reason provided"));
                        if reason.len() > 500 {
                            reason.truncate(500);
                            reason.push_str("...");
                        }
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(reason);
                                    let arg1 = &(msg.guild_id.map(|g| g.get()).unwrap_or(0)
                                        as i64);
                                    let arg2 = &(id);
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg0);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg2);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            3usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg2),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg2).map(move |()| query_args)
                                        });
                                    #[allow(non_snake_case)]
                                    struct Record {
                                        id: String,
                                        reason: String,
                                    }
                                    #[automatically_derived]
                                    #[allow(non_snake_case)]
                                    impl ::core::fmt::Debug for Record {
                                        #[inline]
                                        fn fmt(
                                            &self,
                                            f: &mut ::core::fmt::Formatter,
                                        ) -> ::core::fmt::Result {
                                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                                f,
                                                "Record",
                                                "id",
                                                &self.id,
                                                "reason",
                                                &&self.reason,
                                            )
                                        }
                                    }
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                            "\n                UPDATE actions SET reason = $1, updated_at = NOW() WHERE guild_id = $2 AND id = $3 RETURNING id, reason;\n            ",
                                            query_args,
                                        )
                                        .try_map(|row: sqlx::postgres::PgRow| {
                                            use ::sqlx::Row as _;
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_id = row
                                                .try_get_unchecked::<String, _>(0usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_reason = row
                                                .try_get_unchecked::<String, _>(1usize)?
                                                .into();
                                            ::std::result::Result::Ok(Record {
                                                id: sqlx_query_as_id,
                                                reason: sqlx_query_as_reason,
                                            })
                                        })
                                }
                            }
                        }
                            .fetch_optional(SQL.get().unwrap())
                            .await;
                        let data = match res {
                            Ok(d) => d,
                            Err(err) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\reason.rs:98",
                                                "Ouroboros::commands::reason",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\reason.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(98u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::reason",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Couldn\'t fetch log data; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Couldn\'t fetch log data; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Err(CommandError {
                                    title: String::from("Unable to query the database"),
                                    hint: Some(String::from("try again later")),
                                    arg: None,
                                });
                            }
                        };
                        let Some(data) = data else {
                            return Err(CommandError {
                                title: String::from("Log not found"),
                                hint: Some(
                                    String::from("check if you have copied the ID correctly!"),
                                ),
                                arg: None,
                            });
                        };
                        let reply = CreateMessage::new()
                            .add_embed(
                                CreateEmbed::new()
                                    .description(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "**`{1}` UPDATED**```\n{0}\n```",
                                                    data.reason,
                                                    id,
                                                ),
                                            )
                                        }),
                                    )
                                    .color(BRAND_BLUE),
                            )
                            .reference_message(&msg)
                            .allowed_mentions(
                                CreateAllowedMentions::new().replied_user(false),
                            );
                        if let Err(err) = msg
                            .channel_id
                            .send_message(&ctx.http, reply)
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\reason.rs:125",
                                            "Ouroboros::commands::reason",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\reason.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(125u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::reason",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Could not send message; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Could not send message; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                        }
                        guild_log(
                                &ctx.http,
                                LogType::ActionUpdate,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**ACTION UPDATED**\n-# Log ID: `{3}` | Actor: {0} `{1}`\n```\n{2}\n```",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            reason,
                                                            id,
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::some_string),
                        Arc::new(Transformers::consume),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: ::alloc::vec::Vec::new(),
                    one_of: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            Permissions::MANAGE_NICKNAMES,
                            Permissions::KICK_MEMBERS,
                            Permissions::MODERATE_MEMBERS,
                            Permissions::BAN_MEMBERS,
                        ]),
                    ),
                }
            }
        }
    }
    pub use reason::Reason;
    mod update {
        use reqwest::{Client, Method, Request, Url, header::HeaderValue};
        use serenity::{
            all::{CacheHttp, Context, Message},
            async_trait,
        };
        use tracing::warn;
        use crate::{
            BOT_CONFIG,
            commands::{
                Command, CommandCategory, CommandParameter, CommandPermissions,
                CommandSyntax, TransformerFnArc,
            },
            event_handler::CommandError, lexer::Token, utils::is_developer,
        };
        use ouroboros_macros::command;
        use std::process::exit;
        pub struct Update;
        impl Update {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Update {
            fn get_name(&self) -> &'static str {
                "update"
            }
            fn get_short(&self) -> &'static str {
                "Updates the bot remotely"
            }
            fn get_full(&self) -> &'static str {
                "Updates the Bot using the Github repository in the config. \
        Warning: This might print debug information in chat! Only run this in a channel with members you trust!"
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                ::alloc::vec::Vec::new()
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Developer
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let __ret: Result<(), CommandError> = {
                        if !is_developer(&msg.author) {
                            return Ok(());
                        }
                        let cfg = BOT_CONFIG.get().unwrap();
                        let Some(repo) = cfg.repository.clone() else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\update.rs:61",
                                            "Ouroboros::commands::update",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\update.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(61u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::update",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Update command disabled! Please set a repository in the config!",
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!(
                                                                                        "Update command disabled! Please set a repository in the config!",
                                                                                    ) as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            let _ = msg
                                .reply(
                                    &ctx.http(),
                                    "Update command disabled! Please set a repository in the config",
                                )
                                .await;
                            return Ok(());
                        };
                        let client = Client::new();
                        let mut request = Request::new(
                            Method::GET,
                            Url::parse(
                                    ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "https://api.github.com/repos/{0}/actions/runs?per_page=1",
                                                    repo,
                                                ),
                                            )
                                        })
                                        .as_str(),
                                )
                                .unwrap(),
                        );
                        let headers = request.headers_mut();
                        headers
                            .append(
                                "User-Agent",
                                HeaderValue::from_str(
                                        ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!("Ouroboros Bot v{0}", "0.1.0-pre"),
                                                )
                                            })
                                            .as_str(),
                                    )
                                    .unwrap(),
                            );
                        if let Some(token) = cfg.github_token.clone() {
                            headers
                                .append(
                                    "Authorization",
                                    HeaderValue::from_str(
                                            ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("Bearer {0}", token))
                                                })
                                                .as_str(),
                                        )
                                        .unwrap(),
                                );
                        }
                        let res = match client.execute(request).await {
                            Ok(o) => o,
                            Err(e) => {
                                let err = ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Error getting actions, make sure to set a Github token with enough permissions if your repository is private; err = {0:?}",
                                            e,
                                        ),
                                    )
                                });
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\update.rs:99",
                                                "Ouroboros::commands::update",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\update.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(99u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::update",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["err"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                let _ = msg.reply(&ctx.http(), err).await;
                                return Ok(());
                            }
                        };
                        if res.status() != 200 {
                            let err = ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "Error getting actions, make sure to set a Github token with enough permissions if your repository is private; res = {0:?}",
                                        res,
                                    ),
                                )
                            });
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\update.rs:109",
                                            "Ouroboros::commands::update",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\update.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(109u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::update",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["err"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            let _ = msg.reply(&ctx.http(), err).await;
                            return Ok(());
                        }
                        let json = match res.json::<WorkflowRunsResponse>().await {
                            Ok(r) => r,
                            Err(err) => {
                                let err = ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Error deserializing actions response; err = {0:?}",
                                            err,
                                        ),
                                    )
                                });
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\update.rs:118",
                                                "Ouroboros::commands::update",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\update.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(118u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::update",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["err"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                let _ = msg.reply(&ctx.http(), err).await;
                                return Ok(());
                            }
                        };
                        if let Some(run) = json.workflow_runs.first() {
                            if run.status != "completed"
                                || run.conclusion.clone().is_none_or(|c| c != "success")
                            {
                                let err = ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Latest run with id {0} is not successful! Fix your code idiot!",
                                            run.id,
                                        ),
                                    )
                                });
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\update.rs:130",
                                                "Ouroboros::commands::update",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\update.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(130u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::update",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["err"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                let _ = msg.reply(&ctx.http(), err).await;
                                return Ok(());
                            }
                            let mut artifacts_req = Request::new(
                                Method::GET,
                                Url::parse(&run.artifacts_url).unwrap(),
                            );
                            let headers = artifacts_req.headers_mut();
                            headers
                                .append(
                                    "User-Agent",
                                    HeaderValue::from_str(
                                            ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("Ouroboros Bot v{0}", "0.1.0-pre"),
                                                    )
                                                })
                                                .as_str(),
                                        )
                                        .unwrap(),
                                );
                            if let Some(token) = cfg.github_token.clone() {
                                headers
                                    .append(
                                        "Authorization",
                                        HeaderValue::from_str(
                                                ::alloc::__export::must_use({
                                                        ::alloc::fmt::format(format_args!("Bearer {0}", token))
                                                    })
                                                    .as_str(),
                                            )
                                            .unwrap(),
                                    );
                            }
                            let res = match client.execute(artifacts_req).await {
                                Ok(o) => o,
                                Err(e) => {
                                    let err = ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!("Error fetching artifacts; err = {0:?}", e),
                                        )
                                    });
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src\\commands\\update.rs:157",
                                                    "Ouroboros::commands::update",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "src\\commands\\update.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(157u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "Ouroboros::commands::update",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["err"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                if match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            use ::tracing::log;
                                                            let level = match ::tracing::Level::WARN {
                                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                _ => ::tracing::log::Level::Trace,
                                                            };
                                                            if level <= log::max_level() {
                                                                let meta = __CALLSITE.metadata();
                                                                let log_meta = log::Metadata::builder()
                                                                    .level(level)
                                                                    .target(meta.target())
                                                                    .build();
                                                                let logger = log::logger();
                                                                if logger.enabled(&log_meta) {
                                                                    ::tracing::__macro_support::__tracing_log(
                                                                        meta,
                                                                        logger,
                                                                        log_meta,
                                                                        &value_set,
                                                                    )
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &{
                                                                        #[allow(unused_imports)]
                                                                        use ::tracing::field::{debug, display, Value};
                                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                                        __CALLSITE
                                                                            .metadata()
                                                                            .fields()
                                                                            .value_set(
                                                                                &[
                                                                                    (
                                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                                        ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                    ),
                                                                                ],
                                                                            )
                                                                    },
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        }
                                    };
                                    let _ = msg.reply(&ctx.http(), err).await;
                                    return Ok(());
                                }
                            };
                            if res.status() != 200 {
                                let err = ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Error fetching artifacts; res = {0:?}", res),
                                    )
                                });
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\update.rs:165",
                                                "Ouroboros::commands::update",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\update.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(165u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::update",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["err"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                let _ = msg.reply(&ctx.http(), err).await;
                                return Ok(());
                            }
                            let json = match res.json::<ArtifactsResponse>().await {
                                Ok(r) => r,
                                Err(err) => {
                                    let err = ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "Error deserializing artifacts response; err = {0:?}",
                                                err,
                                            ),
                                        )
                                    });
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src\\commands\\update.rs:174",
                                                    "Ouroboros::commands::update",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "src\\commands\\update.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(174u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "Ouroboros::commands::update",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["err"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                if match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            use ::tracing::log;
                                                            let level = match ::tracing::Level::WARN {
                                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                _ => ::tracing::log::Level::Trace,
                                                            };
                                                            if level <= log::max_level() {
                                                                let meta = __CALLSITE.metadata();
                                                                let log_meta = log::Metadata::builder()
                                                                    .level(level)
                                                                    .target(meta.target())
                                                                    .build();
                                                                let logger = log::logger();
                                                                if logger.enabled(&log_meta) {
                                                                    ::tracing::__macro_support::__tracing_log(
                                                                        meta,
                                                                        logger,
                                                                        log_meta,
                                                                        &value_set,
                                                                    )
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &{
                                                                        #[allow(unused_imports)]
                                                                        use ::tracing::field::{debug, display, Value};
                                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                                        __CALLSITE
                                                                            .metadata()
                                                                            .fields()
                                                                            .value_set(
                                                                                &[
                                                                                    (
                                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                                        ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                    ),
                                                                                ],
                                                                            )
                                                                    },
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        }
                                    };
                                    let _ = msg.reply(&ctx.http(), err).await;
                                    return Ok(());
                                }
                            };
                            fn artifact_matches(name: &str) -> bool {
                                name.ends_with(".exe")
                            }
                            let Some(artifact) = json
                                .artifacts
                                .into_iter()
                                .find(|a| artifact_matches(&a.name)) else {
                                let err = "No artifact found. Check if the latest action produced the correct artifacts";
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\update.rs:197",
                                                "Ouroboros::commands::update",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\update.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(197u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::update",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["err"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                let _ = msg.reply(&ctx.http(), err).await;
                                return Ok(());
                            };
                            let mut download_req = Request::new(
                                Method::GET,
                                Url::parse(&artifact.archive_download_url).unwrap(),
                            );
                            let headers = download_req.headers_mut();
                            headers
                                .append(
                                    "User-Agent",
                                    HeaderValue::from_str(
                                            ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("Ouroboros Bot v{0}", "0.1.0-pre"),
                                                    )
                                                })
                                                .as_str(),
                                        )
                                        .unwrap(),
                                );
                            if let Some(token) = cfg.github_token.clone() {
                                headers
                                    .append(
                                        "Authorization",
                                        HeaderValue::from_str(
                                                &::alloc::__export::must_use({
                                                    ::alloc::fmt::format(format_args!("Bearer {0}", token))
                                                }),
                                            )
                                            .unwrap(),
                                    );
                            }
                            let res = match client.execute(download_req).await {
                                Ok(o) => o,
                                Err(e) => {
                                    let err = ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!("Error fetching artifact file; err = {0:?}", e),
                                        )
                                    });
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src\\commands\\update.rs:226",
                                                    "Ouroboros::commands::update",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "src\\commands\\update.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(226u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "Ouroboros::commands::update",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["err"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                if match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            use ::tracing::log;
                                                            let level = match ::tracing::Level::WARN {
                                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                _ => ::tracing::log::Level::Trace,
                                                            };
                                                            if level <= log::max_level() {
                                                                let meta = __CALLSITE.metadata();
                                                                let log_meta = log::Metadata::builder()
                                                                    .level(level)
                                                                    .target(meta.target())
                                                                    .build();
                                                                let logger = log::logger();
                                                                if logger.enabled(&log_meta) {
                                                                    ::tracing::__macro_support::__tracing_log(
                                                                        meta,
                                                                        logger,
                                                                        log_meta,
                                                                        &value_set,
                                                                    )
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &{
                                                                        #[allow(unused_imports)]
                                                                        use ::tracing::field::{debug, display, Value};
                                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                                        __CALLSITE
                                                                            .metadata()
                                                                            .fields()
                                                                            .value_set(
                                                                                &[
                                                                                    (
                                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                                        ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                    ),
                                                                                ],
                                                                            )
                                                                    },
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        }
                                    };
                                    let _ = msg.reply(&ctx.http(), err).await;
                                    return Ok(());
                                }
                            };
                            if res.status() != 200 {
                                let err = ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Error fetching artifact file; res = {0:?}",
                                            res,
                                        ),
                                    )
                                });
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\update.rs:234",
                                                "Ouroboros::commands::update",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\update.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(234u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::update",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["err"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                let _ = msg.reply(&ctx.http(), err).await;
                                return Ok(());
                            }
                            let Ok(bytes) = res.bytes().await else {
                                let err = String::from("Error fetching artifact file;");
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\update.rs:241",
                                                "Ouroboros::commands::update",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\update.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(241u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::update",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["err"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                let _ = msg.reply(&ctx.http(), err).await;
                                return Ok(());
                            };
                            let filename = String::from("new_") + artifact.name.as_str();
                            let unzip_result = tokio::task::spawn_blocking(move || -> Result<
                                    Vec<u8>,
                                    String,
                                > {
                                    let reader = std::io::Cursor::new(bytes);
                                    let Ok(mut zip) = zip::ZipArchive::new(reader) else {
                                        return Err(String::from("Failed to create a zip cursor"));
                                    };
                                    let name = "Ouroboros.exe";
                                    let Ok(mut file) = zip
                                        .by_name(
                                            &::alloc::__export::must_use({
                                                ::alloc::fmt::format(format_args!("release/{0}", name))
                                            }),
                                        ) else {
                                        return Err(String::from("Failed to extract file"));
                                    };
                                    let mut buffer = Vec::with_capacity(file.size() as usize);
                                    if let Err(err) = std::io::copy(&mut file, &mut buffer) {
                                        return Err(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(format_args!("{0:?}", err))
                                            }),
                                        );
                                    }
                                    Ok(buffer)
                                })
                                .await;
                            let extracted_bytes = match unzip_result {
                                Ok(r) => {
                                    match r {
                                        Ok(b) => b,
                                        Err(err) => {
                                            let err = ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!(
                                                        "Failed unzipping artifact zip; err = {0:?}",
                                                        err,
                                                    ),
                                                )
                                            });
                                            {
                                                use ::tracing::__macro_support::Callsite as _;
                                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                    static META: ::tracing::Metadata<'static> = {
                                                        ::tracing_core::metadata::Metadata::new(
                                                            "event src\\commands\\update.rs:278",
                                                            "Ouroboros::commands::update",
                                                            ::tracing::Level::WARN,
                                                            ::tracing_core::__macro_support::Option::Some(
                                                                "src\\commands\\update.rs",
                                                            ),
                                                            ::tracing_core::__macro_support::Option::Some(278u32),
                                                            ::tracing_core::__macro_support::Option::Some(
                                                                "Ouroboros::commands::update",
                                                            ),
                                                            ::tracing_core::field::FieldSet::new(
                                                                &["err"],
                                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                            ),
                                                            ::tracing::metadata::Kind::EVENT,
                                                        )
                                                    };
                                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                                };
                                                let enabled = ::tracing::Level::WARN
                                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                    && ::tracing::Level::WARN
                                                        <= ::tracing::level_filters::LevelFilter::current()
                                                    && {
                                                        let interest = __CALLSITE.interest();
                                                        !interest.is_never()
                                                            && ::tracing::__macro_support::__is_enabled(
                                                                __CALLSITE.metadata(),
                                                                interest,
                                                            )
                                                    };
                                                if enabled {
                                                    (|value_set: ::tracing::field::ValueSet| {
                                                        let meta = __CALLSITE.metadata();
                                                        ::tracing::Event::dispatch(meta, &value_set);
                                                        if match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                                        {
                                                            if !::tracing::dispatcher::has_been_set() {
                                                                {
                                                                    use ::tracing::log;
                                                                    let level = match ::tracing::Level::WARN {
                                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                        _ => ::tracing::log::Level::Trace,
                                                                    };
                                                                    if level <= log::max_level() {
                                                                        let meta = __CALLSITE.metadata();
                                                                        let log_meta = log::Metadata::builder()
                                                                            .level(level)
                                                                            .target(meta.target())
                                                                            .build();
                                                                        let logger = log::logger();
                                                                        if logger.enabled(&log_meta) {
                                                                            ::tracing::__macro_support::__tracing_log(
                                                                                meta,
                                                                                logger,
                                                                                log_meta,
                                                                                &value_set,
                                                                            )
                                                                        }
                                                                    }
                                                                }
                                                            } else {
                                                                {}
                                                            }
                                                        } else {
                                                            {}
                                                        };
                                                    })({
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                    ),
                                                                ],
                                                            )
                                                    });
                                                } else {
                                                    if match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                                    {
                                                        if !::tracing::dispatcher::has_been_set() {
                                                            {
                                                                use ::tracing::log;
                                                                let level = match ::tracing::Level::WARN {
                                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                    _ => ::tracing::log::Level::Trace,
                                                                };
                                                                if level <= log::max_level() {
                                                                    let meta = __CALLSITE.metadata();
                                                                    let log_meta = log::Metadata::builder()
                                                                        .level(level)
                                                                        .target(meta.target())
                                                                        .build();
                                                                    let logger = log::logger();
                                                                    if logger.enabled(&log_meta) {
                                                                        ::tracing::__macro_support::__tracing_log(
                                                                            meta,
                                                                            logger,
                                                                            log_meta,
                                                                            &{
                                                                                #[allow(unused_imports)]
                                                                                use ::tracing::field::{debug, display, Value};
                                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                                __CALLSITE
                                                                                    .metadata()
                                                                                    .fields()
                                                                                    .value_set(
                                                                                        &[
                                                                                            (
                                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                                ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                            ),
                                                                                        ],
                                                                                    )
                                                                            },
                                                                        )
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            {}
                                                        }
                                                    } else {
                                                        {}
                                                    };
                                                }
                                            };
                                            let _ = msg.reply(&ctx.http(), err).await;
                                            return Ok(());
                                        }
                                    }
                                }
                                Err(err) => {
                                    let err = ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "Failed unzipping artifact zip; err = {0:?}",
                                                err,
                                            ),
                                        )
                                    });
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src\\commands\\update.rs:285",
                                                    "Ouroboros::commands::update",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "src\\commands\\update.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(285u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "Ouroboros::commands::update",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["err"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                if match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            use ::tracing::log;
                                                            let level = match ::tracing::Level::WARN {
                                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                _ => ::tracing::log::Level::Trace,
                                                            };
                                                            if level <= log::max_level() {
                                                                let meta = __CALLSITE.metadata();
                                                                let log_meta = log::Metadata::builder()
                                                                    .level(level)
                                                                    .target(meta.target())
                                                                    .build();
                                                                let logger = log::logger();
                                                                if logger.enabled(&log_meta) {
                                                                    ::tracing::__macro_support::__tracing_log(
                                                                        meta,
                                                                        logger,
                                                                        log_meta,
                                                                        &value_set,
                                                                    )
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &{
                                                                        #[allow(unused_imports)]
                                                                        use ::tracing::field::{debug, display, Value};
                                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                                        __CALLSITE
                                                                            .metadata()
                                                                            .fields()
                                                                            .value_set(
                                                                                &[
                                                                                    (
                                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                                        ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                    ),
                                                                                ],
                                                                            )
                                                                    },
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        }
                                    };
                                    let _ = msg.reply(&ctx.http(), err).await;
                                    return Ok(());
                                }
                            };
                            if let Err(err) = tokio::fs::write(
                                    filename.clone(),
                                    &extracted_bytes,
                                )
                                .await
                            {
                                let err = ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "Failed writing artifact file; err = {0:?}",
                                            err,
                                        ),
                                    )
                                });
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\update.rs:293",
                                                "Ouroboros::commands::update",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\update.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(293u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::update",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["err"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                let _ = msg.reply(&ctx.http(), err).await;
                                return Ok(());
                            }
                            {
                                use std::process::Command as SystemCommand;
                                let child = match SystemCommand::new(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(".{0}{1}", std::path::MAIN_SEPARATOR, filename),
                                            )
                                        }),
                                    )
                                    .arg(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "--update={0}:{1}",
                                                    msg.channel_id.get(),
                                                    msg.id.get(),
                                                ),
                                            )
                                        }),
                                    )
                                    .spawn()
                                {
                                    Ok(c) => c,
                                    Err(e) => {
                                        let err = ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "Could not run downloaded version; err = {0:?}",
                                                    e,
                                                ),
                                            )
                                        });
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event src\\commands\\update.rs:341",
                                                        "Ouroboros::commands::update",
                                                        ::tracing::Level::WARN,
                                                        ::tracing_core::__macro_support::Option::Some(
                                                            "src\\commands\\update.rs",
                                                        ),
                                                        ::tracing_core::__macro_support::Option::Some(341u32),
                                                        ::tracing_core::__macro_support::Option::Some(
                                                            "Ouroboros::commands::update",
                                                        ),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["err"],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = ::tracing::Level::WARN
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::tracing::Level::WARN
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                    if match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                                    {
                                                        if !::tracing::dispatcher::has_been_set() {
                                                            {
                                                                use ::tracing::log;
                                                                let level = match ::tracing::Level::WARN {
                                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                    _ => ::tracing::log::Level::Trace,
                                                                };
                                                                if level <= log::max_level() {
                                                                    let meta = __CALLSITE.metadata();
                                                                    let log_meta = log::Metadata::builder()
                                                                        .level(level)
                                                                        .target(meta.target())
                                                                        .build();
                                                                    let logger = log::logger();
                                                                    if logger.enabled(&log_meta) {
                                                                        ::tracing::__macro_support::__tracing_log(
                                                                            meta,
                                                                            logger,
                                                                            log_meta,
                                                                            &value_set,
                                                                        )
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            {}
                                                        }
                                                    } else {
                                                        {}
                                                    };
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                ),
                                                            ],
                                                        )
                                                });
                                            } else {
                                                if match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            use ::tracing::log;
                                                            let level = match ::tracing::Level::WARN {
                                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                _ => ::tracing::log::Level::Trace,
                                                            };
                                                            if level <= log::max_level() {
                                                                let meta = __CALLSITE.metadata();
                                                                let log_meta = log::Metadata::builder()
                                                                    .level(level)
                                                                    .target(meta.target())
                                                                    .build();
                                                                let logger = log::logger();
                                                                if logger.enabled(&log_meta) {
                                                                    ::tracing::__macro_support::__tracing_log(
                                                                        meta,
                                                                        logger,
                                                                        log_meta,
                                                                        &{
                                                                            #[allow(unused_imports)]
                                                                            use ::tracing::field::{debug, display, Value};
                                                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                                                            __CALLSITE
                                                                                .metadata()
                                                                                .fields()
                                                                                .value_set(
                                                                                    &[
                                                                                        (
                                                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                                            ::tracing::__macro_support::Option::Some(&err as &dyn Value),
                                                                                        ),
                                                                                    ],
                                                                                )
                                                                        },
                                                                    )
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                            }
                                        };
                                        let _ = msg.reply(&ctx.http(), err).await;
                                        return Ok(());
                                    }
                                };
                                drop(child);
                                exit(0);
                            }
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                ::alloc::vec::Vec::new()
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: ::alloc::vec::Vec::new(),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
        use serde::Deserialize;
        pub struct WorkflowRunsResponse {
            pub workflow_runs: Vec<WorkflowRun>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for WorkflowRunsResponse {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "WorkflowRunsResponse",
                    "workflow_runs",
                    &&self.workflow_runs,
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for WorkflowRunsResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "workflow_runs" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"workflow_runs" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<WorkflowRunsResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = WorkflowRunsResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct WorkflowRunsResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<WorkflowRun>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct WorkflowRunsResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(WorkflowRunsResponse {
                                workflow_runs: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Vec<WorkflowRun>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "workflow_runs",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<WorkflowRun>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("workflow_runs")?
                                }
                            };
                            _serde::__private::Ok(WorkflowRunsResponse {
                                workflow_runs: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["workflow_runs"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "WorkflowRunsResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                WorkflowRunsResponse,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct WorkflowRun {
            pub id: u64,
            pub status: String,
            pub conclusion: Option<String>,
            pub artifacts_url: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for WorkflowRun {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "WorkflowRun",
                    "id",
                    &self.id,
                    "status",
                    &self.status,
                    "conclusion",
                    &self.conclusion,
                    "artifacts_url",
                    &&self.artifacts_url,
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for WorkflowRun {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "status" => _serde::__private::Ok(__Field::__field1),
                                "conclusion" => _serde::__private::Ok(__Field::__field2),
                                "artifacts_url" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"status" => _serde::__private::Ok(__Field::__field1),
                                b"conclusion" => _serde::__private::Ok(__Field::__field2),
                                b"artifacts_url" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<WorkflowRun>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = WorkflowRun;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct WorkflowRun",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                u64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct WorkflowRun with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct WorkflowRun with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct WorkflowRun with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct WorkflowRun with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(WorkflowRun {
                                id: __field0,
                                status: __field1,
                                conclusion: __field2,
                                artifacts_url: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("status"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "conclusion",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "artifacts_url",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("status")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("conclusion")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("artifacts_url")?
                                }
                            };
                            _serde::__private::Ok(WorkflowRun {
                                id: __field0,
                                status: __field1,
                                conclusion: __field2,
                                artifacts_url: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "status",
                        "conclusion",
                        "artifacts_url",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "WorkflowRun",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<WorkflowRun>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct ArtifactsResponse {
            pub artifacts: Vec<Artifact>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ArtifactsResponse {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ArtifactsResponse",
                    "artifacts",
                    &&self.artifacts,
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ArtifactsResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "artifacts" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"artifacts" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ArtifactsResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ArtifactsResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ArtifactsResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<Artifact>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ArtifactsResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ArtifactsResponse {
                                artifacts: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Vec<Artifact>> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "artifacts",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<Artifact>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("artifacts")?
                                }
                            };
                            _serde::__private::Ok(ArtifactsResponse {
                                artifacts: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["artifacts"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ArtifactsResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ArtifactsResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct Artifact {
            pub name: String,
            pub archive_download_url: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Artifact {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "Artifact",
                    "name",
                    &self.name,
                    "archive_download_url",
                    &&self.archive_download_url,
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Artifact {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "archive_download_url" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"archive_download_url" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Artifact>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Artifact;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Artifact",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Artifact with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Artifact with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Artifact {
                                name: __field0,
                                archive_download_url: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "archive_download_url",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "archive_download_url",
                                    )?
                                }
                            };
                            _serde::__private::Ok(Artifact {
                                name: __field0,
                                archive_download_url: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "name",
                        "archive_download_url",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Artifact",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Artifact>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
    }
    pub use update::Update;
    mod config {
        use std::{iter::Peekable, sync::Arc, vec::IntoIter};
        use serenity::{
            all::{
                Context, CreateAllowedMentions, CreateEmbed, CreateMessage, Message,
                Permissions,
            },
            async_trait, json::{self, Value},
        };
        use tracing::{error, warn};
        use crate::{
            GUILD_SETTINGS, SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerError, TransformerFnArc,
                TransformerReturn,
            },
            constants::BRAND_BLUE, event_handler::CommandError, lexer::Token,
            transformers::Transformers, utils::Settings,
        };
        type UnwrapTransformerFn = Box<
            dyn for<'a> Fn(
                &'a Context,
                &'a Message,
                &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> + Send + Sync,
        >;
        pub struct Config;
        impl Config {
            pub fn new() -> Self {
                Self {}
            }
            fn get_option_desc(&self, opt: &str) -> &str {
                match opt {
                    "log" => "Settings controlling guild event logging",
                    "log.log_bots" => "<Bool> Include bots in server activity logs",
                    _ => "",
                }
            }
        }
        impl Command for Config {
            fn get_name(&self) -> &'static str {
                "config"
            }
            fn get_short(&self) -> &'static str {
                "Configures functions of the bot"
            }
            fn get_full(&self) -> &'static str {
                "Configures functions of the bot. \
        Available subcommands: list set get;\n \
        `list [group]` lists all groups/keys in a group\n \
        `set <group>.<key> <value>` sets a setting to value\n \
        `get <group>.<key>` gets the value of a setting \
        To clear a setting set its value to `none`."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::String("subcommand", true),
                        CommandSyntax::String("argument1", false),
                        CommandSyntax::String("argument2", false),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Admin
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn run<'life0, 'async_trait>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let args = args;
                    let __ret: Result<(), CommandError> = {
                        let mut args_iter = args.into_iter();
                        let Some(subcommand_token) = args_iter.next() else {
                            return Err(
                                CommandError::arg_not_found("String", Some("subcommand")),
                            );
                        };
                        let Token {
                            contents: Some(CommandArgument::String(subcommand)),
                            ..
                        } = subcommand_token.clone() else {
                            return Err(
                                CommandError::arg_not_found("String", Some("subcommand")),
                            );
                        };
                        let arg1_token = args_iter.next();
                        let arg1: Option<String> = match arg1_token.clone() {
                            Some(arg) => {
                                match arg.contents {
                                    Some(CommandArgument::String(inner)) => Some(inner),
                                    _ => None,
                                }
                            }
                            None => None,
                        };
                        let arg2_token = args_iter.next();
                        let arg2: Option<String> = match arg2_token.clone() {
                            Some(arg) => {
                                match arg.contents {
                                    Some(CommandArgument::String(inner)) => Some(inner),
                                    _ => None,
                                }
                            }
                            None => None,
                        };
                        let mut global = GUILD_SETTINGS.get().unwrap().lock().await;
                        let settings = match global
                            .get(msg.guild_id.map(|g| g.get()).unwrap_or(1))
                            .await
                        {
                            Ok(s) => s,
                            Err(_) => Settings { ..Default::default() },
                        };
                        if subcommand == "list" {
                            let Ok(Value::Object(json_rep)) = json::to_value(&settings)
                            else {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\config.rs:125",
                                                "Ouroboros::commands::config",
                                                ::tracing::Level::ERROR,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\config.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(125u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::config",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::ERROR {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Json serialization went wrong on guild settings",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::ERROR {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!(
                                                                                            "Json serialization went wrong on guild settings",
                                                                                        ) as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Err(CommandError {
                                    title: String::from("Could not fetch guild settings"),
                                    hint: Some(String::from("please try again later")),
                                    arg: None,
                                });
                            };
                            let description = if let Some(group_key) = arg1 {
                                let Some(Value::Object(group)) = json_rep.get(&group_key)
                                else {
                                    return Err(CommandError {
                                        title: String::from("Could not find group"),
                                        hint: Some(
                                            String::from("run `config list` for a list of all groups"),
                                        ),
                                        arg: None,
                                    });
                                };
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "**Available Settings In Group**\n{0}",
                                            group
                                                .keys()
                                                .map(|k| ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "`{1}` - {0}",
                                                            __self
                                                                .get_option_desc(
                                                                    ::alloc::__export::must_use({
                                                                            ::alloc::fmt::format(format_args!("{0}.{1}", group_key, k))
                                                                        })
                                                                        .as_str(),
                                                                ),
                                                            k,
                                                        ),
                                                    )
                                                }))
                                                .collect::<Vec<String>>()
                                                .join("\n"),
                                        ),
                                    )
                                })
                            } else {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "**Available Config Groups**\n{0}",
                                            json_rep
                                                .keys()
                                                .map(|k| ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("`{1}` - {0}", __self.get_option_desc(k), k),
                                                    )
                                                }))
                                                .collect::<Vec<String>>()
                                                .join("\n"),
                                        ),
                                    )
                                })
                            };
                            let reply = CreateMessage::new()
                                .add_embed(
                                    CreateEmbed::new()
                                        .description(description)
                                        .color(BRAND_BLUE),
                                )
                                .reference_message(&msg)
                                .allowed_mentions(
                                    CreateAllowedMentions::new().replied_user(false),
                                );
                            if let Err(err) = msg
                                .channel_id
                                .send_message(&ctx.http, reply)
                                .await
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\config.rs:174",
                                                "Ouroboros::commands::config",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\config.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(174u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::config",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            Ok(())
                        } else if subcommand == "get" {
                            let Some(setting) = arg1 else {
                                return Err(
                                    CommandError::arg_not_found("String", Some("arg1")),
                                );
                            };
                            let value = match setting.as_str() {
                                "log.log_bots" => {
                                    settings
                                        .log
                                        .log_bots
                                        .map(|c| ::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!("{0}", c))
                                        }))
                                        .unwrap_or(String::from("false"))
                                }
                                _ => {
                                    return Err(CommandError {
                                        title: String::from("Could not find setting"),
                                        hint: Some(
                                            String::from("run config list for a list of valid settings"),
                                        ),
                                        arg: Some(arg1_token.unwrap()),
                                    });
                                }
                            };
                            let reply = CreateMessage::new()
                                .add_embed(
                                    CreateEmbed::new()
                                        .description(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!("{0}: {1}", setting, value),
                                                )
                                            }),
                                        )
                                        .color(BRAND_BLUE),
                                )
                                .reference_message(&msg)
                                .allowed_mentions(
                                    CreateAllowedMentions::new().replied_user(false),
                                );
                            if let Err(err) = msg
                                .channel_id
                                .send_message(&ctx.http, reply)
                                .await
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\config.rs:208",
                                                "Ouroboros::commands::config",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\config.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(208u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::config",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            Ok(())
                        } else if subcommand == "set" {
                            let Some(setting) = arg1 else {
                                return Err(
                                    CommandError::arg_not_found("String", Some("arg1")),
                                );
                            };
                            let Some(value) = arg2 else {
                                return Err(
                                    CommandError::arg_not_found("String", Some("arg1")),
                                );
                            };
                            let mut iter = <[_]>::into_vec(
                                    ::alloc::boxed::box_new([arg2_token.clone().unwrap()]),
                                )
                                .into_iter()
                                .peekable();
                            let setting_info: (
                                UnwrapTransformerFn,
                                sqlx::query::Query<
                                    '_,
                                    sqlx::Postgres,
                                    sqlx::postgres::PgArguments,
                                >,
                            ) = match setting.as_str() {
                                "log.log_bots" => {
                                    (
                                        Box::new(Transformers::bool),
                                        sqlx::query(
                                            "UPDATE guild_settings SET log_bot = $2 WHERE guild_id = $1",
                                        ),
                                    )
                                }
                                _ => {
                                    return Err(CommandError {
                                        title: String::from("Could not find setting"),
                                        hint: Some(
                                            String::from(
                                                "run `config list` for a list of valid settings",
                                            ),
                                        ),
                                        arg: Some(arg1_token.unwrap()),
                                    });
                                }
                            };
                            let res = if iter
                                .peek()
                                .map(|t| t.raw.clone())
                                .unwrap_or_default()
                                .to_lowercase() == "none"
                            {
                                setting_info
                                    .1
                                    .bind(msg.guild_id.map(|g| g.get()).unwrap_or(1) as i64)
                                    .bind(None as Option<i32>)
                                    .execute(SQL.get().unwrap())
                                    .await
                            } else {
                                match setting_info.0(&ctx, &msg, &mut iter).await {
                                    Ok(
                                        Token {
                                            contents: Some(CommandArgument::GuildChannel(channel)),
                                            ..
                                        },
                                    ) => {
                                        setting_info
                                            .1
                                            .bind(msg.guild_id.map(|g| g.get()).unwrap_or(1) as i64)
                                            .bind(channel.id.get() as i64)
                                            .execute(SQL.get().unwrap())
                                            .await
                                    }
                                    Ok(
                                        Token { contents: Some(CommandArgument::bool(b)), .. },
                                    ) => {
                                        setting_info
                                            .1
                                            .bind(msg.guild_id.map(|g| g.get()).unwrap_or(1) as i64)
                                            .bind(b)
                                            .execute(SQL.get().unwrap())
                                            .await
                                    }
                                    Err(TransformerError::CommandError(mut err)) => {
                                        err.arg = Some(arg2_token.unwrap());
                                        return Err(err);
                                    }
                                    _ => {
                                        return Err(CommandError {
                                            title: String::from(
                                                "Could not insert value into settings.",
                                            ),
                                            hint: None,
                                            arg: Some(arg2_token.unwrap()),
                                        });
                                    }
                                }
                            };
                            if let Err(err) = res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\config.rs:297",
                                                "Ouroboros::commands::config",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\config.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(297u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::config",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Could not update guild settings; err = {0:?}",
                                                                    err,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!(
                                                                                            "Could not update guild settings; err = {0:?}",
                                                                                            err,
                                                                                        ) as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Err(CommandError {
                                    title: String::from("Could not update settings"),
                                    hint: Some(String::from("please try again later.")),
                                    arg: Some(arg1_token.unwrap()),
                                });
                            }
                            global.invalidate();
                            let reply = CreateMessage::new()
                                .add_embed(
                                    CreateEmbed::new()
                                        .description(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!("Successfully set {0} to {1}", setting, value),
                                                )
                                            }),
                                        )
                                        .color(BRAND_BLUE),
                                )
                                .reference_message(&msg)
                                .allowed_mentions(
                                    CreateAllowedMentions::new().replied_user(false),
                                );
                            if let Err(err) = msg
                                .channel_id
                                .send_message(&ctx.http, reply)
                                .await
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\config.rs:317",
                                                "Ouroboros::commands::config",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\config.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(317u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::config",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            Ok(())
                        } else {
                            Err(CommandError {
                                title: String::from("Subcommand not found"),
                                hint: Some(
                                    String::from("available subcommands: list, get, set"),
                                ),
                                arg: Some(subcommand_token),
                            })
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::some_string),
                        Arc::new(Transformers::string),
                        Arc::new(Transformers::some_string),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::ADMINISTRATOR]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use config::Config;
    mod say {
        use std::sync::Arc;
        use serenity::{
            all::{Context, CreateMessage, Message},
            async_trait,
        };
        use crate::{
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            event_handler::CommandError, lexer::Token, transformers::Transformers,
            utils::is_developer,
        };
        use ouroboros_macros::command;
        pub struct Say;
        impl Say {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Say {
            fn get_name(&self) -> &'static str {
                "say"
            }
            fn get_short(&self) -> &'static str {
                ""
            }
            fn get_full(&self) -> &'static str {
                "Says something as the bot"
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                ::alloc::vec::Vec::new()
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Developer
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let say = {
                    let Some(Token { contents: Some(CommandArgument::String(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("say", Some("String")))
                        })
                    };
                    b
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let say = say;
                    let __ret: Result<(), CommandError> = {
                        if is_developer(&msg.author) {
                            let _ = msg.delete(&ctx.http).await;
                            let mut response = CreateMessage::new().content(say);
                            if let Some(reply) = msg.referenced_message {
                                response = response.reference_message(&*reply);
                            }
                            let _ = msg
                                .channel_id
                                .send_message(&ctx.http, response)
                                .await;
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([Arc::new(Transformers::consume)]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: ::alloc::vec::Vec::new(),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use say::Say;
    mod about {
        use std::time::Instant;
        use serenity::{
            all::{Context, CreateAllowedMentions, CreateEmbed, CreateMessage, Message},
            async_trait,
        };
        use sysinfo::System;
        use tracing::warn;
        use crate::{
            START_TIME,
            commands::{Command, CommandCategory, CommandParameter, CommandSyntax},
            constants::BRAND_BLUE, event_handler::CommandError, lexer::Token,
        };
        pub struct About;
        impl About {
            pub fn new() -> Self {
                Self
            }
        }
        impl Command for About {
            fn get_name(&self) -> &'static str {
                "about"
            }
            fn get_short(&self) -> &'static str {
                "Gets general information about the bot"
            }
            fn get_full(&self) -> &'static str {
                "Shows various statistics of the bot. Useful for nerds!"
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                ::alloc::vec::Vec::new()
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Misc
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn run<'life0, 'async_trait>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                _args: Vec<Token>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let _args = _args;
                    let __ret: Result<(), CommandError> = {
                        let guild_count = ctx.cache.guild_count();
                        let uptime = {
                            let elapsed = START_TIME
                                .get()
                                .unwrap_or(&Instant::now())
                                .elapsed();
                            let seconds = elapsed.as_secs();
                            (seconds / 3600, (seconds % 3600) / 60, seconds % 60)
                        };
                        let memory = {
                            let mut sys = System::new_all();
                            sys.refresh_all();
                            sys.process((std::process::id() as usize).into())
                                .map(|p| p.memory() as f64 / 1024.0 / 1024.0)
                                .unwrap_or(0.0)
                        };
                        let description = {
                            let uptime = if uptime.0 != 0 {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}h {1}m {2}s", uptime.0, uptime.1, uptime.2),
                                    )
                                })
                            } else if uptime.1 != 0 {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}m {1}s", uptime.1, uptime.2),
                                    )
                                })
                            } else {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(format_args!("{0}s", uptime.2))
                                })
                            };
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "**ABOUT**\nHey, I\'m {0}!\nA moderation bot made for one purpose and one purpose only: Moderation.\nI\'m currently in private beta but my source code is available at <https://github.com/chloecinders/ouroboros>.\nType `+help` to see a list of all commands!\n\nI was made in Rust by chloecinders!\n\nSpecial thanks to:\n```\nserenity-rs: Underlying Bot Framework\nandreashgk: Rust Mentorship\nDiscord Previews & Rust Central: Bots pre-release testing grounds\n```\nNerd Stats:\nVersion: {1}\nServers: {2}\nUptime: {3}\nMemory: {4:.2}MB",
                                        ctx.cache.current_user().name,
                                        "0.1.0-pre",
                                        guild_count,
                                        uptime,
                                        memory,
                                    ),
                                )
                            })
                        };
                        let reply = CreateMessage::new()
                            .add_embed(
                                CreateEmbed::new()
                                    .description(description)
                                    .color(BRAND_BLUE),
                            )
                            .reference_message(&msg)
                            .allowed_mentions(
                                CreateAllowedMentions::new().replied_user(false),
                            );
                        if let Err(e) = msg
                            .channel_id
                            .send_message(&ctx.http, reply)
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\about.rs:115",
                                            "Ouroboros::commands::about",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\about.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(115u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::about",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Could not send message; err = {0:?}", e)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Could not send message; err = {0:?}", e)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
    }
    pub use about::About;
    mod duration {
        use std::sync::Arc;
        use chrono::Utc;
        use ouroboros_macros::command;
        use serenity::{
            all::{
                Context, CreateAllowedMentions, CreateEmbed, CreateMessage, EditMember,
                Mentionable, Message, Permissions,
            },
            async_trait,
        };
        use sqlx::query;
        use tracing::warn;
        use crate::{
            SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, database::ActionType, event_handler::CommandError,
            lexer::Token, transformers::Transformers, utils::{LogType, guild_log},
        };
        pub struct Duration;
        impl Duration {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Duration {
            fn get_name(&self) -> &'static str {
                "duration"
            }
            fn get_short(&self) -> &'static str {
                "Modifies the duration of a moderation action"
            }
            fn get_full(&self) -> &'static str {
                "Modifies the duration of a moderation action. \
        Run the log command for the id. \
        The action must be one that accepts a duration, such as ban or mute. \
        The new duration is relative to the time the action has taken place."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CommandSyntax::String("id", false),
                        CommandSyntax::Duration("duration", true),
                    ]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Moderation
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let id = {
                    let Some(Token { contents: Some(CommandArgument::String(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("id", Some("String")))
                        })
                    };
                    b
                };
                let duration = {
                    let Some(
                        Token { contents: Some(CommandArgument::Duration(b)), .. },
                    ) = args_iter.next() else {
                        return Box::pin(async move {
                            Err(
                                CommandError::arg_not_found("duration", Some("Duration")),
                            )
                        })
                    };
                    b
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let id = id;
                    let duration = duration;
                    let __ret: Result<(), CommandError> = {
                        let res = {
                            {
                                #[allow(clippy::all)]
                                {
                                    use ::sqlx::Arguments as _;
                                    let arg0 = &(msg.guild_id.map(|g| g.get()).unwrap_or(0)
                                        as i64);
                                    let arg1 = &(id);
                                    #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                    if false {
                                        use ::sqlx::ty_match::{
                                            WrapSameExt as _, MatchBorrowExt as _,
                                        };
                                        let expr = ::sqlx::ty_match::dupe_value(arg1);
                                        let ty_check = ::sqlx::ty_match::WrapSame::<
                                            &str,
                                            _,
                                        >::new(&expr)
                                            .wrap_same();
                                        let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                            ty_check,
                                            &expr,
                                        );
                                        _ty_check = match_borrow.match_borrow();
                                        ::core::panicking::panic(
                                            "internal error: entered unreachable code",
                                        );
                                    }
                                    let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                        '_,
                                    >::default();
                                    query_args
                                        .reserve(
                                            2usize,
                                            0
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg0)
                                                + ::sqlx::encode::Encode::<
                                                    sqlx::postgres::Postgres,
                                                >::size_hint(arg1),
                                        );
                                    let query_args = ::core::result::Result::<
                                        _,
                                        ::sqlx::error::BoxDynError,
                                    >::Ok(query_args)
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg0).map(move |()| query_args)
                                        })
                                        .and_then(move |mut query_args| {
                                            query_args.add(arg1).map(move |()| query_args)
                                        });
                                    #[allow(non_snake_case)]
                                    struct Record {
                                        r#type: ActionType,
                                        user_id: i64,
                                        created_at: sqlx::types::chrono::NaiveDateTime,
                                        expires_at: ::std::option::Option<
                                            sqlx::types::chrono::NaiveDateTime,
                                        >,
                                        reason: String,
                                    }
                                    #[automatically_derived]
                                    #[allow(non_snake_case)]
                                    impl ::core::fmt::Debug for Record {
                                        #[inline]
                                        fn fmt(
                                            &self,
                                            f: &mut ::core::fmt::Formatter,
                                        ) -> ::core::fmt::Result {
                                            ::core::fmt::Formatter::debug_struct_field5_finish(
                                                f,
                                                "Record",
                                                "type",
                                                &self.r#type,
                                                "user_id",
                                                &self.user_id,
                                                "created_at",
                                                &self.created_at,
                                                "expires_at",
                                                &self.expires_at,
                                                "reason",
                                                &&self.reason,
                                            )
                                        }
                                    }
                                    ::sqlx::__query_with_result::<
                                        sqlx::postgres::Postgres,
                                        _,
                                    >(
                                            "\n                SELECT type as \"type!: ActionType\", user_id, created_at, expires_at, reason FROM actions WHERE guild_id = $1 AND id = $2;\n            ",
                                            query_args,
                                        )
                                        .try_map(|row: sqlx::postgres::PgRow| {
                                            use ::sqlx::Row as _;
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_type = row
                                                .try_get_unchecked::<ActionType, _>(0usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_user_id = row
                                                .try_get_unchecked::<i64, _>(1usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_created_at = row
                                                .try_get_unchecked::<
                                                    sqlx::types::chrono::NaiveDateTime,
                                                    _,
                                                >(2usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_expires_at = row
                                                .try_get_unchecked::<
                                                    ::std::option::Option<sqlx::types::chrono::NaiveDateTime>,
                                                    _,
                                                >(3usize)?
                                                .into();
                                            #[allow(non_snake_case)]
                                            let sqlx_query_as_reason = row
                                                .try_get_unchecked::<String, _>(4usize)?
                                                .into();
                                            ::std::result::Result::Ok(Record {
                                                r#type: sqlx_query_as_type,
                                                user_id: sqlx_query_as_user_id,
                                                created_at: sqlx_query_as_created_at,
                                                expires_at: sqlx_query_as_expires_at,
                                                reason: sqlx_query_as_reason,
                                            })
                                        })
                                }
                            }
                        }
                            .fetch_one(SQL.get().unwrap())
                            .await;
                        let data = match res {
                            Ok(d) => d,
                            Err(err) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\duration.rs:87",
                                                "Ouroboros::commands::duration",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\duration.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(87u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::duration",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Couldn\'t fetch log data; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Couldn\'t fetch log data; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Err(CommandError {
                                    title: String::from("Unable to query the database"),
                                    hint: Some(String::from("try again later")),
                                    arg: None,
                                });
                            }
                        };
                        let now = Utc::now().naive_utc();
                        if data.expires_at.unwrap_or_default() <= now {
                            return Err(CommandError {
                                title: String::from("Already expired"),
                                hint: Some(
                                    String::from("this moderation action has already expired."),
                                ),
                                arg: None,
                            });
                        }
                        if data.created_at + duration <= now {
                            return Err(CommandError {
                                title: String::from(
                                    "This action would set the action duration to the past",
                                ),
                                hint: Some(
                                    String::from(
                                        "this would instantly reverse the action. If you are sure this is what you want please use the appropriate command like unban or unmute.",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        match data.r#type {
                            ActionType::Ban => {
                                if let Err(err) = {
                                    {
                                        #[allow(clippy::all)]
                                        {
                                            use ::sqlx::Arguments as _;
                                            let arg0 = &(data.created_at + duration);
                                            let arg1 = &(msg.guild_id.map(|g| g.get()).unwrap_or(0)
                                                as i64);
                                            let arg2 = &(id);
                                            #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                            if false {
                                                use ::sqlx::ty_match::{
                                                    WrapSameExt as _, MatchBorrowExt as _,
                                                };
                                                let expr = ::sqlx::ty_match::dupe_value(arg0);
                                                let ty_check = ::sqlx::ty_match::WrapSame::<
                                                    sqlx::types::chrono::NaiveDateTime,
                                                    _,
                                                >::new(&expr)
                                                    .wrap_same();
                                                let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                    ty_check,
                                                    &expr,
                                                );
                                                _ty_check = match_borrow.match_borrow();
                                                ::core::panicking::panic(
                                                    "internal error: entered unreachable code",
                                                );
                                            }
                                            #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                            if false {
                                                use ::sqlx::ty_match::{
                                                    WrapSameExt as _, MatchBorrowExt as _,
                                                };
                                                let expr = ::sqlx::ty_match::dupe_value(arg2);
                                                let ty_check = ::sqlx::ty_match::WrapSame::<
                                                    &str,
                                                    _,
                                                >::new(&expr)
                                                    .wrap_same();
                                                let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                    ty_check,
                                                    &expr,
                                                );
                                                _ty_check = match_borrow.match_borrow();
                                                ::core::panicking::panic(
                                                    "internal error: entered unreachable code",
                                                );
                                            }
                                            let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                                '_,
                                            >::default();
                                            query_args
                                                .reserve(
                                                    3usize,
                                                    0
                                                        + ::sqlx::encode::Encode::<
                                                            sqlx::postgres::Postgres,
                                                        >::size_hint(arg0)
                                                        + ::sqlx::encode::Encode::<
                                                            sqlx::postgres::Postgres,
                                                        >::size_hint(arg1)
                                                        + ::sqlx::encode::Encode::<
                                                            sqlx::postgres::Postgres,
                                                        >::size_hint(arg2),
                                                );
                                            let query_args = ::core::result::Result::<
                                                _,
                                                ::sqlx::error::BoxDynError,
                                            >::Ok(query_args)
                                                .and_then(move |mut query_args| {
                                                    query_args.add(arg0).map(move |()| query_args)
                                                })
                                                .and_then(move |mut query_args| {
                                                    query_args.add(arg1).map(move |()| query_args)
                                                })
                                                .and_then(move |mut query_args| {
                                                    query_args.add(arg2).map(move |()| query_args)
                                                });
                                            ::sqlx::__query_with_result::<
                                                sqlx::postgres::Postgres,
                                                _,
                                            >(
                                                "UPDATE actions SET expires_at = $1 WHERE guild_id = $2 AND id = $3",
                                                query_args,
                                            )
                                        }
                                    }
                                }
                                    .execute(SQL.get().unwrap())
                                    .await
                                {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src\\commands\\duration.rs:127",
                                                    "Ouroboros::commands::duration",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "src\\commands\\duration.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(127u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "Ouroboros::commands::duration",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                if match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            use ::tracing::log;
                                                            let level = match ::tracing::Level::WARN {
                                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                _ => ::tracing::log::Level::Trace,
                                                            };
                                                            if level <= log::max_level() {
                                                                let meta = __CALLSITE.metadata();
                                                                let log_meta = log::Metadata::builder()
                                                                    .level(level)
                                                                    .target(meta.target())
                                                                    .build();
                                                                let logger = log::logger();
                                                                if logger.enabled(&log_meta) {
                                                                    ::tracing::__macro_support::__tracing_log(
                                                                        meta,
                                                                        logger,
                                                                        log_meta,
                                                                        &value_set,
                                                                    )
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Couldn\'t update duration; err = {0:?}", err)
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &{
                                                                        #[allow(unused_imports)]
                                                                        use ::tracing::field::{debug, display, Value};
                                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                                        __CALLSITE
                                                                            .metadata()
                                                                            .fields()
                                                                            .value_set(
                                                                                &[
                                                                                    (
                                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                                        ::tracing::__macro_support::Option::Some(
                                                                                            &format_args!("Couldn\'t update duration; err = {0:?}", err)
                                                                                                as &dyn Value,
                                                                                        ),
                                                                                    ),
                                                                                ],
                                                                            )
                                                                    },
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        }
                                    };
                                    return Err(CommandError {
                                        title: String::from("Unable to query the database"),
                                        hint: Some(String::from("try again later")),
                                        arg: None,
                                    });
                                }
                            }
                            ActionType::Mute => {
                                let time = data.created_at + duration;
                                let edit = EditMember::new()
                                    .audit_log_reason(&data.reason)
                                    .disable_communication_until_datetime(
                                        time.and_utc().into(),
                                    );
                                let member_result = msg
                                    .guild_id
                                    .unwrap()
                                    .member(&ctx.http, data.user_id as u64)
                                    .await;
                                if member_result.is_err() {
                                    return Err(CommandError {
                                        title: String::from("Unable to update the mute duration"),
                                        hint: Some(
                                            String::from(
                                                "the target of the action isn't in the server anymore. Urge them to join back!",
                                            ),
                                        ),
                                        arg: None,
                                    });
                                }
                                if let Ok(mut member) = member_result
                                    && (member.enable_communication(&ctx.http).await.is_err()
                                        || member
                                            .guild_id
                                            .edit_member(&ctx.http, &member, edit)
                                            .await
                                            .is_err())
                                {
                                    return Err(CommandError {
                                        title: String::from("Unable to update the mute duration"),
                                        hint: Some(
                                            String::from(
                                                "check if the bot has permissions to time the member out",
                                            ),
                                        ),
                                        arg: None,
                                    });
                                }
                                if let Err(err) = {
                                    {
                                        #[allow(clippy::all)]
                                        {
                                            use ::sqlx::Arguments as _;
                                            let arg0 = &(data.created_at + duration);
                                            let arg1 = &(msg.guild_id.map(|g| g.get()).unwrap_or(0)
                                                as i64);
                                            let arg2 = &(id);
                                            #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                            if false {
                                                use ::sqlx::ty_match::{
                                                    WrapSameExt as _, MatchBorrowExt as _,
                                                };
                                                let expr = ::sqlx::ty_match::dupe_value(arg0);
                                                let ty_check = ::sqlx::ty_match::WrapSame::<
                                                    sqlx::types::chrono::NaiveDateTime,
                                                    _,
                                                >::new(&expr)
                                                    .wrap_same();
                                                let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                    ty_check,
                                                    &expr,
                                                );
                                                _ty_check = match_borrow.match_borrow();
                                                ::core::panicking::panic(
                                                    "internal error: entered unreachable code",
                                                );
                                            }
                                            #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                            if false {
                                                use ::sqlx::ty_match::{
                                                    WrapSameExt as _, MatchBorrowExt as _,
                                                };
                                                let expr = ::sqlx::ty_match::dupe_value(arg2);
                                                let ty_check = ::sqlx::ty_match::WrapSame::<
                                                    &str,
                                                    _,
                                                >::new(&expr)
                                                    .wrap_same();
                                                let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                    ty_check,
                                                    &expr,
                                                );
                                                _ty_check = match_borrow.match_borrow();
                                                ::core::panicking::panic(
                                                    "internal error: entered unreachable code",
                                                );
                                            }
                                            let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                                '_,
                                            >::default();
                                            query_args
                                                .reserve(
                                                    3usize,
                                                    0
                                                        + ::sqlx::encode::Encode::<
                                                            sqlx::postgres::Postgres,
                                                        >::size_hint(arg0)
                                                        + ::sqlx::encode::Encode::<
                                                            sqlx::postgres::Postgres,
                                                        >::size_hint(arg1)
                                                        + ::sqlx::encode::Encode::<
                                                            sqlx::postgres::Postgres,
                                                        >::size_hint(arg2),
                                                );
                                            let query_args = ::core::result::Result::<
                                                _,
                                                ::sqlx::error::BoxDynError,
                                            >::Ok(query_args)
                                                .and_then(move |mut query_args| {
                                                    query_args.add(arg0).map(move |()| query_args)
                                                })
                                                .and_then(move |mut query_args| {
                                                    query_args.add(arg1).map(move |()| query_args)
                                                })
                                                .and_then(move |mut query_args| {
                                                    query_args.add(arg2).map(move |()| query_args)
                                                });
                                            ::sqlx::__query_with_result::<
                                                sqlx::postgres::Postgres,
                                                _,
                                            >(
                                                "UPDATE actions SET expires_at = $1 WHERE guild_id = $2 AND id = $3",
                                                query_args,
                                            )
                                        }
                                    }
                                }
                                    .execute(SQL.get().unwrap())
                                    .await
                                {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src\\commands\\duration.rs:183",
                                                    "Ouroboros::commands::duration",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "src\\commands\\duration.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(183u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "Ouroboros::commands::duration",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                if match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            use ::tracing::log;
                                                            let level = match ::tracing::Level::WARN {
                                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                _ => ::tracing::log::Level::Trace,
                                                            };
                                                            if level <= log::max_level() {
                                                                let meta = __CALLSITE.metadata();
                                                                let log_meta = log::Metadata::builder()
                                                                    .level(level)
                                                                    .target(meta.target())
                                                                    .build();
                                                                let logger = log::logger();
                                                                if logger.enabled(&log_meta) {
                                                                    ::tracing::__macro_support::__tracing_log(
                                                                        meta,
                                                                        logger,
                                                                        log_meta,
                                                                        &value_set,
                                                                    )
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Couldn\'t update duration; err = {0:?}", err)
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &{
                                                                        #[allow(unused_imports)]
                                                                        use ::tracing::field::{debug, display, Value};
                                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                                        __CALLSITE
                                                                            .metadata()
                                                                            .fields()
                                                                            .value_set(
                                                                                &[
                                                                                    (
                                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                                        ::tracing::__macro_support::Option::Some(
                                                                                            &format_args!("Couldn\'t update duration; err = {0:?}", err)
                                                                                                as &dyn Value,
                                                                                        ),
                                                                                    ),
                                                                                ],
                                                                            )
                                                                    },
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        }
                                    };
                                    return Err(CommandError {
                                        title: String::from("Unable to query the database"),
                                        hint: Some(String::from("try again later")),
                                        arg: None,
                                    });
                                }
                            }
                            _ => {
                                return Err(CommandError {
                                    title: String::from("Invalid action type"),
                                    hint: Some(
                                        String::from(
                                            "this moderation action does not have a duration.",
                                        ),
                                    ),
                                    arg: None,
                                });
                            }
                        };
                        let new_expiry_date = data.created_at + duration;
                        let reply = CreateMessage::new()
                            .add_embed(
                                CreateEmbed::new()
                                    .description(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "**`{1}` UPDATED**\n-# New Expiry: {0}",
                                                    new_expiry_date.format("%Y-%m-%d %H:%M:%S"),
                                                    id,
                                                ),
                                            )
                                        }),
                                    )
                                    .color(BRAND_BLUE),
                            )
                            .reference_message(&msg)
                            .allowed_mentions(
                                CreateAllowedMentions::new().replied_user(false),
                            );
                        if let Err(err) = msg
                            .channel_id
                            .send_message(&ctx.http, reply)
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\duration.rs:217",
                                            "Ouroboros::commands::duration",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\duration.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(217u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::duration",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Could not send message; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Could not send message; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                        }
                        guild_log(
                                &ctx.http,
                                LogType::ActionUpdate,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**ACTION UPDATED**\n-# Log ID: `{3}` | Actor: {0} `{1}` | New Expiry: {2}",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            new_expiry_date.format("%Y-%m-%d %H:%M:%S"),
                                                            id,
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Arc::new(Transformers::some_string),
                        Arc::new(Transformers::duration),
                    ]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: ::alloc::vec::Vec::new(),
                    one_of: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            Permissions::MANAGE_NICKNAMES,
                            Permissions::KICK_MEMBERS,
                            Permissions::MODERATE_MEMBERS,
                            Permissions::BAN_MEMBERS,
                        ]),
                    ),
                }
            }
        }
    }
    pub use duration::Duration;
    mod extract_id {
        use serenity::{
            all::{Context, CreateAllowedMentions, CreateEmbed, CreateMessage, Message},
            async_trait,
        };
        use tracing::warn;
        use crate::{
            commands::{Command, CommandCategory, CommandParameter, CommandSyntax},
            constants::BRAND_BLUE, event_handler::CommandError, lexer::Token,
        };
        pub struct ExtractId;
        impl ExtractId {
            pub fn new() -> Self {
                Self
            }
        }
        impl Command for ExtractId {
            fn get_name(&self) -> &'static str {
                "eid"
            }
            fn get_short(&self) -> &'static str {
                "Extracts an id from a message"
            }
            fn get_full(&self) -> &'static str {
                "Checks a replied to message for ids and sends them in separate messages. Useful for people on mobile who don't want to fight with their phone about copying out an id."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                ::alloc::vec::Vec::new()
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Utilities
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn run<'life0, 'async_trait>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                _args: Vec<Token>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let _args = _args;
                    let __ret: Result<(), CommandError> = {
                        let Some(reply) = &msg.referenced_message else {
                            return Err(CommandError {
                                title: String::from(
                                    "You must reply to a message to use this command",
                                ),
                                hint: None,
                                arg: None,
                            });
                        };
                        let mut search_text = reply.content.clone();
                        for embed in &reply.embeds {
                            let mut embed_locations = <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    embed.title.clone(),
                                    embed.description.clone(),
                                    embed.footer.clone().map(|f| f.text),
                                    embed.author.clone().map(|a| a.name),
                                ]),
                            );
                            embed
                                .fields
                                .iter()
                                .for_each(|f| {
                                    embed_locations.push(Some(f.name.clone()));
                                    embed_locations.push(Some(f.value.clone()));
                                });
                            embed_locations
                                .into_iter()
                                .for_each(|s| {
                                    search_text
                                        .push_str(
                                            ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!("\n{0}", &s.unwrap_or_default()),
                                                    )
                                                })
                                                .as_str(),
                                        );
                                });
                        }
                        let ids: Vec<String> = search_text
                            .split_whitespace()
                            .filter(|part| part.chars().all(|c| c.is_ascii_digit()))
                            .filter(|part| part.len() >= 5 && part.len() <= 20)
                            .map(|s| s.to_string())
                            .collect();
                        if ids.is_empty() {
                            let reply = CreateMessage::new()
                                .add_embed(
                                    CreateEmbed::new()
                                        .description("No IDs found in the referenced message.")
                                        .color(BRAND_BLUE),
                                )
                                .reference_message(&msg)
                                .allowed_mentions(
                                    CreateAllowedMentions::new().replied_user(false),
                                );
                            if let Err(err) = msg
                                .channel_id
                                .send_message(&ctx.http, reply)
                                .await
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\extract_id.rs:93",
                                                "Ouroboros::commands::extract_id",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\extract_id.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(93u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::extract_id",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                        } else {
                            let mut iter = ids.into_iter();
                            let first_id = iter.next().unwrap();
                            let reply = CreateMessage::new()
                                .content(first_id)
                                .reference_message(&msg)
                                .allowed_mentions(
                                    CreateAllowedMentions::new().replied_user(false),
                                );
                            if let Err(err) = msg
                                .channel_id
                                .send_message(&ctx.http, reply)
                                .await
                            {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\extract_id.rs:105",
                                                "Ouroboros::commands::extract_id",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\extract_id.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(105u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::extract_id",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                            }
                            for id in iter.take(4) {
                                let reply = CreateMessage::new().content(id);
                                if let Err(err) = msg
                                    .channel_id
                                    .send_message(&ctx.http, reply)
                                    .await
                                {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src\\commands\\extract_id.rs:112",
                                                    "Ouroboros::commands::extract_id",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "src\\commands\\extract_id.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(112u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "Ouroboros::commands::extract_id",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                if match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            use ::tracing::log;
                                                            let level = match ::tracing::Level::WARN {
                                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                _ => ::tracing::log::Level::Trace,
                                                            };
                                                            if level <= log::max_level() {
                                                                let meta = __CALLSITE.metadata();
                                                                let log_meta = log::Metadata::builder()
                                                                    .level(level)
                                                                    .target(meta.target())
                                                                    .build();
                                                                let logger = log::logger();
                                                                if logger.enabled(&log_meta) {
                                                                    ::tracing::__macro_support::__tracing_log(
                                                                        meta,
                                                                        logger,
                                                                        log_meta,
                                                                        &value_set,
                                                                    )
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Could not send message; err = {0:?}", err)
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &{
                                                                        #[allow(unused_imports)]
                                                                        use ::tracing::field::{debug, display, Value};
                                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                                        __CALLSITE
                                                                            .metadata()
                                                                            .fields()
                                                                            .value_set(
                                                                                &[
                                                                                    (
                                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                                        ::tracing::__macro_support::Option::Some(
                                                                                            &format_args!("Could not send message; err = {0:?}", err)
                                                                                                as &dyn Value,
                                                                                        ),
                                                                                    ),
                                                                                ],
                                                                            )
                                                                    },
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        }
                                    };
                                }
                            }
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
    }
    pub use extract_id::ExtractId;
    mod cache {
        use std::{sync::Arc, time::Duration};
        use serenity::{
            all::{
                Context, CreateAllowedMentions, CreateEmbed, CreateMessage, Mentionable,
                Message, Permissions,
            },
            async_trait,
        };
        use tokio::time::sleep;
        use tracing::warn;
        use crate::{
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError,
            lexer::{InferType, Token},
            transformers::Transformers, utils::{LogType, guild_log},
        };
        use ouroboros_macros::command;
        pub struct Cache;
        impl Cache {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for Cache {
            fn get_name(&self) -> &'static str {
                "cache"
            }
            fn get_short(&self) -> &'static str {
                "Causes clients to cache the target user"
            }
            fn get_full(&self) -> &'static str {
                "Bans and immediately unbans a user to make clients cache the user. \
        Does not work on members who are already in the server, as those do not need to be forced into the cache."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([CommandSyntax::User("user", true)]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Utilities
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let user = {
                    let Some(Token { contents: Some(CommandArgument::User(b)), .. }) = args_iter
                        .next() else {
                        return Box::pin(async move {
                            Err(CommandError::arg_not_found("user", Some("User")))
                        })
                    };
                    b
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let user = user;
                    let __ret: Result<(), CommandError> = {
                        let inferred = args
                            .first()
                            .map(|a| match a.inferred {
                                Some(InferType::Message) => true,
                                _ => false,
                            })
                            .unwrap_or(false);
                        if msg.guild_id.unwrap().member(&ctx.http, user.id).await.is_ok()
                        {
                            return Err(CommandError {
                                title: String::from("User was found in the server"),
                                hint: None,
                                arg: None,
                            });
                        }
                        if let Err(err) = msg
                            .guild_id
                            .unwrap()
                            .ban_with_reason(
                                &ctx.http,
                                &user,
                                0,
                                "Forced into client cache",
                            )
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\cache.rs:91",
                                            "Ouroboros::commands::cache",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\cache.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(91u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::cache",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while banning; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while banning; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not ban member"),
                                hint: Some(
                                    String::from(
                                        "check if the bot has the ban members permission or try again later",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        if let Err(err) = msg
                            .guild_id
                            .unwrap()
                            .unban(&ctx.http, &user)
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\commands\\cache.rs:103",
                                            "Ouroboros::commands::cache",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\commands\\cache.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(103u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::commands::cache",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Got error while unbanning; err = {0:?}", err)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Got error while unbanning; err = {0:?}", err)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                            return Err(CommandError {
                                title: String::from("Could not unban member"),
                                hint: Some(
                                    String::from(
                                        "check if the bot has the ban members permission or try again later",
                                    ),
                                ),
                                arg: None,
                            });
                        }
                        let reply = CreateMessage::new()
                            .add_embed(
                                CreateEmbed::new()
                                    .description(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "**{0} CACHED**\n-# Target: {0} `{1}`",
                                                    user.mention(),
                                                    user.id.get(),
                                                ),
                                            )
                                        }),
                                    )
                                    .color(BRAND_BLUE),
                            )
                            .reference_message(&msg)
                            .allowed_mentions(
                                CreateAllowedMentions::new().replied_user(false),
                            );
                        let reply_msg = msg
                            .channel_id
                            .send_message(&ctx.http, reply)
                            .await;
                        guild_log(
                                &ctx.http,
                                LogType::MemberCache,
                                msg.guild_id.unwrap(),
                                CreateMessage::new()
                                    .add_embed(
                                        CreateEmbed::new()
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "**MEMBER CACHED**\n-# Actor: {0} `{1}` | Target: {2} `{3}`",
                                                            msg.author.mention(),
                                                            msg.author.id.get(),
                                                            user.mention(),
                                                            user.id.get(),
                                                        ),
                                                    )
                                                }),
                                            )
                                            .color(BRAND_BLUE),
                                    ),
                            )
                            .await;
                        let reply_msg = match reply_msg {
                            Ok(m) => m,
                            Err(err) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\cache.rs:150",
                                                "Ouroboros::commands::cache",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\cache.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(150u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::cache",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Ok(());
                            }
                        };
                        if inferred && let Some(reply) = msg.referenced_message.clone() {
                            let _ = reply.delete(&ctx.http).await;
                        }
                        if inferred {
                            let http = ctx.http.clone();
                            tokio::spawn(async move {
                                sleep(Duration::from_secs(5)).await;
                                let _ = msg.delete(&http).await;
                                let _ = reply_msg.delete(&http).await;
                            });
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([Arc::new(Transformers::reply_user)]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::BAN_MEMBERS]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use cache::Cache;
    mod define_log {
        use std::{
            collections::{HashMap, hash_map::Entry::Vacant},
            sync::Arc, time::Duration,
        };
        use serenity::{
            all::{
                ButtonStyle, ComponentInteractionDataKind, Context, CreateActionRow,
                CreateAllowedMentions, CreateButton, CreateEmbed,
                CreateInteractionResponse, CreateInteractionResponseMessage,
                CreateMessage, CreateSelectMenu, CreateSelectMenuKind,
                CreateSelectMenuOption, EditMessage, GuildChannel, Message, Permissions,
            },
            async_trait, json,
        };
        use sqlx::query;
        use tracing::warn;
        use crate::{
            GUILD_SETTINGS, SQL,
            commands::{
                Command, CommandArgument, CommandCategory, CommandParameter,
                CommandPermissions, CommandSyntax, TransformerFnArc,
            },
            constants::BRAND_BLUE, event_handler::CommandError, lexer::Token,
            transformers::Transformers, utils::LogType,
        };
        use ouroboros_macros::command;
        pub struct DefineLog;
        impl DefineLog {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for DefineLog {
            fn get_name(&self) -> &'static str {
                "dlog"
            }
            fn get_short(&self) -> &'static str {
                "Defines a channel as a log channel"
            }
            fn get_full(&self) -> &'static str {
                "Defines a channel as a log channel. \
        If no channel is provided the current channel will be selected. \
        You will be able to choose the specific types of events which will get logged within the selected channel."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([CommandSyntax::Channel("channel", true)]),
                )
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Admin
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                let channel: Option<GuildChannel> = match args_iter.next() {
                    Some(arg) => {
                        match arg.contents {
                            Some(CommandArgument::GuildChannel(inner)) => Some(inner),
                            _ => None,
                        }
                    }
                    None => None,
                };
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let channel = channel;
                    let __ret: Result<(), CommandError> = {
                        let channel = channel
                            .unwrap_or_else(|| {
                                msg.guild(&ctx.cache)
                                    .unwrap()
                                    .channels
                                    .get(&msg.channel_id)
                                    .unwrap()
                                    .clone()
                            });
                        let channel_ids: HashMap<LogType, u64>;
                        {
                            let mut lock = GUILD_SETTINGS.get().unwrap().lock().await;
                            channel_ids = lock
                                .get(msg.guild_id.unwrap().get())
                                .await
                                .unwrap()
                                .log
                                .log_channel_ids
                                .clone();
                        }
                        let options = LogType::all()
                            .into_iter()
                            .map(|t| {
                                let mut opt = CreateSelectMenuOption::new(
                                    t.title(),
                                    json::to_string(&t).unwrap(),
                                );
                                if let Some(current_channel) = channel_ids.get(&t) {
                                    if *current_channel != channel.id.get() {
                                        opt = opt
                                            .description(
                                                ::alloc::__export::must_use({
                                                    ::alloc::fmt::format(
                                                        format_args!(
                                                            "Currently assigned to <#{0}> - will overwrite!",
                                                            current_channel,
                                                        ),
                                                    )
                                                }),
                                            )
                                    } else {
                                        opt = opt.description("Currently assigned to this channel")
                                    }
                                }
                                opt
                            })
                            .collect::<Vec<_>>();
                        let options_len = options.len() as u8;
                        let components = <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                CreateActionRow::SelectMenu(
                                    CreateSelectMenu::new(
                                            "type_select",
                                            CreateSelectMenuKind::String {
                                                options,
                                            },
                                        )
                                        .max_values(options_len),
                                ),
                                CreateActionRow::Buttons(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            CreateButton::new("keep")
                                                .label("Keep")
                                                .style(ButtonStyle::Primary),
                                            CreateButton::new("all")
                                                .label("All")
                                                .style(ButtonStyle::Secondary),
                                            CreateButton::new("reset")
                                                .label("Reset")
                                                .style(ButtonStyle::Danger),
                                            CreateButton::new("cancel")
                                                .label("Cancel")
                                                .style(ButtonStyle::Secondary),
                                        ]),
                                    ),
                                ),
                            ]),
                        );
                        let reply = CreateMessage::new()
                            .add_embed(
                                CreateEmbed::new()
                                    .description(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!(
                                                    "**DEFINE LOG**\nPlease select the type of events to log in this channel <#{0}>.\n\n                        `Keep` - set this channel for events that don’t have a channel yet\n                        `All` - set this channel for all events, even if they already have one\n                        `Reset` - remove this channel from all events\n                        `Cancel` - do nothing",
                                                    channel.id.get(),
                                                ),
                                            )
                                        }),
                                    )
                                    .color(BRAND_BLUE),
                            )
                            .components(components)
                            .reference_message(&msg)
                            .allowed_mentions(
                                CreateAllowedMentions::new().replied_user(false),
                            );
                        let mut new_msg = match msg
                            .channel_id
                            .send_message(&ctx.http, reply)
                            .await
                        {
                            Ok(m) => m,
                            Err(err) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\define_log.rs:159",
                                                "Ouroboros::commands::define_log",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\define_log.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(159u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::define_log",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not send message; err = {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!("Could not send message; err = {0:?}", err)
                                                                                            as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Ok(());
                            }
                        };
                        loop {
                            let interaction = match new_msg
                                .await_component_interaction(&ctx.shard)
                                .timeout(Duration::from_secs(60 * 5))
                                .await
                            {
                                Some(i) => i,
                                None => {
                                    let _ = new_msg
                                        .edit(
                                            &ctx.http,
                                            EditMessage::new()
                                                .components(
                                                    <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            CreateActionRow::SelectMenu(
                                                                CreateSelectMenu::new(
                                                                        "type_select",
                                                                        CreateSelectMenuKind::String {
                                                                            options: ::alloc::vec::Vec::new(),
                                                                        },
                                                                    )
                                                                    .max_values(options_len)
                                                                    .disabled(true),
                                                            ),
                                                            CreateActionRow::Buttons(
                                                                <[_]>::into_vec(
                                                                    ::alloc::boxed::box_new([
                                                                        CreateButton::new("all")
                                                                            .label("All")
                                                                            .style(ButtonStyle::Primary)
                                                                            .disabled(true),
                                                                        CreateButton::new("reset")
                                                                            .label("Reset")
                                                                            .style(ButtonStyle::Danger)
                                                                            .disabled(true),
                                                                    ]),
                                                                ),
                                                            ),
                                                        ]),
                                                    ),
                                                ),
                                        )
                                        .await;
                                    return Ok(());
                                }
                            };
                            if interaction.user.id != msg.author.id {
                                if let Err(e) = interaction
                                    .create_response(
                                        &ctx.http,
                                        CreateInteractionResponse::Message(
                                            CreateInteractionResponseMessage::new()
                                                .content("You are not the author of the original message!")
                                                .ephemeral(true),
                                        ),
                                    )
                                    .await
                                {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src\\commands\\define_log.rs:213",
                                                    "Ouroboros::commands::define_log",
                                                    ::tracing::Level::WARN,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "src\\commands\\define_log.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(213u32),
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "Ouroboros::commands::define_log",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::WARN
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::WARN
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                if match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                                {
                                                    if !::tracing::dispatcher::has_been_set() {
                                                        {
                                                            use ::tracing::log;
                                                            let level = match ::tracing::Level::WARN {
                                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                                _ => ::tracing::log::Level::Trace,
                                                            };
                                                            if level <= log::max_level() {
                                                                let meta = __CALLSITE.metadata();
                                                                let log_meta = log::Metadata::builder()
                                                                    .level(level)
                                                                    .target(meta.target())
                                                                    .build();
                                                                let logger = log::logger();
                                                                if logger.enabled(&log_meta) {
                                                                    ::tracing::__macro_support::__tracing_log(
                                                                        meta,
                                                                        logger,
                                                                        log_meta,
                                                                        &value_set,
                                                                    )
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        {}
                                                    }
                                                } else {
                                                    {}
                                                };
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Could not send message; err = {0:?}", e)
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &{
                                                                        #[allow(unused_imports)]
                                                                        use ::tracing::field::{debug, display, Value};
                                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                                        __CALLSITE
                                                                            .metadata()
                                                                            .fields()
                                                                            .value_set(
                                                                                &[
                                                                                    (
                                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                                        ::tracing::__macro_support::Option::Some(
                                                                                            &format_args!("Could not send message; err = {0:?}", e)
                                                                                                as &dyn Value,
                                                                                        ),
                                                                                    ),
                                                                                ],
                                                                            )
                                                                    },
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        }
                                    };
                                }
                                continue;
                            }
                            let new_values = match interaction.data.custom_id.as_str() {
                                "type_select" => {
                                    let ComponentInteractionDataKind::StringSelect { values } = interaction
                                        .data
                                        .kind
                                        .clone() else {
                                        return Err(CommandError {
                                            title: String::from("Unexpected interaction data kind"),
                                            hint: Some(
                                                String::from(
                                                    "you found an ultra-rare error! please contact the developers about this",
                                                ),
                                            ),
                                            arg: None,
                                        });
                                    };
                                    let mut current_values = channel_ids.clone();
                                    values
                                        .into_iter()
                                        .map(|t| json::from_str::<LogType>(t).unwrap())
                                        .for_each(|t| {
                                            current_values.insert(t, channel.id.get());
                                        });
                                    current_values
                                }
                                "keep" => {
                                    let mut current_values = channel_ids.clone();
                                    for log_type in LogType::all() {
                                        if let Vacant(e) = current_values.entry(log_type) {
                                            e.insert(channel.id.get());
                                        }
                                    }
                                    current_values
                                }
                                "all" => {
                                    LogType::all()
                                        .into_iter()
                                        .map(|t| (t, channel.id.get()))
                                        .collect::<HashMap<LogType, u64>>()
                                }
                                "reset" => {
                                    let mut current_values = channel_ids.clone();
                                    for (log_type, channel_id) in current_values.clone() {
                                        if channel_id == channel.id.get() {
                                            current_values.remove(&log_type);
                                        }
                                    }
                                    current_values
                                }
                                "cancel" => channel_ids,
                                _ => return Ok(()),
                            };
                            let _ = new_msg
                                .edit(
                                    &ctx.http,
                                    EditMessage::new()
                                        .components(
                                            <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    CreateActionRow::SelectMenu(
                                                        CreateSelectMenu::new(
                                                                "type_select",
                                                                CreateSelectMenuKind::String {
                                                                    options: ::alloc::vec::Vec::new(),
                                                                },
                                                            )
                                                            .max_values(options_len)
                                                            .disabled(true),
                                                    ),
                                                    CreateActionRow::Buttons(
                                                        <[_]>::into_vec(
                                                            ::alloc::boxed::box_new([
                                                                CreateButton::new("all")
                                                                    .label("All")
                                                                    .style(ButtonStyle::Primary)
                                                                    .disabled(true),
                                                                CreateButton::new("reset")
                                                                    .label("Reset")
                                                                    .style(ButtonStyle::Danger)
                                                                    .disabled(true),
                                                            ]),
                                                        ),
                                                    ),
                                                ]),
                                            ),
                                        ),
                                )
                                .await;
                            let res = {
                                {
                                    #[allow(clippy::all)]
                                    {
                                        use ::sqlx::Arguments as _;
                                        let arg0 = &(msg.guild_id.unwrap().get() as i64);
                                        let arg1 = &(json::to_value(&new_values).unwrap());
                                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                                        if false {
                                            use ::sqlx::ty_match::{
                                                WrapSameExt as _, MatchBorrowExt as _,
                                            };
                                            let expr = ::sqlx::ty_match::dupe_value(arg1);
                                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                                sqlx::types::JsonValue,
                                                _,
                                            >::new(&expr)
                                                .wrap_same();
                                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                                ty_check,
                                                &expr,
                                            );
                                            _ty_check = match_borrow.match_borrow();
                                            ::core::panicking::panic(
                                                "internal error: entered unreachable code",
                                            );
                                        }
                                        let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                            '_,
                                        >::default();
                                        query_args
                                            .reserve(
                                                2usize,
                                                0
                                                    + ::sqlx::encode::Encode::<
                                                        sqlx::postgres::Postgres,
                                                    >::size_hint(arg0)
                                                    + ::sqlx::encode::Encode::<
                                                        sqlx::postgres::Postgres,
                                                    >::size_hint(arg1),
                                            );
                                        let query_args = ::core::result::Result::<
                                            _,
                                            ::sqlx::error::BoxDynError,
                                        >::Ok(query_args)
                                            .and_then(move |mut query_args| {
                                                query_args.add(arg0).map(move |()| query_args)
                                            })
                                            .and_then(move |mut query_args| {
                                                query_args.add(arg1).map(move |()| query_args)
                                            });
                                        ::sqlx::__query_with_result::<
                                            sqlx::postgres::Postgres,
                                            _,
                                        >(
                                            "UPDATE guild_settings SET log_channel_ids = $2 WHERE guild_id = $1",
                                            query_args,
                                        )
                                    }
                                }
                            }
                                .execute(SQL.get().unwrap())
                                .await;
                            if let Err(err) = res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src\\commands\\define_log.rs:314",
                                                "Ouroboros::commands::define_log",
                                                ::tracing::Level::WARN,
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "src\\commands\\define_log.rs",
                                                ),
                                                ::tracing_core::__macro_support::Option::Some(314u32),
                                                ::tracing_core::__macro_support::Option::Some(
                                                    "Ouroboros::commands::define_log",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::WARN
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::WARN
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                            if match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            } <= ::tracing::log::STATIC_MAX_LEVEL
                                            {
                                                if !::tracing::dispatcher::has_been_set() {
                                                    {
                                                        use ::tracing::log;
                                                        let level = match ::tracing::Level::WARN {
                                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                            _ => ::tracing::log::Level::Trace,
                                                        };
                                                        if level <= log::max_level() {
                                                            let meta = __CALLSITE.metadata();
                                                            let log_meta = log::Metadata::builder()
                                                                .level(level)
                                                                .target(meta.target())
                                                                .build();
                                                            let logger = log::logger();
                                                            if logger.enabled(&log_meta) {
                                                                ::tracing::__macro_support::__tracing_log(
                                                                    meta,
                                                                    logger,
                                                                    log_meta,
                                                                    &value_set,
                                                                )
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    {}
                                                }
                                            } else {
                                                {}
                                            };
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!(
                                                                    "Got error while updating guild log ids; err = {0:?}",
                                                                    err,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &{
                                                                    #[allow(unused_imports)]
                                                                    use ::tracing::field::{debug, display, Value};
                                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                                    __CALLSITE
                                                                        .metadata()
                                                                        .fields()
                                                                        .value_set(
                                                                            &[
                                                                                (
                                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                                    ::tracing::__macro_support::Option::Some(
                                                                                        &format_args!(
                                                                                            "Got error while updating guild log ids; err = {0:?}",
                                                                                            err,
                                                                                        ) as &dyn Value,
                                                                                    ),
                                                                                ),
                                                                            ],
                                                                        )
                                                                },
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    }
                                };
                                return Err(CommandError {
                                    title: String::from("Could not update the database"),
                                    hint: Some(String::from("please try again later")),
                                    arg: None,
                                });
                            }
                            {
                                let mut lock = GUILD_SETTINGS.get().unwrap().lock().await;
                                lock.invalidate();
                            }
                            let _ = interaction
                                .create_response(
                                    &ctx.http,
                                    CreateInteractionResponse::Message(
                                        CreateInteractionResponseMessage::new()
                                            .content("Successfully updated the log channel ids!")
                                            .ephemeral(true),
                                    ),
                                )
                                .await;
                            let _ = msg.delete(&ctx.http).await;
                            let _ = new_msg.delete(&ctx.http).await;
                            return Ok(());
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([Arc::new(Transformers::guild_channel)]),
                )
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: <[_]>::into_vec(
                        ::alloc::boxed::box_new([Permissions::ADMINISTRATOR]),
                    ),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use define_log::DefineLog;
    mod permdbg {
        use serenity::{
            all::{Context, CreateAttachment, CreateMessage, Message, Permissions},
            async_trait,
        };
        use tracing::warn;
        use crate::{
            commands::{
                Command, CommandCategory, CommandParameter, CommandPermissions,
                CommandSyntax, TransformerFnArc,
            },
            event_handler::CommandError, lexer::Token, utils::is_developer,
        };
        use ouroboros_macros::command;
        pub struct PermDbg;
        impl PermDbg {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl Command for PermDbg {
            fn get_name(&self) -> &'static str {
                "permdbg"
            }
            fn get_short(&self) -> &'static str {
                "Gets permission debug information"
            }
            fn get_full(&self) -> &'static str {
                "Send this message in a channel to check the bots permissions of the channel."
            }
            fn get_syntax(&self) -> Vec<CommandSyntax> {
                ::alloc::vec::Vec::new()
            }
            fn get_category(&self) -> CommandCategory {
                CommandCategory::Developer
            }
            fn get_args(&self) -> Vec<&'static CommandParameter<'static>> {
                ::alloc::vec::Vec::new()
            }
            fn run<'life0, 'async_trait, 'life1>(
                &'life0 self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
                params: std::collections::HashMap<&'life1 str, CommandArgument>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), CommandError>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                let mut args_iter = args.clone().into_iter();
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), CommandError>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let ctx = ctx;
                    let msg = msg;
                    let __ret: Result<(), CommandError> = {
                        if is_developer(&msg.author) {
                            let channel = msg
                                .channel(&ctx.http)
                                .await
                                .unwrap()
                                .guild()
                                .unwrap();
                            let guild_perms: Vec<Permissions> = ::alloc::vec::Vec::new();
                            let channel_perms: Vec<Permissions> = ::alloc::vec::Vec::new();
                            ::core::panicking::panic("not yet implemented")
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            fn get_transformers(&self) -> Vec<TransformerFnArc> {
                ::alloc::vec::Vec::new()
            }
            fn get_permissions(&self) -> CommandPermissions {
                CommandPermissions {
                    required: ::alloc::vec::Vec::new(),
                    one_of: ::alloc::vec::Vec::new(),
                }
            }
        }
    }
    pub use permdbg::PermDbg;
}
mod config {
    use serde::Deserialize;
    pub struct Config {
        pub bot: Bot,
        pub release: Environment,
        pub dev: Environment,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Config {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Config",
                "bot",
                &self.bot,
                "release",
                &self.release,
                "dev",
                &&self.dev,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Config {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "bot" => _serde::__private::Ok(__Field::__field0),
                            "release" => _serde::__private::Ok(__Field::__field1),
                            "dev" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"bot" => _serde::__private::Ok(__Field::__field0),
                            b"release" => _serde::__private::Ok(__Field::__field1),
                            b"dev" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Config>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Config;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Config",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Bot,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Config with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Environment,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Config with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Environment,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Config with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Config {
                            bot: __field0,
                            release: __field1,
                            dev: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Bot> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Environment> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Environment> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("bot"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Bot>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "release",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Environment,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("dev"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Environment,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bot")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("release")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dev")?
                            }
                        };
                        _serde::__private::Ok(Config {
                            bot: __field0,
                            release: __field1,
                            dev: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["bot", "release", "dev"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Config",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Config>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct Bot {
        pub env: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Bot {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Bot",
                "env",
                &&self.env,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bot {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "env" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"env" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bot>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bot;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Bot",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Bot with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Bot { env: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("env"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("env")?
                            }
                        };
                        _serde::__private::Ok(Bot { env: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["env"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Bot",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bot>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct Environment {
        pub token: String,
        pub prefix: String,
        pub database_url: String,
        pub max_connections: u32,
        pub msg_cache: usize,
        pub dev_ids: Option<Vec<u64>>,
        pub whitelist_enabled: Option<bool>,
        pub whitelist: Option<Vec<u64>>,
        pub repository: Option<String>,
        pub github_token: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Environment {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "token",
                "prefix",
                "database_url",
                "max_connections",
                "msg_cache",
                "dev_ids",
                "whitelist_enabled",
                "whitelist",
                "repository",
                "github_token",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.token,
                &self.prefix,
                &self.database_url,
                &self.max_connections,
                &self.msg_cache,
                &self.dev_ids,
                &self.whitelist_enabled,
                &self.whitelist,
                &self.repository,
                &&self.github_token,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Environment",
                names,
                values,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Environment {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "token" => _serde::__private::Ok(__Field::__field0),
                            "prefix" => _serde::__private::Ok(__Field::__field1),
                            "database_url" => _serde::__private::Ok(__Field::__field2),
                            "max_connections" => _serde::__private::Ok(__Field::__field3),
                            "msg_cache" => _serde::__private::Ok(__Field::__field4),
                            "dev_ids" => _serde::__private::Ok(__Field::__field5),
                            "whitelist_enabled" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "whitelist" => _serde::__private::Ok(__Field::__field7),
                            "repository" => _serde::__private::Ok(__Field::__field8),
                            "github_token" => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"token" => _serde::__private::Ok(__Field::__field0),
                            b"prefix" => _serde::__private::Ok(__Field::__field1),
                            b"database_url" => _serde::__private::Ok(__Field::__field2),
                            b"max_connections" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"msg_cache" => _serde::__private::Ok(__Field::__field4),
                            b"dev_ids" => _serde::__private::Ok(__Field::__field5),
                            b"whitelist_enabled" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"whitelist" => _serde::__private::Ok(__Field::__field7),
                            b"repository" => _serde::__private::Ok(__Field::__field8),
                            b"github_token" => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Environment>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Environment;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Environment",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Environment with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Environment with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Environment with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Environment with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Environment with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Option<Vec<u64>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Environment with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Environment with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Option<Vec<u64>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct Environment with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct Environment with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct Environment with 10 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Environment {
                            token: __field0,
                            prefix: __field1,
                            database_url: __field2,
                            max_connections: __field3,
                            msg_cache: __field4,
                            dev_ids: __field5,
                            whitelist_enabled: __field6,
                            whitelist: __field7,
                            repository: __field8,
                            github_token: __field9,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Option<Vec<u64>>> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Option<Vec<u64>>> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("token"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("prefix"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "database_url",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "max_connections",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "msg_cache",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dev_ids",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<Vec<u64>>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "whitelist_enabled",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "whitelist",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<Vec<u64>>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "repository",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "github_token",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("prefix")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("database_url")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("max_connections")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("msg_cache")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dev_ids")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("whitelist_enabled")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("whitelist")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("repository")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("github_token")?
                            }
                        };
                        _serde::__private::Ok(Environment {
                            token: __field0,
                            prefix: __field1,
                            database_url: __field2,
                            max_connections: __field3,
                            msg_cache: __field4,
                            dev_ids: __field5,
                            whitelist_enabled: __field6,
                            whitelist: __field7,
                            repository: __field8,
                            github_token: __field9,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "token",
                    "prefix",
                    "database_url",
                    "max_connections",
                    "msg_cache",
                    "dev_ids",
                    "whitelist_enabled",
                    "whitelist",
                    "repository",
                    "github_token",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Environment",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Environment>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Environment {
        #[inline]
        fn default() -> Environment {
            Environment {
                token: ::core::default::Default::default(),
                prefix: ::core::default::Default::default(),
                database_url: ::core::default::Default::default(),
                max_connections: ::core::default::Default::default(),
                msg_cache: ::core::default::Default::default(),
                dev_ids: ::core::default::Default::default(),
                whitelist_enabled: ::core::default::Default::default(),
                whitelist: ::core::default::Default::default(),
                repository: ::core::default::Default::default(),
                github_token: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Environment {
        #[inline]
        fn clone(&self) -> Environment {
            Environment {
                token: ::core::clone::Clone::clone(&self.token),
                prefix: ::core::clone::Clone::clone(&self.prefix),
                database_url: ::core::clone::Clone::clone(&self.database_url),
                max_connections: ::core::clone::Clone::clone(&self.max_connections),
                msg_cache: ::core::clone::Clone::clone(&self.msg_cache),
                dev_ids: ::core::clone::Clone::clone(&self.dev_ids),
                whitelist_enabled: ::core::clone::Clone::clone(&self.whitelist_enabled),
                whitelist: ::core::clone::Clone::clone(&self.whitelist),
                repository: ::core::clone::Clone::clone(&self.repository),
                github_token: ::core::clone::Clone::clone(&self.github_token),
            }
        }
    }
}
mod constants {
    use serenity::all::Color;
    pub const BRAND_RED: Color = Color::from_rgb(227, 92, 104);
    pub const BRAND_BLUE: Color = Color::from_rgb(128, 199, 232);
    pub const SOFT_YELLOW: Color = Color::from_rgb(255, 243, 176);
}
mod database {
    use sqlx::query;
    use tracing::info;
    use crate::SQL;
    #[sqlx(type_name = "action_type", rename_all = "lowercase")]
    pub enum ActionType {
        Warn,
        Kick,
        Ban,
        Softban,
        Mute,
        Unban,
        Unmute,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ActionType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ActionType::Warn => "Warn",
                    ActionType::Kick => "Kick",
                    ActionType::Ban => "Ban",
                    ActionType::Softban => "Softban",
                    ActionType::Mute => "Mute",
                    ActionType::Unban => "Unban",
                    ActionType::Unmute => "Unmute",
                },
            )
        }
    }
    #[automatically_derived]
    impl<'q, DB: ::sqlx::Database> ::sqlx::encode::Encode<'q, DB> for ActionType
    where
        &'q ::std::primitive::str: ::sqlx::encode::Encode<'q, DB>,
    {
        fn encode_by_ref(
            &self,
            buf: &mut <DB as ::sqlx::database::Database>::ArgumentBuffer<'q>,
        ) -> ::std::result::Result<::sqlx::encode::IsNull, ::sqlx::error::BoxDynError> {
            let val = match self {
                ActionType::Warn => "warn",
                ActionType::Kick => "kick",
                ActionType::Ban => "ban",
                ActionType::Softban => "softban",
                ActionType::Mute => "mute",
                ActionType::Unban => "unban",
                ActionType::Unmute => "unmute",
            };
            <&::std::primitive::str as ::sqlx::encode::Encode<'q, DB>>::encode(val, buf)
        }
        fn size_hint(&self) -> ::std::primitive::usize {
            let val = match self {
                ActionType::Warn => "warn",
                ActionType::Kick => "kick",
                ActionType::Ban => "ban",
                ActionType::Softban => "softban",
                ActionType::Mute => "mute",
                ActionType::Unban => "unban",
                ActionType::Unmute => "unmute",
            };
            <&::std::primitive::str as ::sqlx::encode::Encode<'q, DB>>::size_hint(&val)
        }
    }
    #[automatically_derived]
    impl<'r> ::sqlx::decode::Decode<'r, ::sqlx::postgres::Postgres> for ActionType {
        fn decode(
            value: ::sqlx::postgres::PgValueRef<'r>,
        ) -> ::std::result::Result<
            Self,
            ::std::boxed::Box<
                dyn ::std::error::Error + 'static + ::std::marker::Send + ::std::marker::Sync,
            >,
        > {
            let value = <&'r ::std::primitive::str as ::sqlx::decode::Decode<
                'r,
                ::sqlx::postgres::Postgres,
            >>::decode(value)?;
            match value {
                "warn" => ::std::result::Result::Ok(ActionType::Warn),
                "kick" => ::std::result::Result::Ok(ActionType::Kick),
                "ban" => ::std::result::Result::Ok(ActionType::Ban),
                "softban" => ::std::result::Result::Ok(ActionType::Softban),
                "mute" => ::std::result::Result::Ok(ActionType::Mute),
                "unban" => ::std::result::Result::Ok(ActionType::Unban),
                "unmute" => ::std::result::Result::Ok(ActionType::Unmute),
                _ => {
                    Err(
                        ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "invalid value {0:?} for enum {1}",
                                        value,
                                        "ActionType",
                                    ),
                                )
                            })
                            .into(),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::sqlx::Type<::sqlx::Postgres> for ActionType {
        fn type_info() -> ::sqlx::postgres::PgTypeInfo {
            ::sqlx::postgres::PgTypeInfo::with_name("action_type")
        }
    }
    #[automatically_derived]
    impl ::sqlx::postgres::PgHasArrayType for ActionType {
        fn array_type_info() -> ::sqlx::postgres::PgTypeInfo {
            ::sqlx::postgres::PgTypeInfo::array_of("action_type")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ActionType {
        #[inline]
        fn clone(&self) -> ActionType {
            match self {
                ActionType::Warn => ActionType::Warn,
                ActionType::Kick => ActionType::Kick,
                ActionType::Ban => ActionType::Ban,
                ActionType::Softban => ActionType::Softban,
                ActionType::Mute => ActionType::Mute,
                ActionType::Unban => ActionType::Unban,
                ActionType::Unmute => ActionType::Unmute,
            }
        }
    }
    impl std::fmt::Display for ActionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ActionType::Warn => f.write_fmt(format_args!("warn")),
                ActionType::Kick => f.write_fmt(format_args!("kick")),
                ActionType::Ban => f.write_fmt(format_args!("ban")),
                ActionType::Softban => f.write_fmt(format_args!("softban")),
                ActionType::Mute => f.write_fmt(format_args!("mute")),
                ActionType::Unban => f.write_fmt(format_args!("unban")),
                ActionType::Unmute => f.write_fmt(format_args!("unmute")),
            }
        }
    }
    pub async fn run_migrations() {
        {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "event src\\database.rs:33",
                        "Ouroboros::database",
                        ::tracing::Level::INFO,
                        ::tracing_core::__macro_support::Option::Some(
                            "src\\database.rs",
                        ),
                        ::tracing_core::__macro_support::Option::Some(33u32),
                        ::tracing_core::__macro_support::Option::Some(
                            "Ouroboros::database",
                        ),
                        ::tracing_core::field::FieldSet::new(
                            &["message"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::EVENT,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let enabled = ::tracing::Level::INFO
                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::INFO
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    let interest = __CALLSITE.interest();
                    !interest.is_never()
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                };
            if enabled {
                (|value_set: ::tracing::field::ValueSet| {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Event::dispatch(meta, &value_set);
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &value_set,
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                })({
                    #[allow(unused_imports)]
                    use ::tracing::field::{debug, display, Value};
                    let mut iter = __CALLSITE.metadata().fields().iter();
                    __CALLSITE
                        .metadata()
                        .fields()
                        .value_set(
                            &[
                                (
                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                        .expect("FieldSet corrupted (this is a bug)"),
                                    ::tracing::__macro_support::Option::Some(
                                        &format_args!("Running database migrations") as &dyn Value,
                                    ),
                                ),
                            ],
                        )
                });
            } else {
                if match ::tracing::Level::INFO {
                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                    _ => ::tracing::log::Level::Trace,
                } <= ::tracing::log::STATIC_MAX_LEVEL
                {
                    if !::tracing::dispatcher::has_been_set() {
                        {
                            use ::tracing::log;
                            let level = match ::tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            };
                            if level <= log::max_level() {
                                let meta = __CALLSITE.metadata();
                                let log_meta = log::Metadata::builder()
                                    .level(level)
                                    .target(meta.target())
                                    .build();
                                let logger = log::logger();
                                if logger.enabled(&log_meta) {
                                    ::tracing::__macro_support::__tracing_log(
                                        meta,
                                        logger,
                                        log_meta,
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Running database migrations") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        },
                                    )
                                }
                            }
                        }
                    } else {
                        {}
                    }
                } else {
                    {}
                };
            }
        };
        create_action_type_201420250826().await;
        create_actions_223320250818().await;
        create_guild_settings_195120250826().await;
        add_log_bot_to_guild_settings_220420250829().await;
        add_log_mod_to_guild_settings_021020250918().await;
        remove_log_mod_and_change_channel_id_to_jsonb_150020250921().await;
        add_message_cache_store_133120250922().await;
        add_last_reapplied_at_to_actions_160120250923().await;
    }
    pub async fn create_actions_223320250818() {
        if let Err(err) = {
            {
                #[allow(clippy::all)]
                {
                    use ::sqlx::Arguments as _;
                    let query_args = ::core::result::Result::<
                        _,
                        ::sqlx::error::BoxDynError,
                    >::Ok(
                        <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                            '_,
                        >::default(),
                    );
                    ::sqlx::__query_with_result::<
                        sqlx::postgres::Postgres,
                        _,
                    >(
                        "\n        CREATE TABLE IF NOT EXISTS public.actions\n        (\n            guild_id bigint NOT NULL,\n            user_id bigint NOT NULL,\n            reason text COLLATE pg_catalog.\"default\" NOT NULL,\n            moderator_id bigint NOT NULL,\n            created_at timestamp without time zone NOT NULL DEFAULT now(),\n            updated_at timestamp without time zone,\n            id character varying(128) COLLATE pg_catalog.\"default\" NOT NULL,\n            type action_type NOT NULL DEFAULT 'warn'::action_type,\n            active boolean NOT NULL DEFAULT true,\n            expires_at timestamp without time zone,\n            CONSTRAINT warns_pkey PRIMARY KEY (id)\n        )\n        ",
                        query_args,
                    )
                }
            }
        }
            .execute(SQL.get().unwrap())
            .await
        {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Couldnt run database migration create_actions_223320250818; Err = {0:?}",
                        err,
                    ),
                );
            };
        }
    }
    pub async fn create_guild_settings_195120250826() {
        if let Err(err) = {
            {
                #[allow(clippy::all)]
                {
                    use ::sqlx::Arguments as _;
                    let query_args = ::core::result::Result::<
                        _,
                        ::sqlx::error::BoxDynError,
                    >::Ok(
                        <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                            '_,
                        >::default(),
                    );
                    ::sqlx::__query_with_result::<
                        sqlx::postgres::Postgres,
                        _,
                    >(
                        "\n        CREATE TABLE IF NOT EXISTS public.guild_settings\n        (\n            guild_id bigint NOT NULL PRIMARY KEY,\n            log_channel bigint\n        )\n        ",
                        query_args,
                    )
                }
            }
        }
            .execute(SQL.get().unwrap())
            .await
        {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Couldnt run database migration create_guild_settings_195120250826; Err = {0:?}",
                        err,
                    ),
                );
            };
        }
    }
    pub async fn create_action_type_201420250826() {
        if let Err(err) = {
            {
                #[allow(clippy::all)]
                {
                    use ::sqlx::Arguments as _;
                    let query_args = ::core::result::Result::<
                        _,
                        ::sqlx::error::BoxDynError,
                    >::Ok(
                        <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                            '_,
                        >::default(),
                    );
                    ::sqlx::__query_with_result::<
                        sqlx::postgres::Postgres,
                        _,
                    >(
                        "\n        DO $$\n        BEGIN\n            IF NOT EXISTS (\n                SELECT 1\n                FROM pg_type t\n                JOIN pg_namespace n ON n.oid = t.typnamespace\n                WHERE t.typname = 'action_type'\n                AND n.nspname = 'public'\n            ) THEN\n                CREATE TYPE public.action_type AS ENUM\n                    ('warn', 'ban', 'kick', 'softban', 'timeout', 'unban', 'mute', 'unmute');\n            END IF;\n        END$$;\n        ",
                        query_args,
                    )
                }
            }
        }
            .execute(SQL.get().unwrap())
            .await
        {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Couldnt run database migration create_guild_settings_195120250826; Err = {0:?}",
                        err,
                    ),
                );
            };
        }
    }
    pub async fn add_log_bot_to_guild_settings_220420250829() {
        if let Err(err) = {
            {
                #[allow(clippy::all)]
                {
                    use ::sqlx::Arguments as _;
                    let query_args = ::core::result::Result::<
                        _,
                        ::sqlx::error::BoxDynError,
                    >::Ok(
                        <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                            '_,
                        >::default(),
                    );
                    ::sqlx::__query_with_result::<
                        sqlx::postgres::Postgres,
                        _,
                    >(
                        "\n        ALTER TABLE public.guild_settings\n        ADD COLUMN IF NOT EXISTS log_bot BOOLEAN\n        ",
                        query_args,
                    )
                }
            }
        }
            .execute(SQL.get().unwrap())
            .await
        {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Couldnt run database migration add_log_bot_to_guild_settings_220420250829; Err = {0:?}",
                        err,
                    ),
                );
            };
        }
    }
    pub async fn add_log_mod_to_guild_settings_021020250918() {
        if let Err(err) = {
            {
                #[allow(clippy::all)]
                {
                    use ::sqlx::Arguments as _;
                    let query_args = ::core::result::Result::<
                        _,
                        ::sqlx::error::BoxDynError,
                    >::Ok(
                        <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                            '_,
                        >::default(),
                    );
                    ::sqlx::__query_with_result::<
                        sqlx::postgres::Postgres,
                        _,
                    >(
                        "\n        ALTER TABLE public.guild_settings\n        ADD COLUMN IF NOT EXISTS log_mod bigint\n        ",
                        query_args,
                    )
                }
            }
        }
            .execute(SQL.get().unwrap())
            .await
        {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Couldnt run database migration add_log_mod_to_guild_settings_021020250918; Err = {0:?}",
                        err,
                    ),
                );
            };
        }
    }
    pub async fn remove_log_mod_and_change_channel_id_to_jsonb_150020250921() {
        if let Err(err) = {
            {
                #[allow(clippy::all)]
                {
                    use ::sqlx::Arguments as _;
                    let query_args = ::core::result::Result::<
                        _,
                        ::sqlx::error::BoxDynError,
                    >::Ok(
                        <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                            '_,
                        >::default(),
                    );
                    ::sqlx::__query_with_result::<
                        sqlx::postgres::Postgres,
                        _,
                    >(
                        "\n        ALTER TABLE public.guild_settings\n        DROP COLUMN IF EXISTS log_mod,\n        DROP COLUMN IF EXISTS log_channel,\n        ADD COLUMN IF NOT EXISTS log_channel_ids jsonb\n        ",
                        query_args,
                    )
                }
            }
        }
            .execute(SQL.get().unwrap())
            .await
        {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Couldnt run database migration remove_log_mod_and_change_channel_id_to_jsonb_150020250921; Err = {0:?}",
                        err,
                    ),
                );
            };
        }
    }
    pub async fn add_message_cache_store_133120250922() {
        if let Err(err) = {
            {
                #[allow(clippy::all)]
                {
                    use ::sqlx::Arguments as _;
                    let query_args = ::core::result::Result::<
                        _,
                        ::sqlx::error::BoxDynError,
                    >::Ok(
                        <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                            '_,
                        >::default(),
                    );
                    ::sqlx::__query_with_result::<
                        sqlx::postgres::Postgres,
                        _,
                    >(
                        "\n        CREATE TABLE IF NOT EXISTS public.message_cache_store\n        (\n            channel_id bigint NOT NULL,\n            message_count integer NOT NULL DEFAULT 0,\n            previous_action smallint NOT NULL DEFAULT 0 CHECK (previous_action BETWEEN -1 AND 1),\n            PRIMARY KEY (channel_id)\n        );\n        ",
                        query_args,
                    )
                }
            }
        }
            .execute(SQL.get().unwrap())
            .await
        {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Couldnt run database migration add_message_cache_store_133120250922; Err = {0:?}",
                        err,
                    ),
                );
            };
        }
    }
    pub async fn add_last_reapplied_at_to_actions_160120250923() {
        if let Err(err) = {
            {
                #[allow(clippy::all)]
                {
                    use ::sqlx::Arguments as _;
                    let query_args = ::core::result::Result::<
                        _,
                        ::sqlx::error::BoxDynError,
                    >::Ok(
                        <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                            '_,
                        >::default(),
                    );
                    ::sqlx::__query_with_result::<
                        sqlx::postgres::Postgres,
                        _,
                    >(
                        "\n        ALTER TABLE public.actions\n        ADD COLUMN IF NOT EXISTS last_reapplied_at timestamp with time zone;\n        ",
                        query_args,
                    )
                }
            }
        }
            .execute(SQL.get().unwrap())
            .await
        {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Couldnt run database migration add_last_reapplied_at_to_actions_160120250923; Err = {0:?}",
                        err,
                    ),
                );
            };
        }
    }
}
mod event_handler {
    use std::{collections::HashMap, sync::Arc, time::Duration};
    use serenity::{
        all::{
            ChannelId, Context, CreateAllowedMentions, CreateEmbed, CreateMessage,
            EventHandler, Guild, GuildId, GuildMemberUpdateEvent, Member, Message,
            MessageId, MessageUpdateEvent, User,
        },
        async_trait,
    };
    use tokio::{
        sync::{Mutex, MutexGuard},
        time::sleep,
    };
    use tracing::{info, warn};
    use crate::{
        SQL,
        commands::{
            About, Ban, Cache, ColonThree, Command, Config, DefineLog,
            Duration as DurationCommand, ExtractId, Kick, Log, MsgDbg, Mute, Ping, Purge,
            Reason, Say, Softban, Stats, Unban, Unmute, Update, Warn,
        },
        constants::BRAND_RED, event_handler::message_cache::MessageCache, lexer::Token,
    };
    pub struct CommandError {
        pub title: String,
        pub hint: Option<String>,
        pub arg: Option<Token>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CommandError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "CommandError",
                "title",
                &self.title,
                "hint",
                &self.hint,
                "arg",
                &&self.arg,
            )
        }
    }
    impl CommandError {
        pub fn arg_not_found(arg_type: &str, name: Option<&str>) -> Self {
            let name = name
                .map(|n| ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!(": {0}", n))
                }))
                .unwrap_or_default();
            Self {
                arg: None,
                title: ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!("Missing argument, expected {0}{1}", arg_type, name),
                    )
                }),
                hint: Some(String::from("for more information run !help (command)")),
            }
        }
    }
    impl std::fmt::Display for CommandError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(
                format_args!(
                    "Command Error: {0}; hint: {1}",
                    self.title,
                    self.hint.clone().unwrap_or(String::from("(None)")),
                ),
            )
        }
    }
    impl std::error::Error for CommandError {}
    pub struct MissingArgumentError(pub String);
    #[automatically_derived]
    impl ::core::fmt::Debug for MissingArgumentError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "MissingArgumentError",
                &&self.0,
            )
        }
    }
    impl std::fmt::Display for MissingArgumentError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(format_args!("Missing Argument Error: {0}", self.0))
        }
    }
    impl std::error::Error for MissingArgumentError {}
    struct MessageDeleteEvent {
        channel_id: ChannelId,
        message_id: MessageId,
    }
    mod help_cmd {
        use std::{sync::Arc, time::Duration};
        use serenity::all::{
            ButtonStyle, Context, CreateActionRow, CreateAllowedMentions, CreateButton,
            CreateEmbed, CreateEmbedFooter, CreateInteractionResponse,
            CreateInteractionResponseMessage, CreateMessage, EditMessage, Message,
        };
        use tracing::warn;
        use crate::{
            commands::{Command, CommandCategory},
            constants::BRAND_BLUE, event_handler::{CommandError, Handler},
            lexer::Token, utils::is_developer,
        };
        impl Handler {
            pub async fn help_run(
                &self,
                ctx: Context,
                msg: Message,
                args: Vec<Token>,
            ) -> Result<(), CommandError> {
                let mut args_iter = args.into_iter();
                if let Some(name_tok) = args_iter.next() {
                    let Some(cmd) = self
                        .commands
                        .iter()
                        .find(|c| c.get_name() == name_tok.raw.to_lowercase()) else {
                        return Err(CommandError {
                            title: String::from("Command not found"),
                            hint: Some(
                                String::from(
                                    "double check if the command name provided is a valid command.",
                                ),
                            ),
                            arg: Some(name_tok),
                        });
                    };
                    let cmd_perms = cmd.get_permissions();
                    let perms = if cmd_perms.one_of.is_empty()
                        && cmd_perms.required.is_empty()
                    {
                        ""
                    } else {
                        let mut result = String::new();
                        if !cmd_perms.required.is_empty() {
                            let string = cmd_perms
                                .required
                                .iter()
                                .map(|p| {
                                    let names = p
                                        .get_permission_names()
                                        .into_iter()
                                        .map(|n| n.to_uppercase().replace(" ", "_"))
                                        .collect::<Vec<_>>();
                                    names.join(" && ")
                                })
                                .collect::<Vec<_>>()
                                .join(" && ");
                            result.push_str(&string);
                        }
                        if !cmd_perms.one_of.is_empty() {
                            let string = cmd_perms
                                .one_of
                                .iter()
                                .map(|p| {
                                    let names = p
                                        .get_permission_names()
                                        .into_iter()
                                        .map(|n| n.to_uppercase().replace(" ", "_"))
                                        .collect::<Vec<_>>();
                                    names.join(" || ")
                                })
                                .collect::<Vec<_>>()
                                .join(" || ");
                            if !result.is_empty() {
                                result
                                    .push_str(
                                        &::alloc::__export::must_use({
                                            ::alloc::fmt::format(format_args!(" && ({0})", string))
                                        }),
                                    );
                            } else {
                                result.push_str(&string);
                            }
                        }
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("\nRequired Permissions:\n`{0}`", result),
                            )
                        })
                    };
                    let syntax = {
                        let command_syntax = cmd.get_syntax();
                        let mut def = ::alloc::vec::Vec::new();
                        let mut example = ::alloc::vec::Vec::new();
                        for syn in command_syntax {
                            def.push(syn.get_def());
                            example.push(syn.get_example());
                        }
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Syntax:\n```\n{0}{1} {2}\n```\nExample:\n```{0}{1} {3}```",
                                    self.prefix,
                                    cmd.get_name(),
                                    def.join(" "),
                                    example.join(" "),
                                ),
                            )
                        })
                    };
                    let reply = CreateMessage::new()
                        .add_embed(
                            CreateEmbed::new()
                                .description(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "**{0}**\n{1}\n\n{2}{3}",
                                                cmd.get_name().to_uppercase(),
                                                cmd.get_full(),
                                                syntax,
                                                perms,
                                            ),
                                        )
                                    }),
                                )
                                .color(BRAND_BLUE),
                        )
                        .reference_message(&msg)
                        .allowed_mentions(
                            CreateAllowedMentions::new().replied_user(false),
                        );
                    if let Err(e) = msg.channel_id.send_message(&ctx.http, reply).await {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src\\event_handler\\help_cmd.rs:126",
                                        "Ouroboros::event_handler::help_cmd",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "src\\event_handler\\help_cmd.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(126u32),
                                        ::tracing_core::__macro_support::Option::Some(
                                            "Ouroboros::event_handler::help_cmd",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &value_set,
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!("Could not send message; err = {0:?}", e)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                                            __CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                            ::tracing::__macro_support::Option::Some(
                                                                                &format_args!("Could not send message; err = {0:?}", e)
                                                                                    as &dyn Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            }
                        }
                    }
                    return Ok(());
                }
                let mut command_pages: Vec<(CommandCategory, Vec<&Arc<dyn Command>>)> = ::alloc::vec::Vec::new();
                let mut current_page: usize = 0;
                self.commands
                    .iter()
                    .for_each(|c| {
                        if c.get_category() == CommandCategory::Developer
                            && !is_developer(&msg.author)
                        {
                            return;
                        }
                        if let Some((_, vec)) = command_pages
                            .iter_mut()
                            .find(|(k, _)| k == &c.get_category())
                        {
                            vec.push(c);
                        } else {
                            command_pages
                                .push((
                                    c.get_category(),
                                    <[_]>::into_vec(::alloc::boxed::box_new([c])),
                                ));
                        }
                    });
                let get_page_body = |page: usize| {
                    let Some(page) = command_pages.get(page) else {
                        return String::new();
                    };
                    let mut body = ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!("**{0}**\n", page.0.to_string().to_uppercase()),
                        )
                    });
                    page.1
                        .iter()
                        .for_each(|c| {
                            if !c.get_short().is_empty() {
                                body.push_str(
                                    ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("`{0}` - {1}\n", c.get_name(), c.get_short()),
                                            )
                                        })
                                        .as_str(),
                                );
                            }
                        });
                    body
                };
                let mut page_buttons = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        CreateButton::new("first")
                            .style(ButtonStyle::Secondary)
                            .label("<<")
                            .disabled(true),
                        CreateButton::new("prev")
                            .style(ButtonStyle::Secondary)
                            .label("<")
                            .disabled(true),
                        CreateButton::new("page")
                            .style(ButtonStyle::Secondary)
                            .label(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("1/{0}", command_pages.len()),
                                    )
                                }),
                            )
                            .disabled(true),
                        CreateButton::new("next")
                            .style(ButtonStyle::Secondary)
                            .label(">"),
                        CreateButton::new("last")
                            .style(ButtonStyle::Secondary)
                            .label(">>"),
                    ]),
                );
                let get_updated_buttons = |
                    page: usize,
                    disabled: [bool; 4],
                | -> Vec<CreateButton> {
                    let disabled: [bool; 5] = [
                        disabled[0],
                        disabled[1],
                        true,
                        disabled[2],
                        disabled[3],
                    ];
                    let mut new = page_buttons.clone();
                    new = new
                        .into_iter()
                        .enumerate()
                        .map(|(i, mut d)| {
                            if i == 2 {
                                d = d
                                    .label(
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("{0}/{1}", page + 1, command_pages.len()),
                                            )
                                        }),
                                    );
                            }
                            d.disabled(disabled[i])
                        })
                        .collect();
                    new
                };
                let reply = CreateMessage::new()
                    .add_embed(
                        CreateEmbed::new()
                            .description(get_page_body(current_page))
                            .footer(
                                CreateEmbedFooter::new(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "View additional information using {0}help <command: String>",
                                                self.prefix,
                                            ),
                                        )
                                    }),
                                ),
                            )
                            .color(BRAND_BLUE),
                    )
                    .components(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                CreateActionRow::Buttons(page_buttons.clone()),
                            ]),
                        ),
                    )
                    .reference_message(&msg)
                    .allowed_mentions(CreateAllowedMentions::new().replied_user(false));
                let mut new_msg = match msg
                    .channel_id
                    .send_message(&ctx.http, reply)
                    .await
                {
                    Ok(m) => m,
                    Err(e) => {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src\\event_handler\\help_cmd.rs:223",
                                        "Ouroboros::event_handler::help_cmd",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "src\\event_handler\\help_cmd.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(223u32),
                                        ::tracing_core::__macro_support::Option::Some(
                                            "Ouroboros::event_handler::help_cmd",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &value_set,
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!("Could not send message; err = {0:?}", e)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                                            __CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                            ::tracing::__macro_support::Option::Some(
                                                                                &format_args!("Could not send message; err = {0:?}", e)
                                                                                    as &dyn Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            }
                        };
                        return Ok(());
                    }
                };
                loop {
                    let interaction = match new_msg
                        .await_component_interaction(&ctx.shard)
                        .timeout(Duration::from_secs(60 * 5))
                        .await
                    {
                        Some(i) => i,
                        None => {
                            page_buttons = page_buttons
                                .into_iter()
                                .map(|b| b.disabled(true))
                                .collect();
                            let _ = new_msg
                                .edit(
                                    &ctx.http,
                                    EditMessage::new()
                                        .components(
                                            <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    CreateActionRow::Buttons(page_buttons),
                                                ]),
                                            ),
                                        ),
                                )
                                .await;
                            return Ok(());
                        }
                    };
                    if interaction.user.id != msg.author.id {
                        if let Err(e) = interaction
                            .create_response(
                                &ctx.http,
                                CreateInteractionResponse::Message(
                                    CreateInteractionResponseMessage::new()
                                        .content("You are not the author of the original message!")
                                        .ephemeral(true),
                                ),
                            )
                            .await
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src\\event_handler\\help_cmd.rs:260",
                                            "Ouroboros::event_handler::help_cmd",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "src\\event_handler\\help_cmd.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(260u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "Ouroboros::event_handler::help_cmd",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        if match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        } <= ::tracing::log::STATIC_MAX_LEVEL
                                        {
                                            if !::tracing::dispatcher::has_been_set() {
                                                {
                                                    use ::tracing::log;
                                                    let level = match ::tracing::Level::WARN {
                                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                        _ => ::tracing::log::Level::Trace,
                                                    };
                                                    if level <= log::max_level() {
                                                        let meta = __CALLSITE.metadata();
                                                        let log_meta = log::Metadata::builder()
                                                            .level(level)
                                                            .target(meta.target())
                                                            .build();
                                                        let logger = log::logger();
                                                        if logger.enabled(&log_meta) {
                                                            ::tracing::__macro_support::__tracing_log(
                                                                meta,
                                                                logger,
                                                                log_meta,
                                                                &value_set,
                                                            )
                                                        }
                                                    }
                                                }
                                            } else {
                                                {}
                                            }
                                        } else {
                                            {}
                                        };
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Could not send message; err = {0:?}", e)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &{
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::tracing::__macro_support::Option::Some(
                                                                                    &format_args!("Could not send message; err = {0:?}", e)
                                                                                        as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            },
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                }
                            };
                        }
                        continue;
                    }
                    match interaction.data.custom_id.as_str() {
                        "first" => {
                            current_page = 0;
                            let response = get_page_body(current_page);
                            if interaction
                                .create_response(
                                    &ctx.http,
                                    CreateInteractionResponse::UpdateMessage(
                                        CreateInteractionResponseMessage::default()
                                            .add_embed(
                                                CreateEmbed::new()
                                                    .description(response)
                                                    .footer(
                                                        CreateEmbedFooter::new(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!(
                                                                        "View additional information using {0}help <command: String>",
                                                                        self.prefix,
                                                                    ),
                                                                )
                                                            }),
                                                        ),
                                                    )
                                                    .color(BRAND_BLUE),
                                            )
                                            .components(
                                                <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        CreateActionRow::Buttons(
                                                            get_updated_buttons(
                                                                current_page,
                                                                [true, true, false, false],
                                                            ),
                                                        ),
                                                    ]),
                                                ),
                                            ),
                                    ),
                                )
                                .await
                                .is_err()
                            {
                                return Ok(());
                            }
                        }
                        "prev" => {
                            current_page -= 1;
                            let response = get_page_body(current_page);
                            let none_prev = if current_page == 0 {
                                true
                            } else {
                                command_pages.get(current_page - 1).is_none()
                            };
                            if interaction
                                .create_response(
                                    &ctx.http,
                                    CreateInteractionResponse::UpdateMessage(
                                        CreateInteractionResponseMessage::default()
                                            .add_embed(
                                                CreateEmbed::new()
                                                    .description(response)
                                                    .footer(
                                                        CreateEmbedFooter::new(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!(
                                                                        "View additional information using {0}help <command: String>",
                                                                        self.prefix,
                                                                    ),
                                                                )
                                                            }),
                                                        ),
                                                    )
                                                    .color(BRAND_BLUE),
                                            )
                                            .components(
                                                <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        CreateActionRow::Buttons(
                                                            get_updated_buttons(
                                                                current_page,
                                                                [none_prev, none_prev, false, false],
                                                            ),
                                                        ),
                                                    ]),
                                                ),
                                            ),
                                    ),
                                )
                                .await
                                .is_err()
                            {
                                return Ok(());
                            }
                        }
                        "next" => {
                            current_page += 1;
                            let response = get_page_body(current_page);
                            let none_next = command_pages
                                .get(current_page + 1)
                                .is_none();
                            if interaction
                                .create_response(
                                    &ctx.http,
                                    CreateInteractionResponse::UpdateMessage(
                                        CreateInteractionResponseMessage::default()
                                            .add_embed(
                                                CreateEmbed::new()
                                                    .description(response)
                                                    .footer(
                                                        CreateEmbedFooter::new(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!(
                                                                        "View additional information using {0}help <command: String>",
                                                                        self.prefix,
                                                                    ),
                                                                )
                                                            }),
                                                        ),
                                                    )
                                                    .color(BRAND_BLUE),
                                            )
                                            .components(
                                                <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        CreateActionRow::Buttons(
                                                            get_updated_buttons(
                                                                current_page,
                                                                [false, false, none_next, none_next],
                                                            ),
                                                        ),
                                                    ]),
                                                ),
                                            ),
                                    ),
                                )
                                .await
                                .is_err()
                            {
                                return Ok(());
                            }
                        }
                        "last" => {
                            current_page = command_pages.len() - 1;
                            let response = get_page_body(current_page);
                            if interaction
                                .create_response(
                                    &ctx.http,
                                    CreateInteractionResponse::UpdateMessage(
                                        CreateInteractionResponseMessage::default()
                                            .add_embed(
                                                CreateEmbed::new()
                                                    .description(response)
                                                    .footer(
                                                        CreateEmbedFooter::new(
                                                            ::alloc::__export::must_use({
                                                                ::alloc::fmt::format(
                                                                    format_args!(
                                                                        "View additional information using {0}help <command: String>",
                                                                        self.prefix,
                                                                    ),
                                                                )
                                                            }),
                                                        ),
                                                    )
                                                    .color(BRAND_BLUE),
                                            )
                                            .components(
                                                <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        CreateActionRow::Buttons(
                                                            get_updated_buttons(
                                                                current_page,
                                                                [false, false, true, true],
                                                            ),
                                                        ),
                                                    ]),
                                                ),
                                            ),
                                    ),
                                )
                                .await
                                .is_err()
                            {
                                return Ok(());
                            }
                        }
                        _ => {}
                    };
                }
            }
        }
    }
    mod message_cache {
        use std::collections::{HashMap, VecDeque};
        use serenity::all::Message;
        pub struct MessageCache {
            sizes: HashMap<u64, usize>,
            messages: HashMap<u64, MessageQueue>,
            inserts: HashMap<u64, usize>,
        }
        impl MessageCache {
            pub fn new() -> Self {
                Self {
                    sizes: HashMap::new(),
                    messages: HashMap::new(),
                    inserts: HashMap::new(),
                }
            }
            pub fn assign_count(&mut self, channel: u64, count: usize) {
                self.sizes.insert(channel, count);
            }
            pub fn clear_inserts(&mut self) {
                self.inserts = self
                    .inserts
                    .clone()
                    .into_keys()
                    .map(|i| (i, 0_usize))
                    .collect::<HashMap<_, _>>();
            }
            pub fn store_message(&mut self, channel: u64, message: Message) {
                *self.inserts.entry(channel).or_default() += 1;
                let queue_size = *self.sizes.entry(channel).or_insert(100);
                if queue_size == 0 {
                    return;
                }
                let queue = self.messages.entry(channel).or_default();
                queue.insert(message);
                if queue.len() > queue_size {
                    queue.pop();
                }
            }
            pub fn get_message(
                &mut self,
                channel: u64,
                message: u64,
            ) -> Option<&Message> {
                let queue = self.messages.entry(channel).or_default();
                queue.get(message)
            }
            pub fn get_inserts(&self) -> HashMap<u64, usize> {
                self.inserts.clone()
            }
            pub fn get_sizes(&self) -> HashMap<u64, usize> {
                self.sizes.clone()
            }
            pub fn get_channel_len(&self, channel: u64) -> usize {
                self.messages.get(&channel).map(|c| c.len()).unwrap_or_default()
            }
        }
        struct MessageQueue {
            items: VecDeque<Message>,
            index: HashMap<u64, usize>,
        }
        #[automatically_derived]
        impl ::core::default::Default for MessageQueue {
            #[inline]
            fn default() -> MessageQueue {
                MessageQueue {
                    items: ::core::default::Default::default(),
                    index: ::core::default::Default::default(),
                }
            }
        }
        impl MessageQueue {
            fn insert(&mut self, msg: Message) {
                let id = msg.id.get();
                self.items.push_front(msg);
                self.index.insert(id, self.items.len() - 1);
            }
            fn len(&self) -> usize {
                self.items.len()
            }
            fn get(&self, id: u64) -> Option<&Message> {
                self.index.get(&id).map(|&i| &self.items[i])
            }
            fn pop(&mut self) {
                let msg = self.items.pop_back();
                if let Some(msg) = msg {
                    self.index.remove(&msg.id.get());
                }
            }
        }
    }
    mod guild_create {
        use serenity::all::{Context, Guild};
        use sqlx::query;
        use tracing::error;
        use crate::{BOT_CONFIG, GUILD_SETTINGS, SQL, event_handler::Handler};
        pub async fn guild_create(
            _handler: &Handler,
            ctx: Context,
            guild: Guild,
            is_new: Option<bool>,
        ) {
            if let Some(new) = is_new && new {
                let cfg = BOT_CONFIG.get().unwrap();
                if cfg.whitelist_enabled.is_none_or(|b| !b) {
                    return;
                }
                if cfg
                    .whitelist
                    .as_ref()
                    .is_none_or(|ids| !ids.contains(&guild.id.get()))
                    && let Err(err) = ctx.http.leave_guild(guild.id).await
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\event_handler\\guild_create.rs:23",
                                    "Ouroboros::event_handler::guild_create",
                                    ::tracing::Level::ERROR,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\event_handler\\guild_create.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(23u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::event_handler::guild_create",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::ERROR {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Could not leave non-whitelisted guild! err = {1:?}; id = {0}",
                                                        guild.id.get(),
                                                        err,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "Could not leave non-whitelisted guild! err = {1:?}; id = {0}",
                                                                                guild.id.get(),
                                                                                err,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                }
                if let Err(err) = {
                    {
                        #[allow(clippy::all)]
                        {
                            use ::sqlx::Arguments as _;
                            let arg0 = &(guild.id.get() as i64);
                            let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                '_,
                            >::default();
                            query_args
                                .reserve(
                                    1usize,
                                    0
                                        + ::sqlx::encode::Encode::<
                                            sqlx::postgres::Postgres,
                                        >::size_hint(arg0),
                                );
                            let query_args = ::core::result::Result::<
                                _,
                                ::sqlx::error::BoxDynError,
                            >::Ok(query_args)
                                .and_then(move |mut query_args| {
                                    query_args.add(arg0).map(move |()| query_args)
                                });
                            ::sqlx::__query_with_result::<
                                sqlx::postgres::Postgres,
                                _,
                            >("INSERT INTO actions (guild_id) values ($1);", query_args)
                        }
                    }
                }
                    .execute(SQL.get().unwrap())
                    .await
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\event_handler\\guild_create.rs:36",
                                    "Ouroboros::event_handler::guild_create",
                                    ::tracing::Level::ERROR,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\event_handler\\guild_create.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(36u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::event_handler::guild_create",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::ERROR {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Got error during guild join settings set; guild = {0} err = {1}",
                                                        guild.id.get(),
                                                        err,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "Got error during guild join settings set; guild = {0} err = {1}",
                                                                                guild.id.get(),
                                                                                err,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                }
                {
                    let mut global = GUILD_SETTINGS.get().unwrap().lock().await;
                    global.invalidate();
                }
            }
        }
    }
    mod guild_member_removal {
        use chrono::Utc;
        use serenity::all::{
            Context, CreateEmbed, CreateMessage, GuildId, Member,
            MemberAction::{BanAdd, Kick},
            Mentionable, User, UserId, audit_log::Action,
        };
        use tracing::warn;
        use crate::{
            GUILD_SETTINGS, constants::BRAND_BLUE, event_handler::Handler,
            utils::{LogType, guild_log, snowflake_to_timestamp},
        };
        enum LeaveType {
            User,
            Kick(UserId, String),
            Ban(UserId, String),
        }
        pub async fn guild_member_removal(
            _handler: &Handler,
            ctx: Context,
            guild_id: GuildId,
            user: User,
            _member_data_if_available: Option<Member>,
        ) {
            {
                let mut settings = GUILD_SETTINGS.get().unwrap().lock().await;
                if let Ok(guild_settings) = settings.get(guild_id.get()).await {
                    if user.bot && guild_settings.log.log_bots.is_none_or(|b| !b) {
                        return;
                    }
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\event_handler\\guild_member_removal.rs:38",
                                    "Ouroboros::event_handler::guild_member_removal",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\event_handler\\guild_member_removal.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(38u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::event_handler::guild_member_removal",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Found guild with no cached settings; Id = {0}",
                                                        guild_id,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "Found guild with no cached settings; Id = {0}",
                                                                                guild_id,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                };
            }
            let audit_log = guild_id
                .audit_logs(&ctx.http, None, None, None, Some(5))
                .await
                .ok();
            let mut leave_type = LeaveType::User;
            if let Some(logs) = audit_log {
                for entry in logs.entries {
                    let entry_time = snowflake_to_timestamp(entry.id.get());
                    if (Utc::now() - entry_time).num_seconds().abs() > 5 {
                        continue;
                    }
                    if let Some(target_id) = entry.target_id
                        && target_id.get() != user.id.get()
                    {
                        continue;
                    }
                    match entry.action {
                        Action::Member(Kick) => {
                            if let Some(target) = entry.target_id
                                && user.id.get() == target.get()
                            {
                                leave_type = LeaveType::Kick(
                                    entry.user_id,
                                    entry.reason.unwrap_or(String::from("No reason provided")),
                                );
                            }
                            break;
                        }
                        Action::Member(BanAdd) => {
                            if let Some(target) = entry.target_id
                                && user.id.get() == target.get()
                            {
                                leave_type = LeaveType::Ban(
                                    entry.user_id,
                                    entry.reason.unwrap_or(String::from("No reason provided")),
                                );
                            }
                            break;
                        }
                        _ => {}
                    }
                }
            }
            match leave_type {
                LeaveType::Kick(actor, reason) => {
                    if actor.get() == ctx.cache.current_user().id.get() {
                        return;
                    }
                    guild_log(
                            &ctx.http,
                            LogType::MemberKick,
                            guild_id,
                            CreateMessage::new()
                                .add_embed(
                                    CreateEmbed::new()
                                        .description(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!(
                                                        "**MEMBER KICKED**\n-# Actor: {0} `{1}` | Target: {2} `{3}`\n```\n{4}\n```",
                                                        actor.mention(),
                                                        actor.get(),
                                                        user.mention(),
                                                        user.id.get(),
                                                        reason,
                                                    ),
                                                )
                                            }),
                                        )
                                        .color(BRAND_BLUE),
                                ),
                        )
                        .await;
                }
                LeaveType::Ban(actor, reason) => {
                    if actor.get() == ctx.cache.current_user().id.get() {
                        return;
                    }
                    guild_log(
                            &ctx.http,
                            LogType::MemberBan,
                            guild_id,
                            CreateMessage::new()
                                .add_embed(
                                    CreateEmbed::new()
                                        .description(
                                            ::alloc::__export::must_use({
                                                ::alloc::fmt::format(
                                                    format_args!(
                                                        "**MEMBER BANNED**\n-# Actor: {0} `{1}` | Target: {2} `{3}`\n```\n{4}\n```",
                                                        actor.mention(),
                                                        actor.get(),
                                                        user.mention(),
                                                        user.id.get(),
                                                        reason,
                                                    ),
                                                )
                                            }),
                                        )
                                        .color(BRAND_BLUE),
                                ),
                        )
                        .await;
                }
                _ => {}
            }
        }
    }
    mod guild_member_update {
        use std::io::Cursor;
        use chrono::Utc;
        use image::{DynamicImage, GenericImage, imageops::FilterType};
        use reqwest::Client;
        use serenity::all::{
            Change, Context, CreateAttachment, CreateEmbed, CreateEmbedAuthor,
            CreateMessage, GuildMemberUpdateEvent, Member, MemberAction,
            audit_log::Action,
        };
        use tracing::warn;
        use crate::{
            GUILD_SETTINGS, constants::BRAND_BLUE, event_handler::Handler,
            utils::{LogType, guild_log, snowflake_to_timestamp},
        };
        pub async fn guild_member_update(
            _handler: &Handler,
            ctx: Context,
            old_if_available: Option<Member>,
            new: Option<Member>,
            event: GuildMemberUpdateEvent,
        ) {
            {
                let mut settings = GUILD_SETTINGS.get().unwrap().lock().await;
                let Ok(guild_settings) = settings.get(event.guild_id.get()).await else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\event_handler\\guild_member_update.rs:29",
                                    "Ouroboros::event_handler::guild_member_update",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\event_handler\\guild_member_update.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(29u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::event_handler::guild_member_update",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Found guild with no cached settings; Id = {0}",
                                                        event.guild_id.get(),
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "Found guild with no cached settings; Id = {0}",
                                                                                event.guild_id.get(),
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return;
                };
                if event.user.bot && guild_settings.log.log_bots.is_none_or(|b| !b) {
                    return;
                }
            }
            let audit_log = event
                .guild_id
                .audit_logs(
                    &ctx.http,
                    Some(Action::Member(MemberAction::Update)),
                    None,
                    None,
                    Some(10),
                )
                .await
                .ok();
            let mut moderator_id: Option<u64> = None;
            let mut reason: Option<String> = None;
            let mut old_nick: Option<Option<String>> = old_if_available
                .clone()
                .map(|o| o.nick);
            if let Some(logs) = audit_log {
                'o: for entry in logs.entries {
                    for change in entry.changes.unwrap_or(Vec::new()) {
                        let entry_time = snowflake_to_timestamp(entry.id.get());
                        if let Change::Nick { old, new } = change
                            && event.user.id.get() == entry.user_id.get()
                            && new == event.nick
                            && (Utc::now() - entry_time).num_seconds().abs() <= 300
                        {
                            if old_if_available
                                .clone()
                                .is_some_and(|old_user| {
                                    old.clone()
                                        .is_some_and(|old_nick| old_user.display_name() == old_nick)
                                })
                            {
                                continue;
                            }
                            moderator_id = Some(entry.user_id.get());
                            reason = entry.reason.clone();
                            if Some(old.clone()) != old_nick {
                                old_nick = Some(old);
                            }
                            break 'o;
                        }
                    }
                }
            }
            let name = if let Some(old) = old_nick {
                if old == event.nick {
                    String::new()
                } else {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "\nName:\n`{0}` -> `{1}`",
                                old.unwrap_or(String::from("(none)")),
                                event.nick.unwrap_or(String::from("(none)")),
                            ),
                        )
                    })
                }
            } else {
                String::new()
            };
            let avatar = if let Some(old) = old_if_available && let Some(new) = new {
                if old.avatar.or(old.user.avatar) == new.avatar.or(new.user.avatar) {
                    (String::new(), None)
                } else {
                    let client = Client::new();
                    if let (Some(old_image), Some(new_image)) = (
                        get_member_avatar_image(&client, old).await,
                        get_member_avatar_image(&client, new).await,
                    ) {
                        let target_height = old_image.height();
                        let old_image = old_image
                            .resize(
                                old_image.width() * target_height / old_image.height(),
                                target_height,
                                FilterType::Lanczos3,
                            );
                        let new_image = new_image
                            .resize(
                                new_image.width() * target_height / new_image.height(),
                                target_height,
                                FilterType::Lanczos3,
                            );
                        let total_width = target_height * 2;
                        let mut output = DynamicImage::new_rgba8(
                            total_width,
                            target_height,
                        );
                        output.copy_from(&old_image, 0, 0).unwrap();
                        output.copy_from(&new_image, new_image.width(), 0).unwrap();
                        let mut buff = Vec::new();
                        if output
                            .write_to(
                                &mut Cursor::new(&mut buff),
                                image::ImageFormat::WebP,
                            )
                            .is_err()
                        {
                            (String::new(), None)
                        } else {
                            (String::from("\nAvatar:\n"), Some(buff))
                        }
                    } else {
                        (String::new(), None)
                    }
                }
            } else {
                (String::new(), None)
            };
            if name.is_empty() && avatar.0.is_empty() {
                return;
            }
            let moderator = if let Some(id) = moderator_id {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!(" | Actor: <@{0}>", id))
                })
            } else {
                String::new()
            };
            let reason = if let Some(reason) = reason {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("\nReason:\n```{0} ```", reason))
                })
            } else {
                String::new()
            };
            let description = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "**MEMBER UPDATE**\n-# <@{0}>{1}{2}{3}{4}",
                        event.user.id,
                        moderator,
                        name,
                        reason,
                        avatar.0,
                    ),
                )
            });
            let mut embed = CreateEmbed::new()
                .color(BRAND_BLUE)
                .description(description)
                .author(
                    CreateEmbedAuthor::new(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0}: {1}",
                                        event.user.name,
                                        event.user.id.get(),
                                    ),
                                )
                            }),
                        )
                        .icon_url(
                            event
                                .user
                                .avatar_url()
                                .unwrap_or(event.user.default_avatar_url()),
                        ),
                );
            if !avatar.0.is_empty() {
                embed = embed.image("attachment://avatar.webp");
            }
            let mut msg = CreateMessage::new().add_embed(embed);
            if !avatar.0.is_empty() {
                msg = msg
                    .add_file(CreateAttachment::bytes(avatar.1.unwrap(), "avatar.webp"));
            }
            guild_log(&ctx.http, LogType::MemberUpdate, event.guild_id, msg).await;
        }
        async fn get_member_avatar_image(
            client: &Client,
            member: Member,
        ) -> Option<image::DynamicImage> {
            let avatar_req = client
                .get(
                    member
                        .avatar_url()
                        .unwrap_or(
                            member
                                .user
                                .avatar_url()
                                .unwrap_or(member.user.default_avatar_url()),
                        ),
                )
                .send()
                .await
                .ok()?;
            let bytes = avatar_req.bytes().await.ok()?;
            image::load_from_memory(&bytes).ok()
        }
    }
    mod message {
        use serenity::all::{Context, CreateAllowedMentions, CreateMessage, Message};
        use tracing::warn;
        use crate::{
            commands::{CommandArgument, TransformerError},
            event_handler::{CommandError, Handler},
            lexer::{Token, lex},
            utils::{check_guild_permission, is_developer},
        };
        pub async fn message(handler: &Handler, ctx: Context, msg: Message) {
            if !msg.content.starts_with(handler.prefix.as_str())
                || msg.guild_id.is_none()
            {
                return;
            }
            let contents = msg.content.clone();
            let strip = contents.strip_prefix(handler.prefix.as_str()).unwrap_or("");
            let lex = lex(String::from(strip));
            let mut parts = lex.into_iter().peekable();
            let command_name = parts.next().map(|s| s.raw).unwrap_or_default();
            if command_name == "help" {
                if let Err(err) = handler
                    .help_run(ctx.clone(), msg.clone(), parts.collect())
                    .await
                {
                    handler.send_error(ctx, msg, contents, err).await;
                }
                return;
            } else if command_name == "cachedbg" && is_developer(&msg.author) {
                let lock = handler.message_cache.lock().await;
                let mut sizes = lock.get_sizes();
                let size = sizes.entry(msg.channel_id.get()).or_insert(100);
                let count = lock.get_channel_len(msg.channel_id.get());
                let mut inserts = lock.get_inserts();
                let insert_count = inserts.entry(msg.channel_id.get()).or_insert(0);
                let reply = CreateMessage::new()
                    .content(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "Size: {0}; Count: {1}; Inserts: {2}",
                                    *size,
                                    count,
                                    *insert_count,
                                ),
                            )
                        }),
                    )
                    .reference_message(&msg)
                    .allowed_mentions(CreateAllowedMentions::new().replied_user(false));
                if let Err(err) = msg.channel_id.send_message(&ctx.http, reply).await {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\event_handler\\message.rs:48",
                                    "Ouroboros::event_handler::message",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\event_handler\\message.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(48u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::event_handler::message",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!("Could not send message; err = {0:?}", err)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!("Could not send message; err = {0:?}", err)
                                                                                as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                }
                return;
            }
            let command = handler
                .commands
                .iter()
                .find(|c| c.get_name() == command_name.to_lowercase());
            if let Some(c) = command {
                let permissions = c.get_permissions();
                if !permissions.required.is_empty() || !permissions.one_of.is_empty() {
                    let Ok(member) = msg.member(&ctx.http).await else {
                        handler
                            .send_error(
                                ctx,
                                msg,
                                contents,
                                CommandError {
                                    title: String::from(
                                        "You do not have permissions to execute this command.",
                                    ),
                                    hint: Some(
                                        String::from(
                                            "consider begging for more permissions at your local Discord administrator!",
                                        ),
                                    ),
                                    arg: None,
                                },
                            )
                            .await;
                        return;
                    };
                    for permission in permissions.required {
                        if !check_guild_permission(&ctx, &member, permission).await {
                            handler
                                .send_error(
                                    ctx,
                                    msg,
                                    contents,
                                    CommandError {
                                        title: String::from(
                                            "You do not have permissions to execute this command.",
                                        ),
                                        hint: Some(
                                            String::from(
                                                "consider begging for more permissions at your local Discord administrator!",
                                            ),
                                        ),
                                        arg: None,
                                    },
                                )
                                .await;
                            return;
                        }
                    }
                    let mut pass = true;
                    for permission in permissions.one_of {
                        if !check_guild_permission(&ctx, &member, permission).await {
                            pass = false;
                            break;
                        }
                    }
                    if !pass {
                        handler
                            .send_error(
                                ctx,
                                msg,
                                contents,
                                CommandError {
                                    title: String::from(
                                        "You do not have permissions to execute this command.",
                                    ),
                                    hint: Some(
                                        String::from(
                                            "consider begging for more permissions at your local Discord administrator!",
                                        ),
                                    ),
                                    arg: None,
                                },
                            )
                            .await;
                        return;
                    }
                }
                let mut transformers = c.get_transformers().into_iter();
                let mut args: Vec<Token> = ::alloc::vec::Vec::new();
                while parts.peek().is_some() {
                    if let Some(transformer) = transformers.next() {
                        let result = transformer(&ctx, &msg, &mut parts).await;
                        match result {
                            Ok(r) => {
                                args.push(r);
                            }
                            Err(TransformerError::MissingArgumentError(err)) => {
                                handler
                                    .send_error(
                                        ctx,
                                        msg,
                                        contents,
                                        CommandError::arg_not_found(&err.0, None),
                                    )
                                    .await;
                                return;
                            }
                            Err(TransformerError::CommandError(err)) => {
                                handler.send_error(ctx, msg, contents, err).await;
                                return;
                            }
                        }
                    } else if let Some(mut arg) = parts.next() {
                        arg.contents = Some(CommandArgument::String(arg.raw.clone()));
                        args.push(arg);
                    }
                }
                for transformer in transformers {
                    let result = transformer(&ctx, &msg, &mut parts).await;
                    match result {
                        Ok(r) => {
                            args.push(r);
                        }
                        Err(TransformerError::CommandError(err)) => {
                            handler.send_error(ctx, msg, contents, err).await;
                            return;
                        }
                        Err(TransformerError::MissingArgumentError(_)) => {
                            args.push(Token {
                                contents: Some(CommandArgument::None),
                                raw: String::new(),
                                position: 0,
                                length: 0,
                                iteration: 0,
                                quoted: false,
                                inferred: None,
                            });
                        }
                    }
                }
                let res = c.run(ctx.clone(), msg.clone(), args).await;
                if let Err(err) = res {
                    handler.send_error(ctx, msg, contents, err).await;
                }
            }
        }
    }
    mod message_delete {
        use chrono::Utc;
        use serenity::all::{
            Channel, Context, CreateAttachment, CreateEmbed, CreateEmbedAuthor,
            CreateMessage, Message, MessageAction, audit_log::Action,
        };
        use tracing::warn;
        use crate::{
            GUILD_SETTINGS, constants::BRAND_RED,
            event_handler::{Handler, MessageDeleteEvent},
            utils::{LogType, guild_log, snowflake_to_timestamp},
        };
        pub async fn message_delete(
            _handler: &Handler,
            ctx: Context,
            event: MessageDeleteEvent,
            old_if_available: Option<Message>,
        ) {
            if let Some(msg) = old_if_available.clone() {
                let mut settings = GUILD_SETTINGS.get().unwrap().lock().await;
                let guild_id = msg.guild_id.map(|g| g.get()).unwrap_or(0);
                if let Ok(guild_settings) = settings.get(guild_id).await {
                    if msg.author.bot && guild_settings.log.log_bots.is_none_or(|b| !b) {
                        return;
                    }
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\event_handler\\message_delete.rs:30",
                                    "Ouroboros::event_handler::message_delete",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\event_handler\\message_delete.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(30u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::event_handler::message_delete",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Found guild with no cached settings; Id = {0}",
                                                        guild_id,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "Found guild with no cached settings; Id = {0}",
                                                                                guild_id,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                };
            }
            let guild_id = match event.channel_id.to_channel(&ctx.http).await {
                Ok(Channel::Guild(guild_channel)) => guild_channel.guild_id,
                _ => return,
            };
            let audit_log = guild_id
                .audit_logs(
                    &ctx.http,
                    Some(Action::Message(MessageAction::Delete)),
                    None,
                    None,
                    Some(10),
                )
                .await
                .ok();
            let mut actor_id: Option<u64> = None;
            if let Some(logs) = audit_log {
                if let Some(entry) = logs.entries.first() {
                    let entry_time = snowflake_to_timestamp(entry.id.get());
                    if (Utc::now() - entry_time).num_seconds().abs() <= 300
                        && let Some(target) = entry.target_id
                        && let Some(Some(channel)) = entry
                            .options
                            .clone()
                            .map(|o| o.channel_id)
                        && let Some(msg) = old_if_available.clone()
                        && target.get() == msg.author.id.get()
                        && channel.get() == msg.channel_id.get()
                    {
                        actor_id = Some(entry.user_id.get());
                    }
                } else {
                    for entry in logs.entries {
                        let entry_time = snowflake_to_timestamp(entry.id.get());
                        if (Utc::now() - entry_time).num_seconds().abs() <= 5
                            && let Some(target) = entry.target_id
                            && let Some(Some(channel)) = entry
                                .options
                                .clone()
                                .map(|o| o.channel_id)
                            && let Some(msg) = old_if_available.clone()
                            && target.get() == msg.author.id.get()
                            && channel.get() == msg.channel_id.get()
                        {
                            actor_id = Some(entry.user_id.get());
                        }
                    }
                }
            }
            let mut description = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!("**MESSAGE DELETED**\n-# {0} ", event.message_id.get()),
                )
            });
            let mut files = ::alloc::vec::Vec::new();
            let mut embed = CreateEmbed::new().color(BRAND_RED);
            if let Some(msg) = old_if_available.clone() {
                description
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("| Target: <@{0}> ", msg.author.id.get()),
                            )
                        }),
                    );
                embed = embed
                    .author(
                        CreateEmbedAuthor::new(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0}: {1}",
                                            msg.author.name,
                                            msg.author.id.get(),
                                        ),
                                    )
                                }),
                            )
                            .icon_url(
                                msg
                                    .author
                                    .avatar_url()
                                    .unwrap_or(msg.author.default_avatar_url()),
                            ),
                    );
                for attachment in msg.attachments.iter() {
                    let name = attachment.filename.clone();
                    if let Ok(bytes) = attachment.download().await {
                        files.push(CreateAttachment::bytes(bytes, name));
                    }
                }
            }
            description
                .push_str(
                    &::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "| Channel: <#{0}> ({0}) ",
                                event.channel_id.get(),
                            ),
                        )
                    }),
                );
            if let Some(moderator) = actor_id {
                description
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("| Actor: <@{0}> ({0}) ", moderator),
                            )
                        }),
                    );
            }
            if let Some(msg) = old_if_available {
                description
                    .push_str(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "\n{0}",
                                    if msg.content.is_empty() {
                                        String::new()
                                    } else {
                                        ::alloc::__export::must_use({
                                            ::alloc::fmt::format(
                                                format_args!("```\n{0} \n```", msg.content),
                                            )
                                        })
                                    },
                                ),
                            )
                        }),
                    );
            } else {
                description.push_str("\nContent not found in cache");
            }
            guild_log(
                    &ctx.http,
                    LogType::MessageDelete,
                    guild_id,
                    CreateMessage::new()
                        .add_embed(embed.description(description))
                        .add_files(files),
                )
                .await;
        }
    }
    mod message_update {
        use serenity::all::{
            Channel, Context, CreateAttachment, CreateEmbed, CreateEmbedAuthor,
            CreateMessage, Message, MessageUpdateEvent,
        };
        use crate::{
            constants::SOFT_YELLOW, event_handler::Handler, utils::{LogType, guild_log},
        };
        pub async fn message_update(
            _handler: &Handler,
            ctx: Context,
            old_if_available: Option<Message>,
            new: Option<Message>,
            event: MessageUpdateEvent,
        ) {
            if event.edited_timestamp.is_none() {
                return;
            }
            let mut new_msg = match new {
                Some(m) if m.author.id != ctx.cache.current_user().id => m,
                Some(_) => return,
                None => {
                    match event.channel_id.message(&ctx.http, event.id).await {
                        Ok(m) if m.author.id != ctx.cache.current_user().id => m,
                        _ => return,
                    }
                }
            };
            if new_msg.content.is_empty() {
                new_msg.content = String::from("(no content)");
            }
            let base = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "**MESSAGE EDITED**\n-# Message {0} [jump](https://discord.com/channels/{3}/{2}/{0}) | Target: <@{1}> | Channel: <#{2}> ({2})",
                        new_msg.id.get(),
                        new_msg.author.id.get(),
                        new_msg.channel_id.get(),
                        new_msg.guild_id.map(|g| g.get()).unwrap_or(0),
                    ),
                )
            });
            let (desc, files) = match old_if_available {
                Some(mut old) => {
                    if old.content.is_empty() {
                        old.content = String::from("(no content)");
                    }
                    if old.content.len() > 500 || new_msg.content.len() > 500 {
                        (
                            base.clone(),
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    CreateAttachment::bytes(
                                        new_msg.content.as_bytes(),
                                        "new.txt",
                                    ),
                                    CreateAttachment::bytes(old.content.as_bytes(), "old.txt"),
                                ]),
                            ),
                        )
                    } else {
                        (
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{2}\nBefore:```\n{0}\n```\nAfter:\n```\n{1}\n```",
                                        old.content.replace("```", "\\`\\`\\`"),
                                        new_msg.content.replace("```", "\\`\\`\\`"),
                                        base,
                                    ),
                                )
                            }),
                            ::alloc::vec::Vec::new(),
                        )
                    }
                }
                None => {
                    if new_msg.content.len() > 500 {
                        (
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0}\nMessage content not found in cache",
                                        base,
                                    ),
                                )
                            }),
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    CreateAttachment::bytes(
                                        new_msg.content.as_bytes(),
                                        "new.txt",
                                    ),
                                ]),
                            ),
                        )
                    } else {
                        (
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{1}\nBefore:```\nMessage content not found in cache\n```\nAfter:\n```\n{0}\n```",
                                        new_msg.content.replace("```", "\\`\\`\\`"),
                                        base,
                                    ),
                                )
                            }),
                            ::alloc::vec::Vec::new(),
                        )
                    }
                }
            };
            let mut message = CreateMessage::new()
                .add_embed(
                    CreateEmbed::new()
                        .color(SOFT_YELLOW)
                        .description(desc)
                        .author(
                            CreateEmbedAuthor::new(
                                    ::alloc::__export::must_use({
                                        ::alloc::fmt::format(
                                            format_args!(
                                                "{0}: {1}",
                                                new_msg.author.name,
                                                new_msg.author.id.get(),
                                            ),
                                        )
                                    }),
                                )
                                .icon_url(
                                    new_msg
                                        .author
                                        .avatar_url()
                                        .unwrap_or(new_msg.author.default_avatar_url()),
                                ),
                        ),
                );
            for f in files {
                message = message.add_file(f);
            }
            let guild_id = match new_msg.channel_id.to_channel(&ctx.http).await {
                Ok(Channel::Guild(g)) => g.guild_id.get(),
                _ => new_msg.guild_id.map(|g| g.get()).unwrap_or(1),
            };
            guild_log(&ctx.http, LogType::MessageEdit, guild_id.into(), message).await;
        }
    }
    mod shards_ready {
        use std::fs;
        use serenity::all::Context;
        use sqlx::query;
        use tracing::{error, info};
        use crate::{
            BOT_CONFIG, GUILD_SETTINGS, SQL, config::Environment, event_handler::Handler,
        };
        pub async fn shards_ready(handler: &Handler, ctx: Context, _total_shards: u32) {
            let cfg = BOT_CONFIG.get().unwrap();
            finish_update(&ctx).await;
            check_whitelist(cfg, &ctx).await;
            update_guild_settings(&ctx).await;
            fill_message_cache(handler, &ctx).await;
        }
        pub async fn finish_update(ctx: &Context) {
            let ids = {
                if let Some(arg) = std::env::args()
                    .collect::<Vec<String>>()
                    .iter()
                    .find(|a| a.starts_with("--id"))
                {
                    let Some(ids) = arg.split("=").last() else {
                        return;
                    };
                    ids.to_string()
                } else if let Ok(ids) = fs::read_to_string("./update.txt") {
                    let _ = fs::remove_file("./update.txt");
                    ids
                } else {
                    return;
                }
            };
            let mut parts = ids.split(':');
            let (channel_id, msg_id) = match (parts.next(), parts.next()) {
                (Some(a), Some(b)) => (a, b),
                _ => {
                    return;
                }
            };
            let Ok(channel) = ctx
                .http
                .get_channel(channel_id.parse::<u64>().unwrap().into())
                .await else {
                return;
            };
            let Ok(message) = channel
                .id()
                .message(ctx, msg_id.parse::<u64>().unwrap())
                .await else {
                return;
            };
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src\\event_handler\\shards_ready.rs:63",
                            "Ouroboros::event_handler::shards_ready",
                            ::tracing::Level::INFO,
                            ::tracing_core::__macro_support::Option::Some(
                                "src\\event_handler\\shards_ready.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(63u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "Ouroboros::event_handler::shards_ready",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "Replying to update command; channel = {0:?} message = {1:?}",
                                                channel,
                                                message,
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!(
                                                                        "Replying to update command; channel = {0:?} message = {1:?}",
                                                                        channel,
                                                                        message,
                                                                    ) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
            let _ = message.reply(ctx, "Update finished!").await;
        }
        pub async fn update_guild_settings(ctx: &Context) {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src\\event_handler\\shards_ready.rs:69",
                            "Ouroboros::event_handler::shards_ready",
                            ::tracing::Level::INFO,
                            ::tracing_core::__macro_support::Option::Some(
                                "src\\event_handler\\shards_ready.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(69u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "Ouroboros::event_handler::shards_ready",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("Adding missing guilds to guild_settings")
                                                as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Adding missing guilds to guild_settings")
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
            let guild_ids: Vec<String> = ctx
                .cache
                .guilds()
                .iter()
                .map(|g| ::alloc::__export::must_use({
                    ::alloc::fmt::format(format_args!("({0})", g.get()))
                }))
                .collect();
            let query = ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "INSERT INTO guild_settings (guild_id) VALUES {0} ON CONFLICT (guild_id) DO NOTHING;",
                        guild_ids.join(", "),
                    ),
                )
            });
            if let Err(err) = sqlx::query(&query).execute(SQL.get().unwrap()).await {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src\\event_handler\\shards_ready.rs:83",
                                "Ouroboros::event_handler::shards_ready",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "src\\event_handler\\shards_ready.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(83u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "Ouroboros::event_handler::shards_ready",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "Couldnt add missing guilds to guild_settings; err = {0:?}",
                                                    err,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::tracing::__macro_support::Option::Some(
                                                                        &format_args!(
                                                                            "Couldnt add missing guilds to guild_settings; err = {0:?}",
                                                                            err,
                                                                        ) as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                }
            }
            {
                let mut settings = GUILD_SETTINGS.get().unwrap().lock().await;
                settings.invalidate();
            }
        }
        pub async fn check_whitelist(cfg: &Environment, ctx: &Context) {
            if cfg.whitelist_enabled.is_none_or(|b| !b) {
                return;
            }
            for guild in ctx.cache.guilds() {
                if cfg.whitelist.as_ref().is_none_or(|ids| !ids.contains(&guild.get()))
                    && let Err(err) = ctx.http.leave_guild(guild).await
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\event_handler\\shards_ready.rs:104",
                                    "Ouroboros::event_handler::shards_ready",
                                    ::tracing::Level::ERROR,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\event_handler\\shards_ready.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(104u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::event_handler::shards_ready",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::ERROR {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Could not leave non-whitelisted guild! err = {1:?}; id = {0}",
                                                        guild.get(),
                                                        err,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "Could not leave non-whitelisted guild! err = {1:?}; id = {0}",
                                                                                guild.get(),
                                                                                err,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                }
            }
        }
        pub async fn fill_message_cache(handler: &Handler, ctx: &Context) {
            let existing_data = match {
                {
                    #[allow(clippy::all)]
                    {
                        use ::sqlx::Arguments as _;
                        let query_args = ::core::result::Result::<
                            _,
                            ::sqlx::error::BoxDynError,
                        >::Ok(
                            <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                '_,
                            >::default(),
                        );
                        #[allow(non_snake_case)]
                        struct Record {
                            channel_id: i64,
                            message_count: i32,
                            previous_action: i16,
                        }
                        #[automatically_derived]
                        #[allow(non_snake_case)]
                        impl ::core::fmt::Debug for Record {
                            #[inline]
                            fn fmt(
                                &self,
                                f: &mut ::core::fmt::Formatter,
                            ) -> ::core::fmt::Result {
                                ::core::fmt::Formatter::debug_struct_field3_finish(
                                    f,
                                    "Record",
                                    "channel_id",
                                    &self.channel_id,
                                    "message_count",
                                    &self.message_count,
                                    "previous_action",
                                    &&self.previous_action,
                                )
                            }
                        }
                        ::sqlx::__query_with_result::<
                            sqlx::postgres::Postgres,
                            _,
                        >("SELECT * FROM message_cache_store", query_args)
                            .try_map(|row: sqlx::postgres::PgRow| {
                                use ::sqlx::Row as _;
                                #[allow(non_snake_case)]
                                let sqlx_query_as_channel_id = row
                                    .try_get_unchecked::<i64, _>(0usize)?
                                    .into();
                                #[allow(non_snake_case)]
                                let sqlx_query_as_message_count = row
                                    .try_get_unchecked::<i32, _>(1usize)?
                                    .into();
                                #[allow(non_snake_case)]
                                let sqlx_query_as_previous_action = row
                                    .try_get_unchecked::<i16, _>(2usize)?
                                    .into();
                                ::std::result::Result::Ok(Record {
                                    channel_id: sqlx_query_as_channel_id,
                                    message_count: sqlx_query_as_message_count,
                                    previous_action: sqlx_query_as_previous_action,
                                })
                            })
                    }
                }
            }
                .fetch_all(SQL.get().unwrap())
                .await
            {
                Ok(r) => r,
                Err(err) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\event_handler\\shards_ready.rs:119",
                                    "Ouroboros::event_handler::shards_ready",
                                    ::tracing::Level::ERROR,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\event_handler\\shards_ready.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(119u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::event_handler::shards_ready",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::ERROR {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Couldnt fetch latest message cache counts; err = {0:?}",
                                                        err,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "Couldnt fetch latest message cache counts; err = {0:?}",
                                                                                err,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return;
                }
            };
            let mut lock = handler.message_cache.lock().await;
            for guild in ctx.cache.guilds() {
                let Some(cached) = guild.to_guild_cached(&ctx.cache) else {
                    continue;
                };
                for id in cached.channels.keys() {
                    lock.assign_count(id.get(), 100);
                }
            }
            for record in existing_data {
                lock.assign_count(
                    record.channel_id as u64,
                    record.message_count as usize,
                );
            }
        }
    }
    pub struct Handler {
        prefix: String,
        commands: Vec<Arc<dyn Command>>,
        message_cache: Arc<Mutex<MessageCache>>,
    }
    impl Handler {
        pub fn new(prefix: String) -> Self {
            let commands: Vec<Arc<dyn Command>> = <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    Arc::new(Ping::new()),
                    Arc::new(Stats::new()),
                    Arc::new(Warn::new()),
                    Arc::new(Log::new()),
                    Arc::new(Kick::new()),
                    Arc::new(Softban::new()),
                    Arc::new(Ban::new()),
                    Arc::new(Mute::new()),
                    Arc::new(Unban::new()),
                    Arc::new(Unmute::new()),
                    Arc::new(Purge::new()),
                    Arc::new(MsgDbg::new()),
                    Arc::new(ColonThree::new()),
                    Arc::new(Reason::new()),
                    Arc::new(Update::new()),
                    Arc::new(Config::new()),
                    Arc::new(Say::new()),
                    Arc::new(About::new()),
                    Arc::new(DurationCommand::new()),
                    Arc::new(ExtractId::new()),
                    Arc::new(Cache::new()),
                    Arc::new(DefineLog::new()),
                ]),
            );
            let cache = Arc::new(Mutex::new(MessageCache::new()));
            let cache_clone = cache.clone();
            tokio::spawn(async move {
                loop {
                    sleep(Duration::from_secs(60 * 60 * 60)).await;
                    let lock = cache_clone.lock().await;
                    Self::update_cache_size(lock).await;
                }
            });
            Self {
                prefix,
                commands,
                message_cache: cache,
            }
        }
    }
    impl Handler {
        pub async fn send_error(
            &self,
            ctx: Context,
            msg: Message,
            input: String,
            err: CommandError,
        ) {
            let error_message;
            if let Some(arg) = err.arg {
                let mut hint = String::new();
                if let Some(h) = err.hint {
                    hint = ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("**hint:** {0}", h))
                    });
                }
                error_message = ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "**error:** argument {0}\n```\n{5}\n{1}{2}\n{3}\n```\n{4}",
                            arg.iteration,
                            " ".repeat(arg.position + 1),
                            "^".repeat(arg.length),
                            err.title,
                            hint,
                            input,
                        ),
                    )
                });
            } else {
                let mut hint = String::new();
                if let Some(h) = err.hint {
                    hint = ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("**hint:** {0}", h))
                    });
                }
                error_message = ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "**error:** command failed to run```\n{2}\n\n{0}\n```\n{1}",
                            err.title,
                            hint,
                            input,
                        ),
                    )
                });
            }
            let reply = CreateMessage::new()
                .add_embed(
                    CreateEmbed::new()
                        .description(error_message.clone())
                        .color(BRAND_RED),
                )
                .reference_message(&msg)
                .allowed_mentions(CreateAllowedMentions::new().replied_user(false));
            if let Err(e) = msg.channel_id.send_message(&ctx.http, reply).await {
                let _ = msg
                    .channel_id
                    .send_message(
                        &ctx.http,
                        CreateMessage::new()
                            .content(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "{0}\n-# Bot does not have embed perms in this channel, ",
                                            error_message,
                                        ),
                                    )
                                }),
                            ),
                    )
                    .await;
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src\\event_handler\\mod.rs:186",
                                "Ouroboros::event_handler",
                                ::tracing::Level::WARN,
                                ::tracing_core::__macro_support::Option::Some(
                                    "src\\event_handler\\mod.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(186u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "Ouroboros::event_handler",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::WARN
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::WARN
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!("Could not send message; err = {0:?}", e)
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::WARN {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::tracing::__macro_support::Option::Some(
                                                                        &format_args!("Could not send message; err = {0:?}", e)
                                                                            as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                }
            }
        }
        pub async fn update_cache_size(mut cache: MutexGuard<'_, MessageCache>) {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src\\event_handler\\mod.rs:191",
                            "Ouroboros::event_handler",
                            ::tracing::Level::INFO,
                            ::tracing_core::__macro_support::Option::Some(
                                "src\\event_handler\\mod.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(191u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "Ouroboros::event_handler",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("Updating message cache sizes...")
                                                as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Updating message cache sizes...")
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
            let inserts = cache.get_inserts();
            let mut sizes = cache.get_sizes();
            let actions: HashMap<u64, i16> = HashMap::new();
            for (channel, count) in inserts {
                let count = count as f32;
                let size = *sizes.entry(channel).or_insert(100) as f32;
                if count > size * 120.0 {
                    sizes.insert(channel, (size * 120.0).round() as usize);
                } else if (count) < size * 0.8 {
                    sizes.insert(channel, (size * 0.8).round() as usize);
                }
            }
            let rows: Vec<(i64, i64, i16)> = sizes
                .iter()
                .map(|(&channel_id, &count)| {
                    let prev_action = actions.get(&channel_id).copied().unwrap_or(0);
                    (channel_id as i64, count as i64, prev_action)
                })
                .collect();
            let channel_ids: Vec<i64> = rows.iter().map(|r| r.0).collect();
            let message_counts: Vec<i64> = rows.iter().map(|r| r.1).collect();
            let previous_actions: Vec<i16> = rows.iter().map(|r| r.2).collect();
            if let Err(err) = {
                {
                    #[allow(clippy::all)]
                    {
                        use ::sqlx::Arguments as _;
                        let arg0 = &(&channel_ids);
                        let arg1 = &(&message_counts);
                        let arg2 = &(&previous_actions);
                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                        if false {
                            use ::sqlx::ty_match::{
                                WrapSameExt as _, MatchBorrowExt as _,
                            };
                            let expr = ::sqlx::ty_match::dupe_value(arg0);
                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                &[i64],
                                _,
                            >::new(&expr)
                                .wrap_same();
                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                ty_check,
                                &expr,
                            );
                            _ty_check = match_borrow.match_borrow();
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            );
                        }
                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                        if false {
                            use ::sqlx::ty_match::{
                                WrapSameExt as _, MatchBorrowExt as _,
                            };
                            let expr = ::sqlx::ty_match::dupe_value(arg1);
                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                &[i64],
                                _,
                            >::new(&expr)
                                .wrap_same();
                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                ty_check,
                                &expr,
                            );
                            _ty_check = match_borrow.match_borrow();
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            );
                        }
                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                        if false {
                            use ::sqlx::ty_match::{
                                WrapSameExt as _, MatchBorrowExt as _,
                            };
                            let expr = ::sqlx::ty_match::dupe_value(arg2);
                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                &[i16],
                                _,
                            >::new(&expr)
                                .wrap_same();
                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                ty_check,
                                &expr,
                            );
                            _ty_check = match_borrow.match_borrow();
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            );
                        }
                        let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                            '_,
                        >::default();
                        query_args
                            .reserve(
                                3usize,
                                0
                                    + ::sqlx::encode::Encode::<
                                        sqlx::postgres::Postgres,
                                    >::size_hint(arg0)
                                    + ::sqlx::encode::Encode::<
                                        sqlx::postgres::Postgres,
                                    >::size_hint(arg1)
                                    + ::sqlx::encode::Encode::<
                                        sqlx::postgres::Postgres,
                                    >::size_hint(arg2),
                            );
                        let query_args = ::core::result::Result::<
                            _,
                            ::sqlx::error::BoxDynError,
                        >::Ok(query_args)
                            .and_then(move |mut query_args| {
                                query_args.add(arg0).map(move |()| query_args)
                            })
                            .and_then(move |mut query_args| {
                                query_args.add(arg1).map(move |()| query_args)
                            })
                            .and_then(move |mut query_args| {
                                query_args.add(arg2).map(move |()| query_args)
                            });
                        ::sqlx::__query_with_result::<
                            sqlx::postgres::Postgres,
                            _,
                        >(
                            "\n                INSERT INTO message_cache_store (channel_id, message_count, previous_action)\n                SELECT * FROM UNNEST($1::BIGINT[], $2::BIGINT[], $3::SMALLINT[])\n                ON CONFLICT (channel_id) DO UPDATE\n                SET message_count = EXCLUDED.message_count,\n                    previous_action = EXCLUDED.previous_action\n            ",
                            query_args,
                        )
                    }
                }
            }
                .execute(SQL.get().unwrap())
                .await
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src\\event_handler\\mod.rs:235",
                                "Ouroboros::event_handler",
                                ::tracing::Level::WARN,
                                ::tracing_core::__macro_support::Option::Some(
                                    "src\\event_handler\\mod.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(235u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "Ouroboros::event_handler",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::WARN
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::WARN
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "Got error updating message cache store; err = {0:?}",
                                                    err,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::WARN {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::tracing::__macro_support::Option::Some(
                                                                        &format_args!(
                                                                            "Got error updating message cache store; err = {0:?}",
                                                                            err,
                                                                        ) as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
            }
            cache.clear_inserts();
        }
    }
    impl EventHandler for Handler {
        #[allow(
            elided_named_lifetimes,
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::needless_arbitrary_self_type,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn message<'life0, 'async_trait>(
            &'life0 self,
            ctx: Context,
            msg: Message,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = (),
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                let __self = self;
                let ctx = ctx;
                let msg = msg;
                let _: () = {
                    {
                        let mut lock = __self.message_cache.lock().await;
                        let cloned = msg.clone();
                        lock.store_message(cloned.channel_id.get(), cloned);
                    }
                    message::message(__self, ctx, msg).await;
                };
            })
        }
        #[allow(
            elided_named_lifetimes,
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::needless_arbitrary_self_type,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn message_update<'life0, 'async_trait>(
            &'life0 self,
            ctx: Context,
            _old_if_available: Option<Message>,
            new: Option<Message>,
            event: MessageUpdateEvent,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = (),
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                let __self = self;
                let ctx = ctx;
                let _old_if_available = _old_if_available;
                let new = new;
                let event = event;
                let _: () = {
                    let mut lock = __self.message_cache.lock().await;
                    let old_if_available = lock
                        .get_message(event.channel_id.get(), event.id.get())
                        .cloned();
                    message_update::message_update(
                            __self,
                            ctx,
                            old_if_available,
                            new,
                            event,
                        )
                        .await
                };
            })
        }
        #[allow(
            elided_named_lifetimes,
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::needless_arbitrary_self_type,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn message_delete<'life0, 'async_trait>(
            &'life0 self,
            ctx: Context,
            channel_id: ChannelId,
            deleted_message_id: MessageId,
            _guild_id: Option<GuildId>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = (),
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                let __self = self;
                let ctx = ctx;
                let channel_id = channel_id;
                let deleted_message_id = deleted_message_id;
                let _guild_id = _guild_id;
                let _: () = {
                    let mut lock = __self.message_cache.lock().await;
                    let event = MessageDeleteEvent {
                        channel_id,
                        message_id: deleted_message_id,
                    };
                    let old_if_available = lock
                        .get_message(event.channel_id.get(), event.message_id.get())
                        .cloned();
                    message_delete::message_delete(__self, ctx, event, old_if_available)
                        .await
                };
            })
        }
        #[allow(
            elided_named_lifetimes,
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::needless_arbitrary_self_type,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn guild_create<'life0, 'async_trait>(
            &'life0 self,
            ctx: Context,
            guild: Guild,
            is_new: Option<bool>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = (),
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                let __self = self;
                let ctx = ctx;
                let guild = guild;
                let is_new = is_new;
                let _: () = {
                    guild_create::guild_create(__self, ctx, guild, is_new).await
                };
            })
        }
        #[allow(
            elided_named_lifetimes,
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::needless_arbitrary_self_type,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn shards_ready<'life0, 'async_trait>(
            &'life0 self,
            ctx: Context,
            total_shards: u32,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = (),
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                let __self = self;
                let ctx = ctx;
                let total_shards = total_shards;
                let _: () = {
                    shards_ready::shards_ready(__self, ctx, total_shards).await
                };
            })
        }
        #[allow(
            elided_named_lifetimes,
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::needless_arbitrary_self_type,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn guild_member_update<'life0, 'async_trait>(
            &'life0 self,
            ctx: Context,
            old_if_available: Option<Member>,
            new: Option<Member>,
            event: GuildMemberUpdateEvent,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = (),
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                let __self = self;
                let ctx = ctx;
                let old_if_available = old_if_available;
                let new = new;
                let event = event;
                let _: () = {
                    guild_member_update::guild_member_update(
                            __self,
                            ctx,
                            old_if_available,
                            new,
                            event,
                        )
                        .await
                };
            })
        }
        #[allow(
            elided_named_lifetimes,
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::needless_arbitrary_self_type,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn guild_member_removal<'life0, 'async_trait>(
            &'life0 self,
            ctx: Context,
            guild_id: GuildId,
            user: User,
            member_data_if_available: Option<Member>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = (),
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                let __self = self;
                let ctx = ctx;
                let guild_id = guild_id;
                let user = user;
                let member_data_if_available = member_data_if_available;
                let _: () = {
                    guild_member_removal::guild_member_removal(
                            __self,
                            ctx,
                            guild_id,
                            user,
                            member_data_if_available,
                        )
                        .await
                };
            })
        }
    }
}
mod lexer {
    use crate::commands::CommandArgument;
    pub enum InferType {
        Message,
        SystemMessage,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for InferType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    InferType::Message => "Message",
                    InferType::SystemMessage => "SystemMessage",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InferType {
        #[inline]
        fn clone(&self) -> InferType {
            match self {
                InferType::Message => InferType::Message,
                InferType::SystemMessage => InferType::SystemMessage,
            }
        }
    }
    pub struct Token {
        pub contents: Option<CommandArgument>,
        pub raw: String,
        pub position: usize,
        pub length: usize,
        pub iteration: usize,
        pub quoted: bool,
        pub inferred: Option<InferType>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Token {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "contents",
                "raw",
                "position",
                "length",
                "iteration",
                "quoted",
                "inferred",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.contents,
                &self.raw,
                &self.position,
                &self.length,
                &self.iteration,
                &self.quoted,
                &&self.inferred,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Token", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Token {
        #[inline]
        fn clone(&self) -> Token {
            Token {
                contents: ::core::clone::Clone::clone(&self.contents),
                raw: ::core::clone::Clone::clone(&self.raw),
                position: ::core::clone::Clone::clone(&self.position),
                length: ::core::clone::Clone::clone(&self.length),
                iteration: ::core::clone::Clone::clone(&self.iteration),
                quoted: ::core::clone::Clone::clone(&self.quoted),
                inferred: ::core::clone::Clone::clone(&self.inferred),
            }
        }
    }
    pub fn lex(input: String) -> Vec<Token> {
        let mut iter = input.chars().enumerate().peekable();
        let mut tokens: Vec<Token> = ::alloc::vec::Vec::new();
        let mut in_quotes = false;
        let mut quote_char = '\0';
        let mut was_quoted = false;
        let mut token_start = 0;
        let mut token_count = 0;
        let mut current_token = String::new();
        while let Some((i, ch)) = iter.next() {
            if ch == '\\' {
                if let Some((_, next_char)) = iter.next() {
                    current_token.push(next_char);
                }
                continue;
            }
            if in_quotes {
                if ch == quote_char {
                    in_quotes = false;
                    continue;
                } else {
                    current_token.push(ch);
                    continue;
                }
            }
            if ch.is_whitespace() {
                if !current_token.is_empty() {
                    tokens
                        .push(Token {
                            contents: None,
                            raw: current_token.clone(),
                            position: token_start,
                            length: current_token.len(),
                            iteration: token_count,
                            quoted: was_quoted,
                            inferred: None,
                        });
                    token_count += 1;
                    current_token.clear();
                    was_quoted = false;
                }
                continue;
            }
            if ch == '"' || ch == '\'' {
                if current_token.is_empty() {
                    in_quotes = true;
                    quote_char = ch;
                    token_start = i + 1;
                    was_quoted = true;
                    continue;
                } else {
                    current_token.push(ch);
                    continue;
                }
            }
            if current_token.is_empty() {
                token_start = i;
            }
            current_token.push(ch);
        }
        if !current_token.is_empty() {
            tokens
                .push(Token {
                    contents: None,
                    length: current_token.len(),
                    raw: current_token,
                    position: token_start,
                    iteration: token_count,
                    quoted: was_quoted,
                    inferred: None,
                });
        }
        tokens
    }
}
mod tasks {
    mod expiring_actions {
        use std::sync::Arc;
        use serenity::all::{CacheHttp, EditMember, Guild, GuildId, Http};
        use sqlx::query;
        use tracing::{error, info, warn};
        use crate::SQL;
        pub async fn check_expiring_bans(http: &Arc<Http>) {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src\\tasks\\expiring_actions.rs:10",
                            "Ouroboros::tasks::expiring_actions",
                            ::tracing::Level::INFO,
                            ::tracing_core::__macro_support::Option::Some(
                                "src\\tasks\\expiring_actions.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(10u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "Ouroboros::tasks::expiring_actions",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "check_expiring_bans asynchronous task running...",
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!(
                                                                        "check_expiring_bans asynchronous task running...",
                                                                    ) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
            let data = match {
                {
                    #[allow(clippy::all)]
                    {
                        use ::sqlx::Arguments as _;
                        let query_args = ::core::result::Result::<
                            _,
                            ::sqlx::error::BoxDynError,
                        >::Ok(
                            <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                '_,
                            >::default(),
                        );
                        #[allow(non_snake_case)]
                        struct Record {
                            id: String,
                            guild_id: i64,
                            user_id: i64,
                        }
                        #[automatically_derived]
                        #[allow(non_snake_case)]
                        impl ::core::fmt::Debug for Record {
                            #[inline]
                            fn fmt(
                                &self,
                                f: &mut ::core::fmt::Formatter,
                            ) -> ::core::fmt::Result {
                                ::core::fmt::Formatter::debug_struct_field3_finish(
                                    f,
                                    "Record",
                                    "id",
                                    &self.id,
                                    "guild_id",
                                    &self.guild_id,
                                    "user_id",
                                    &&self.user_id,
                                )
                            }
                        }
                        ::sqlx::__query_with_result::<
                            sqlx::postgres::Postgres,
                            _,
                        >(
                                "\n        SELECT id, guild_id, user_id FROM actions WHERE type = 'ban' AND active = true AND expires_at < NOW();\n        ",
                                query_args,
                            )
                            .try_map(|row: sqlx::postgres::PgRow| {
                                use ::sqlx::Row as _;
                                #[allow(non_snake_case)]
                                let sqlx_query_as_id = row
                                    .try_get_unchecked::<String, _>(0usize)?
                                    .into();
                                #[allow(non_snake_case)]
                                let sqlx_query_as_guild_id = row
                                    .try_get_unchecked::<i64, _>(1usize)?
                                    .into();
                                #[allow(non_snake_case)]
                                let sqlx_query_as_user_id = row
                                    .try_get_unchecked::<i64, _>(2usize)?
                                    .into();
                                ::std::result::Result::Ok(Record {
                                    id: sqlx_query_as_id,
                                    guild_id: sqlx_query_as_guild_id,
                                    user_id: sqlx_query_as_user_id,
                                })
                            })
                    }
                }
            }
                .fetch_all(SQL.get().unwrap())
                .await
            {
                Ok(d) => d,
                Err(e) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\tasks\\expiring_actions.rs:19",
                                    "Ouroboros::tasks::expiring_actions",
                                    ::tracing::Level::ERROR,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\tasks\\expiring_actions.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(19u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::tasks::expiring_actions",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::ERROR {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "task check_expiring_bans couldnt fetch necessary data; Err = {0:?}",
                                                        e,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "task check_expiring_bans couldnt fetch necessary data; Err = {0:?}",
                                                                                e,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return;
                }
            };
            let mut updated: Vec<String> = ::alloc::vec::Vec::new();
            for entry in data {
                let Ok(guild) = Guild::get(http, entry.guild_id as u64).await else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\tasks\\expiring_actions.rs:28",
                                    "Ouroboros::tasks::expiring_actions",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\tasks\\expiring_actions.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(28u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::tasks::expiring_actions",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "task check_expiring_bans couldnt fetch guild; Id = {0:?}",
                                                        entry.guild_id,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "task check_expiring_bans couldnt fetch guild; Id = {0:?}",
                                                                                entry.guild_id,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    continue;
                };
                if guild.unban(http, entry.user_id as u64).await.is_err() {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\tasks\\expiring_actions.rs:36",
                                    "Ouroboros::tasks::expiring_actions",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\tasks\\expiring_actions.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(36u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::tasks::expiring_actions",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "task check_expiring_bans couldnt unban user; Guild = {0:?} Id = {1:?}",
                                                        entry.guild_id,
                                                        entry.user_id,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "task check_expiring_bans couldnt unban user; Guild = {0:?} Id = {1:?}",
                                                                                entry.guild_id,
                                                                                entry.user_id,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    continue;
                } else {
                    updated.push(entry.id);
                }
            }
            if {
                {
                    #[allow(clippy::all)]
                    {
                        use ::sqlx::Arguments as _;
                        let arg0 = &(&updated);
                        #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                        if false {
                            use ::sqlx::ty_match::{
                                WrapSameExt as _, MatchBorrowExt as _,
                            };
                            let expr = ::sqlx::ty_match::dupe_value(arg0);
                            let ty_check = ::sqlx::ty_match::WrapSame::<
                                &[String],
                                _,
                            >::new(&expr)
                                .wrap_same();
                            let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                ty_check,
                                &expr,
                            );
                            _ty_check = match_borrow.match_borrow();
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            );
                        }
                        let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                            '_,
                        >::default();
                        query_args
                            .reserve(
                                1usize,
                                0
                                    + ::sqlx::encode::Encode::<
                                        sqlx::postgres::Postgres,
                                    >::size_hint(arg0),
                            );
                        let query_args = ::core::result::Result::<
                            _,
                            ::sqlx::error::BoxDynError,
                        >::Ok(query_args)
                            .and_then(move |mut query_args| {
                                query_args.add(arg0).map(move |()| query_args)
                            });
                        ::sqlx::__query_with_result::<
                            sqlx::postgres::Postgres,
                            _,
                        >(
                            "\n        UPDATE actions SET active = false WHERE id = ANY($1);\n        ",
                            query_args,
                        )
                    }
                }
            }
                .execute(SQL.get().unwrap())
                .await
                .is_err()
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src\\tasks\\expiring_actions.rs:56",
                                "Ouroboros::tasks::expiring_actions",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "src\\tasks\\expiring_actions.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(56u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "Ouroboros::tasks::expiring_actions",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "task check_expiring_bans couldnt update entries; entries = {0:?}",
                                                    updated,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::tracing::__macro_support::Option::Some(
                                                                        &format_args!(
                                                                            "task check_expiring_bans couldnt update entries; entries = {0:?}",
                                                                            updated,
                                                                        ) as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
            } else {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src\\tasks\\expiring_actions.rs:61",
                                "Ouroboros::tasks::expiring_actions",
                                ::tracing::Level::INFO,
                                ::tracing_core::__macro_support::Option::Some(
                                    "src\\tasks\\expiring_actions.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(61u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "Ouroboros::tasks::expiring_actions",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::INFO {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::INFO {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!("task check_expiring_bans finished")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::tracing::__macro_support::Option::Some(
                                                                        &format_args!("task check_expiring_bans finished")
                                                                            as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
            }
        }
        pub async fn check_expiring_timeouts(cache_http: impl CacheHttp) {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src\\tasks\\expiring_actions.rs:66",
                            "Ouroboros::tasks::expiring_actions",
                            ::tracing::Level::INFO,
                            ::tracing_core::__macro_support::Option::Some(
                                "src\\tasks\\expiring_actions.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(66u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "Ouroboros::tasks::expiring_actions",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "check_expiring_timeouts asynchronous task running...",
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!(
                                                                        "check_expiring_timeouts asynchronous task running...",
                                                                    ) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
            let data = match {
                {
                    #[allow(clippy::all)]
                    {
                        use ::sqlx::Arguments as _;
                        let query_args = ::core::result::Result::<
                            _,
                            ::sqlx::error::BoxDynError,
                        >::Ok(
                            <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                '_,
                            >::default(),
                        );
                        #[allow(non_snake_case)]
                        struct Record {
                            id: String,
                            guild_id: i64,
                            user_id: i64,
                            expires_at: ::std::option::Option<
                                sqlx::types::chrono::NaiveDateTime,
                            >,
                            last_reapplied_at: ::std::option::Option<
                                sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>,
                            >,
                        }
                        #[automatically_derived]
                        #[allow(non_snake_case)]
                        impl ::core::fmt::Debug for Record {
                            #[inline]
                            fn fmt(
                                &self,
                                f: &mut ::core::fmt::Formatter,
                            ) -> ::core::fmt::Result {
                                ::core::fmt::Formatter::debug_struct_field5_finish(
                                    f,
                                    "Record",
                                    "id",
                                    &self.id,
                                    "guild_id",
                                    &self.guild_id,
                                    "user_id",
                                    &self.user_id,
                                    "expires_at",
                                    &self.expires_at,
                                    "last_reapplied_at",
                                    &&self.last_reapplied_at,
                                )
                            }
                        }
                        ::sqlx::__query_with_result::<
                            sqlx::postgres::Postgres,
                            _,
                        >(
                                "\n        SELECT id, guild_id, user_id, expires_at, last_reapplied_at\n        FROM actions\n        WHERE type = 'timeout'\n          AND active = true;\n        ",
                                query_args,
                            )
                            .try_map(|row: sqlx::postgres::PgRow| {
                                use ::sqlx::Row as _;
                                #[allow(non_snake_case)]
                                let sqlx_query_as_id = row
                                    .try_get_unchecked::<String, _>(0usize)?
                                    .into();
                                #[allow(non_snake_case)]
                                let sqlx_query_as_guild_id = row
                                    .try_get_unchecked::<i64, _>(1usize)?
                                    .into();
                                #[allow(non_snake_case)]
                                let sqlx_query_as_user_id = row
                                    .try_get_unchecked::<i64, _>(2usize)?
                                    .into();
                                #[allow(non_snake_case)]
                                let sqlx_query_as_expires_at = row
                                    .try_get_unchecked::<
                                        ::std::option::Option<sqlx::types::chrono::NaiveDateTime>,
                                        _,
                                    >(3usize)?
                                    .into();
                                #[allow(non_snake_case)]
                                let sqlx_query_as_last_reapplied_at = row
                                    .try_get_unchecked::<
                                        ::std::option::Option<
                                            sqlx::types::chrono::DateTime<sqlx::types::chrono::Utc>,
                                        >,
                                        _,
                                    >(4usize)?
                                    .into();
                                ::std::result::Result::Ok(Record {
                                    id: sqlx_query_as_id,
                                    guild_id: sqlx_query_as_guild_id,
                                    user_id: sqlx_query_as_user_id,
                                    expires_at: sqlx_query_as_expires_at,
                                    last_reapplied_at: sqlx_query_as_last_reapplied_at,
                                })
                            })
                    }
                }
            }
                .fetch_all(SQL.get().unwrap())
                .await
            {
                Ok(d) => d,
                Err(e) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\tasks\\expiring_actions.rs:81",
                                    "Ouroboros::tasks::expiring_actions",
                                    ::tracing::Level::ERROR,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\tasks\\expiring_actions.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(81u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::tasks::expiring_actions",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::ERROR {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::ERROR {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "task check_expiring_timeouts couldnt fetch necessary data; Err = {0:?}",
                                                        e,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "task check_expiring_timeouts couldnt fetch necessary data; Err = {0:?}",
                                                                                e,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return;
                }
            };
            let mut updated: Vec<String> = ::alloc::vec::Vec::new();
            let cache_http_ref = &cache_http;
            let now = chrono::Utc::now();
            for entry in data {
                let Ok(mut member) = GuildId::from(entry.guild_id as u64)
                    .member(cache_http_ref, entry.user_id as u64)
                    .await else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\tasks\\expiring_actions.rs:95",
                                    "Ouroboros::tasks::expiring_actions",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\tasks\\expiring_actions.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(95u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::tasks::expiring_actions",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "task check_expiring_timeouts couldnt fetch member; Guild = {0:?} Id = {1:?}",
                                                        entry.guild_id,
                                                        entry.user_id,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!(
                                                                                "task check_expiring_timeouts couldnt fetch member; Guild = {0:?} Id = {1:?}",
                                                                                entry.guild_id,
                                                                                entry.user_id,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    continue;
                };
                let remaining = entry
                    .expires_at
                    .map(|expires_at| expires_at.and_utc() - now);
                let still_active = remaining
                    .map(|d| d.num_seconds() > 0)
                    .unwrap_or(true);
                if !still_active {
                    continue;
                }
                let needs_reapply = match entry.expires_at {
                    None => {
                        match entry.last_reapplied_at {
                            Some(last) => {
                                now.signed_duration_since(last)
                                    >= chrono::Duration::days(20)
                            }
                            None => true,
                        }
                    }
                    Some(expiry) => {
                        let remaining = expiry.and_utc() - now;
                        if remaining <= chrono::Duration::days(27) {
                            true
                        } else {
                            match entry.last_reapplied_at {
                                Some(last) => {
                                    now.signed_duration_since(last)
                                        >= chrono::Duration::days(20)
                                }
                                None => true,
                            }
                        }
                    }
                };
                if needs_reapply {
                    let new_timeout = remaining
                        .unwrap_or_else(|| chrono::Duration::days(27));
                    let capped_timeout = std::cmp::min(
                        new_timeout,
                        chrono::Duration::days(27),
                    );
                    let reason = ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "Ouroboros Managed Mute: log id `{0}`. Please use Ouroboros to unmute to avoid accidental re-application!",
                                entry.id,
                            ),
                        )
                    });
                    let edit = EditMember::new()
                        .audit_log_reason(reason.as_str())
                        .disable_communication_until_datetime(
                            (now + capped_timeout).into(),
                        );
                    if let Err(e) = member.edit(cache_http_ref, edit).await {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src\\tasks\\expiring_actions.rs:144",
                                        "Ouroboros::tasks::expiring_actions",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "src\\tasks\\expiring_actions.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(144u32),
                                        ::tracing_core::__macro_support::Option::Some(
                                            "Ouroboros::tasks::expiring_actions",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    if match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::WARN {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &value_set,
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "task check_expiring_timeouts couldnt update timeout; Guild = {0:?} Id = {1:?} Err = {2:?}",
                                                            entry.guild_id,
                                                            entry.user_id,
                                                            e,
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                                            __CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                            ::tracing::__macro_support::Option::Some(
                                                                                &format_args!(
                                                                                    "task check_expiring_timeouts couldnt update timeout; Guild = {0:?} Id = {1:?} Err = {2:?}",
                                                                                    entry.guild_id,
                                                                                    entry.user_id,
                                                                                    e,
                                                                                ) as &dyn Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            }
                        };
                    } else {
                        updated.push(entry.id);
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src\\tasks\\expiring_actions.rs:150",
                                        "Ouroboros::tasks::expiring_actions",
                                        ::tracing::Level::INFO,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "src\\tasks\\expiring_actions.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(150u32),
                                        ::tracing_core::__macro_support::Option::Some(
                                            "Ouroboros::tasks::expiring_actions",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                    if match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    } <= ::tracing::log::STATIC_MAX_LEVEL
                                    {
                                        if !::tracing::dispatcher::has_been_set() {
                                            {
                                                use ::tracing::log;
                                                let level = match ::tracing::Level::INFO {
                                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                    _ => ::tracing::log::Level::Trace,
                                                };
                                                if level <= log::max_level() {
                                                    let meta = __CALLSITE.metadata();
                                                    let log_meta = log::Metadata::builder()
                                                        .level(level)
                                                        .target(meta.target())
                                                        .build();
                                                    let logger = log::logger();
                                                    if logger.enabled(&log_meta) {
                                                        ::tracing::__macro_support::__tracing_log(
                                                            meta,
                                                            logger,
                                                            log_meta,
                                                            &value_set,
                                                        )
                                                    }
                                                }
                                            }
                                        } else {
                                            {}
                                        }
                                    } else {
                                        {}
                                    };
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "reapplied timeout for user {0:?} in guild {1:?}, now until {2:?}",
                                                            entry.user_id,
                                                            entry.guild_id,
                                                            now + capped_timeout,
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                                if match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::INFO {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                                            __CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                            ::tracing::__macro_support::Option::Some(
                                                                                &format_args!(
                                                                                    "reapplied timeout for user {0:?} in guild {1:?}, now until {2:?}",
                                                                                    entry.user_id,
                                                                                    entry.guild_id,
                                                                                    now + capped_timeout,
                                                                                ) as &dyn Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            }
                        };
                    }
                }
            }
            if !updated.is_empty()
                && let Err(e) = {
                    {
                        #[allow(clippy::all)]
                        {
                            use ::sqlx::Arguments as _;
                            let arg0 = &(&updated);
                            #[allow(clippy::missing_panics_doc, clippy::unreachable)]
                            if false {
                                use ::sqlx::ty_match::{
                                    WrapSameExt as _, MatchBorrowExt as _,
                                };
                                let expr = ::sqlx::ty_match::dupe_value(arg0);
                                let ty_check = ::sqlx::ty_match::WrapSame::<
                                    &[String],
                                    _,
                                >::new(&expr)
                                    .wrap_same();
                                let (mut _ty_check, match_borrow) = ::sqlx::ty_match::MatchBorrow::new(
                                    ty_check,
                                    &expr,
                                );
                                _ty_check = match_borrow.match_borrow();
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                );
                            }
                            let mut query_args = <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                '_,
                            >::default();
                            query_args
                                .reserve(
                                    1usize,
                                    0
                                        + ::sqlx::encode::Encode::<
                                            sqlx::postgres::Postgres,
                                        >::size_hint(arg0),
                                );
                            let query_args = ::core::result::Result::<
                                _,
                                ::sqlx::error::BoxDynError,
                            >::Ok(query_args)
                                .and_then(move |mut query_args| {
                                    query_args.add(arg0).map(move |()| query_args)
                                });
                            ::sqlx::__query_with_result::<
                                sqlx::postgres::Postgres,
                                _,
                            >(
                                "UPDATE actions SET last_reapplied_at = NOW() WHERE id = ANY($1);",
                                query_args,
                            )
                        }
                    }
                }
                    .execute(SQL.get().unwrap())
                    .await
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src\\tasks\\expiring_actions.rs:168",
                                "Ouroboros::tasks::expiring_actions",
                                ::tracing::Level::ERROR,
                                ::tracing_core::__macro_support::Option::Some(
                                    "src\\tasks\\expiring_actions.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(168u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "Ouroboros::tasks::expiring_actions",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::ERROR
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::ERROR
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::ERROR {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "task check_expiring_timeouts couldnt update entries; Err = {0:?}",
                                                    e,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::ERROR {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::ERROR {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::tracing::__macro_support::Option::Some(
                                                                        &format_args!(
                                                                            "task check_expiring_timeouts couldnt update entries; Err = {0:?}",
                                                                            e,
                                                                        ) as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
            }
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src\\tasks\\expiring_actions.rs:174",
                            "Ouroboros::tasks::expiring_actions",
                            ::tracing::Level::INFO,
                            ::tracing_core::__macro_support::Option::Some(
                                "src\\tasks\\expiring_actions.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(174u32),
                            ::tracing_core::__macro_support::Option::Some(
                                "Ouroboros::tasks::expiring_actions",
                            ),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("task check_expiring_timeouts finished")
                                                as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!("task check_expiring_timeouts finished")
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
        }
    }
    pub use expiring_actions::check_expiring_bans;
    pub use expiring_actions::check_expiring_timeouts;
}
mod transformers {
    pub struct Transformers;
    mod bool {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::MissingArgumentError, lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn bool<'a>(
                _ctx: &'a Context,
                _msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    let Some(mut input) = args.next() else {
                        return Err(
                            TransformerError::MissingArgumentError(
                                MissingArgumentError(String::from("String")),
                            ),
                        );
                    };
                    let res = match input.raw.to_lowercase().as_str() {
                        "true" | "y" | "yes" | "yeah" | "t" | "ok" | "on" | "enabled"
                        | "1" | "enable" | "check" | "checked" | "sure" | "yep" | "aye"
                        | "valid" | "correct" => true,
                        _ => false,
                    };
                    input.contents = Some(CommandArgument::bool(res));
                    Ok(input)
                })
            }
        }
    }
    mod consume {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerReturn},
            lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn consume<'a>(
                _ctx: &'a Context,
                msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    let mut new_token = Token {
                        contents: None,
                        raw: String::new(),
                        position: 0,
                        length: 0,
                        iteration: 0,
                        quoted: false,
                        inferred: None,
                    };
                    let reason: String = {
                        if let Some(t) = args.next()
                            && !t.raw.chars().all(char::is_whitespace)
                        {
                            new_token.position = t.position;
                            new_token.iteration = t.iteration;
                            if t.quoted {
                                msg.content[t.position..].to_string().clone()
                            } else {
                                msg.content[t.position + 1..].to_string().clone()
                            }
                        } else {
                            String::new()
                        }
                    };
                    new_token.length = reason.len();
                    new_token.raw = reason;
                    new_token.contents = Some(
                        CommandArgument::String(new_token.raw.clone()),
                    );
                    Ok(new_token)
                })
            }
        }
    }
    mod duration {
        use std::{iter::Peekable, vec::IntoIter};
        use chrono::Duration;
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::{CommandError, MissingArgumentError},
            lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn duration<'a>(
                _ctx: &'a Context,
                _msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    let Some(mut input) = args.next() else {
                        return Err(
                            TransformerError::MissingArgumentError(
                                MissingArgumentError(String::from("Duration")),
                            ),
                        );
                    };
                    let s = input.raw.clone();
                    if s == "0" {
                        input.contents = Some(
                            CommandArgument::Duration(Duration::default()),
                        );
                        return Ok(input);
                    }
                    let (digits, last) = s.split_at(s.len() - 1);
                    if !"smhdwMy".contains(last) {
                        return Err(
                            TransformerError::CommandError(CommandError {
                                arg: Some(input),
                                title: String::from("Could not turn input to a <Duration>"),
                                hint: Some(
                                    String::from(
                                        "provide a valid number and a unit (s, m, h, d, w, M, y), i.e. 1h (1 hour) or 25d (25 days)",
                                    ),
                                ),
                            }),
                        );
                    }
                    let Ok(numbers) = digits.parse::<u32>() else {
                        return Err(
                            TransformerError::CommandError(CommandError {
                                arg: Some(input),
                                title: String::from("Could not turn input to a <Duration>"),
                                hint: Some(
                                    String::from(
                                        "provide a valid number and a unit (s, m, h, d, w, M, y), i.e. 1h (1 hour) or 25d (25 days)",
                                    ),
                                ),
                            }),
                        );
                    };
                    let numbers = numbers as i64;
                    match last {
                        "s" => {
                            input.contents = Some(
                                CommandArgument::Duration(Duration::seconds(numbers)),
                            );
                        }
                        "m" => {
                            input.contents = Some(
                                CommandArgument::Duration(Duration::minutes(numbers)),
                            );
                        }
                        "h" => {
                            input.contents = Some(
                                CommandArgument::Duration(Duration::hours(numbers)),
                            );
                        }
                        "d" => {
                            input.contents = Some(
                                CommandArgument::Duration(Duration::days(numbers)),
                            );
                        }
                        "w" => {
                            input.contents = Some(
                                CommandArgument::Duration(Duration::weeks(numbers)),
                            );
                        }
                        "M" => {
                            input.contents = Some(
                                CommandArgument::Duration(Duration::days(numbers * 30)),
                            );
                        }
                        "y" => {
                            input.contents = Some(
                                CommandArgument::Duration(Duration::days(numbers * 365)),
                            );
                        }
                        _ => {
                            return Err(
                                TransformerError::CommandError(CommandError {
                                    arg: Some(input),
                                    title: String::from("Could not turn input to a <Duration>"),
                                    hint: Some(
                                        String::from(
                                            "provide a valid number and a unit (s, m, h, d, w, M, y), i.e. 1h (1 hour) or 25d (25 days)",
                                        ),
                                    ),
                                }),
                            );
                        }
                    };
                    Ok(input)
                })
            }
        }
    }
    mod guild_channel {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::{CommandError, MissingArgumentError},
            lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn guild_channel<'a>(
                ctx: &'a Context,
                msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    let Some(mut input) = args.next() else {
                        return Err(
                            TransformerError::MissingArgumentError(
                                MissingArgumentError(String::from("Member")),
                            ),
                        );
                    };
                    let Some(guild) = msg.guild_id else {
                        return Err(
                            TransformerError::CommandError(CommandError {
                                title: String::from("Server only command"),
                                hint: Some(String::from("stop trying to run this in dms!")),
                                arg: None,
                            }),
                        );
                    };
                    let Ok(channels) = guild.channels(&ctx.http).await else {
                        return Err(
                            TransformerError::CommandError(CommandError {
                                title: String::from("Couldn't get guild channels"),
                                hint: Some(String::from("please try again later.")),
                                arg: None,
                            }),
                        );
                    };
                    let id = if let Ok(id) = input.raw.parse::<u64>() {
                        id
                    } else if input.raw.starts_with("<#") && input.raw.ends_with(">") {
                        let new_input = input
                            .raw
                            .strip_prefix("<#")
                            .unwrap()
                            .strip_suffix(">")
                            .unwrap();
                        if let Ok(id) = new_input.parse::<u64>() {
                            id
                        } else {
                            return Err(
                                TransformerError::CommandError(CommandError {
                                    arg: Some(input),
                                    title: String::from(
                                        "Could not turn input to a <Guild Channel>",
                                    ),
                                    hint: Some(String::from("provide a valid ID or mention")),
                                }),
                            );
                        }
                    } else {
                        0
                    };
                    for (channel_id, channel) in channels.into_iter() {
                        if id == channel_id.get() || channel.name == input.raw {
                            input.contents = Some(
                                CommandArgument::GuildChannel(channel),
                            );
                            return Ok(input);
                        }
                    }
                    Err(
                        TransformerError::CommandError(CommandError {
                            title: String::from("Could not find channel in guild"),
                            hint: Some(
                                String::from(
                                    "make sure to input the channel id or the exact name.",
                                ),
                            ),
                            arg: None,
                        }),
                    )
                })
            }
        }
    }
    mod i32 {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::{CommandError, MissingArgumentError},
            lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn i32<'a>(
                _ctx: &'a Context,
                _msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    let Some(mut input) = args.next() else {
                        return Err(
                            TransformerError::MissingArgumentError(
                                MissingArgumentError(String::from("String")),
                            ),
                        );
                    };
                    if let Ok(n) = input.raw.clone().parse::<i32>() {
                        input.contents = Some(CommandArgument::i32(n));
                        Ok(input)
                    } else {
                        Err(
                            TransformerError::CommandError(CommandError {
                                arg: Some(input),
                                title: String::from("Could not turn input to a <Number>"),
                                hint: Some(String::from("provide a valid number")),
                            }),
                        )
                    }
                })
            }
        }
    }
    mod maybe_duration {
        use std::{iter::Peekable, vec::IntoIter};
        use chrono::Duration;
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::MissingArgumentError, lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn maybe_duration<'a>(
                ctx: &'a Context,
                msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    let Some(input) = args.peek() else {
                        return Err(
                            TransformerError::MissingArgumentError(
                                MissingArgumentError(String::from("Duration")),
                            ),
                        );
                    };
                    let mut fake_args = <[_]>::into_vec(
                            ::alloc::boxed::box_new([input.clone()]),
                        )
                        .into_iter()
                        .peekable();
                    let input = match Self::duration(ctx, msg, &mut fake_args).await {
                        Ok(t) => {
                            args.next();
                            t
                        }
                        _ => {
                            Token {
                                contents: Some(CommandArgument::Duration(Duration::zero())),
                                raw: String::new(),
                                position: 0,
                                length: 0,
                                iteration: 0,
                                quoted: false,
                                inferred: None,
                            }
                        }
                    };
                    Ok(input)
                })
            }
        }
    }
    mod member {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::{CommandError, MissingArgumentError},
            lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn member<'a>(
                ctx: &'a Context,
                msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    let Some(mut input) = args.next() else {
                        return Err(
                            TransformerError::MissingArgumentError(
                                MissingArgumentError(String::from("Member")),
                            ),
                        );
                    };
                    let id = if let Ok(id) = input.raw.parse::<u64>() {
                        id
                    } else if input.raw.starts_with("<@") && input.raw.ends_with(">") {
                        let new_input = input
                            .raw
                            .strip_prefix("<@")
                            .unwrap()
                            .strip_suffix(">")
                            .unwrap();
                        if let Ok(id) = new_input.parse::<u64>() {
                            id
                        } else {
                            return Err(
                                TransformerError::CommandError(CommandError {
                                    arg: Some(input),
                                    title: String::from(
                                        "Could not turn input to a <Discord Member>",
                                    ),
                                    hint: Some(String::from("provide a valid ID or mention")),
                                }),
                            );
                        }
                    } else {
                        let Ok(users) = msg
                            .guild_id
                            .unwrap_or_else(|| ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            ))
                            .members(&ctx.http, None, None)
                            .await else {
                            return Err(
                                TransformerError::CommandError(CommandError {
                                    arg: Some(input),
                                    title: String::from(
                                        "Could not turn input to a <Discord User>",
                                    ),
                                    hint: Some(String::from("provide a valid ID or mention")),
                                }),
                            );
                        };
                        let opt_user = users.iter().find(|u| u.user.name == input.raw);
                        if let Some(user) = opt_user {
                            input.contents = Some(CommandArgument::Member(user.clone()));
                            return Ok(input);
                        }
                        return Err(
                            TransformerError::CommandError(CommandError {
                                arg: Some(input),
                                title: String::from(
                                    "Could not turn input to a <Discord User>",
                                ),
                                hint: Some(String::from("provide a valid ID or mention")),
                            }),
                        );
                    };
                    let member = {
                        if let Ok(member) = msg
                            .guild_id
                            .unwrap_or_else(|| ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            ))
                            .member(&ctx.http, id)
                            .await
                        {
                            member.clone()
                        } else {
                            return Err(
                                TransformerError::CommandError(CommandError {
                                    arg: Some(input),
                                    title: String::from("Could not find the <Discord Member>"),
                                    hint: Some(
                                        String::from(
                                            "make sure the ID or mention you provided is valid and that the member is in this server!",
                                        ),
                                    ),
                                }),
                            );
                        }
                    };
                    input.contents = Some(CommandArgument::Member(member));
                    Ok(input)
                })
            }
        }
    }
    mod reply_consume {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::MissingArgumentError, lexer::{InferType, Token},
            transformers::Transformers,
        };
        impl Transformers {
            pub fn reply_consume<'a>(
                ctx: &'a Context,
                msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    if args.peek().is_some() {
                        return Transformers::consume(ctx, msg, args).await;
                    } else if let Some(reply) = msg.referenced_message.clone() {
                        let (content, infer_type) = if let Some(embed) = reply
                            .embeds
                            .first()
                            && embed.clone().kind.unwrap_or(String::new())
                                == "auto_moderation_message"
                        {
                            let reason_type = if let Some(field) = embed
                                .fields
                                .iter()
                                .find(|f| f.name == "quarantine_user")
                            {
                                if field.value == "display_name" {
                                    String::from("Name: ")
                                } else if field.value == "clan_tag" {
                                    String::from("Tag: ")
                                } else {
                                    String::from("Automod: ")
                                }
                            } else {
                                String::from("Message: ")
                            };
                            let content = embed
                                .clone()
                                .description
                                .unwrap_or(msg.content.clone());
                            (
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("{0}{1}", reason_type, content),
                                    )
                                }),
                                InferType::SystemMessage,
                            )
                        } else {
                            (
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Message: {0}", reply.content),
                                    )
                                }),
                                InferType::Message,
                            )
                        };
                        Ok(Token {
                            contents: Some(CommandArgument::String(content)),
                            raw: String::new(),
                            position: 0,
                            length: 0,
                            iteration: 0,
                            quoted: false,
                            inferred: Some(infer_type),
                        })
                    } else {
                        Err(
                            TransformerError::MissingArgumentError(
                                MissingArgumentError(String::from("String")),
                            ),
                        )
                    }
                })
            }
        }
    }
    mod reply_member {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message, MessageType};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::CommandError, lexer::{InferType, Token},
            transformers::Transformers,
        };
        impl Transformers {
            pub fn reply_member<'a>(
                ctx: &'a Context,
                msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    if msg.guild_id.is_none() {
                        return Err(
                            TransformerError::CommandError(CommandError {
                                title: String::from("Server only command"),
                                hint: Some(String::from("stop trying to run this in dms!")),
                                arg: None,
                            }),
                        );
                    }
                    if let Some(reply) = msg.referenced_message.clone() {
                        let Ok(member) = msg
                            .guild_id
                            .unwrap()
                            .member(&ctx.http, reply.author.clone())
                            .await else {
                            return Err(
                                TransformerError::CommandError(CommandError {
                                    title: String::from("Replied member not in server"),
                                    hint: Some(
                                        String::from(
                                            "the member you replied to isn't in the server anymore. Urge them to join back!",
                                        ),
                                    ),
                                    arg: None,
                                }),
                            );
                        };
                        let infer_type = if match reply.kind {
                            MessageType::AutoModAction => true,
                            _ => false,
                        } {
                            InferType::SystemMessage
                        } else {
                            InferType::Message
                        };
                        Ok(Token {
                            contents: Some(CommandArgument::Member(member)),
                            raw: String::new(),
                            position: 0,
                            length: 0,
                            iteration: 0,
                            quoted: false,
                            inferred: Some(infer_type),
                        })
                    } else {
                        return Transformers::member(ctx, msg, args).await;
                    }
                })
            }
        }
    }
    mod reply_user {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message, MessageType};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::CommandError, lexer::{InferType, Token},
            transformers::Transformers,
        };
        impl Transformers {
            pub fn reply_user<'a>(
                ctx: &'a Context,
                msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    if msg.guild_id.is_none() {
                        return Err(
                            TransformerError::CommandError(CommandError {
                                title: String::from("Server only command"),
                                hint: Some(String::from("stop trying to run this in dms!")),
                                arg: None,
                            }),
                        );
                    }
                    if let Some(reply) = msg.referenced_message.clone() {
                        let infer_type = if match reply.kind {
                            MessageType::AutoModAction => true,
                            _ => false,
                        } {
                            InferType::SystemMessage
                        } else {
                            InferType::Message
                        };
                        Ok(Token {
                            contents: Some(CommandArgument::User(reply.author)),
                            raw: String::new(),
                            position: 0,
                            length: 0,
                            iteration: 0,
                            quoted: false,
                            inferred: Some(infer_type),
                        })
                    } else {
                        return Transformers::user(ctx, msg, args).await;
                    }
                })
            }
        }
    }
    mod some_string {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::{CommandError, MissingArgumentError},
            lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn some_string<'a>(
                _ctx: &'a Context,
                _msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    let Some(mut input) = args.next() else {
                        return Err(
                            TransformerError::MissingArgumentError(
                                MissingArgumentError(String::from("String")),
                            ),
                        );
                    };
                    if input.raw.chars().all(char::is_whitespace) || input.raw.is_empty()
                    {
                        return Err(
                            TransformerError::CommandError(CommandError {
                                arg: Some(input),
                                title: String::from(
                                    "String must not be empty and not be whitespace",
                                ),
                                hint: None,
                            }),
                        );
                    }
                    input.contents = Some(CommandArgument::String(input.raw.clone()));
                    Ok(input)
                })
            }
        }
    }
    mod string {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::MissingArgumentError, lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn string<'a>(
                _ctx: &'a Context,
                _msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    let Some(mut input) = args.next() else {
                        return Err(
                            TransformerError::MissingArgumentError(
                                MissingArgumentError(String::from("String")),
                            ),
                        );
                    };
                    input.contents = Some(CommandArgument::String(input.raw.clone()));
                    Ok(input)
                })
            }
        }
    }
    mod user {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            event_handler::{CommandError, MissingArgumentError},
            lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn user<'a>(
                ctx: &'a Context,
                _msg: &'a Message,
                args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    let Some(mut input) = args.next() else {
                        return Err(
                            TransformerError::MissingArgumentError(
                                MissingArgumentError(String::from("User")),
                            ),
                        );
                    };
                    let id = if let Ok(id) = input.raw.parse::<u64>() {
                        id
                    } else if input.raw.starts_with("<@") && input.raw.ends_with(">") {
                        let new_input = input
                            .raw
                            .strip_prefix("<@")
                            .unwrap()
                            .strip_suffix(">")
                            .unwrap();
                        if let Ok(id) = new_input.parse::<u64>() {
                            id
                        } else {
                            return Err(
                                TransformerError::CommandError(CommandError {
                                    arg: Some(input),
                                    title: String::from(
                                        "Could not turn input to a <Discord User>",
                                    ),
                                    hint: Some(String::from("provide a valid ID or mention")),
                                }),
                            );
                        }
                    } else {
                        let users = ctx.cache.users();
                        let opt_user = users.iter().find(|u| u.name == input.raw);
                        if let Some(user) = opt_user {
                            input.contents = Some(CommandArgument::User(user.clone()));
                            return Ok(input);
                        }
                        return Err(
                            TransformerError::CommandError(CommandError {
                                arg: Some(input),
                                title: String::from(
                                    "Could not turn input to a <Discord User>",
                                ),
                                hint: Some(String::from("provide a valid ID or mention")),
                            }),
                        );
                    };
                    let user = {
                        if let Some(user) = ctx.cache.user(id) {
                            user.clone()
                        } else if let Ok(user) = ctx.http.get_user(id.into()).await {
                            user.clone()
                        } else {
                            return Err(
                                TransformerError::CommandError(CommandError {
                                    arg: Some(input),
                                    title: String::from("Could not find the <Discord User>"),
                                    hint: Some(
                                        String::from(
                                            "make sure the ID or mention you provided is valid and that its associated user exists!",
                                        ),
                                    ),
                                }),
                            );
                        }
                    };
                    input.contents = Some(CommandArgument::User(user));
                    Ok(input)
                })
            }
        }
    }
    mod none {
        use std::{iter::Peekable, vec::IntoIter};
        use serenity::all::{Context, Message};
        use crate::{
            commands::{CommandArgument, TransformerReturn},
            lexer::Token, transformers::Transformers,
        };
        impl Transformers {
            pub fn none<'a>(
                _ctx: &'a Context,
                _msg: &'a Message,
                _args: &'a mut Peekable<IntoIter<Token>>,
            ) -> TransformerReturn<'a> {
                Box::pin(async move {
                    Ok(Token {
                        contents: Some(CommandArgument::None),
                        raw: String::new(),
                        position: 0,
                        length: 0,
                        iteration: 0,
                        quoted: false,
                        inferred: None,
                    })
                })
            }
        }
    }
}
mod utils {
    mod permissions {
        use serenity::all::{Context, Member, Permissions, User};
        use crate::BOT_CONFIG;
        pub async fn check_guild_permission(
            ctx: &Context,
            member: &Member,
            permission: Permissions,
        ) -> bool {
            let Some(guild_cached) = member.guild_id.to_guild_cached(&ctx.cache) else {
                return false;
            };
            if guild_cached.owner_id.get() == member.user.id.get() {
                return true;
            }
            for role in member.roles.clone() {
                let Some(role) = guild_cached.roles.get(&role) else {
                    return false;
                };
                if role.has_permission(permission)
                    || role.has_permission(Permissions::ADMINISTRATOR)
                {
                    return true;
                }
            }
            false
        }
        pub fn is_developer(user: &User) -> bool {
            let cfg = BOT_CONFIG.get().unwrap();
            cfg.dev_ids.clone().is_some_and(|i| i.contains(&user.id.get()))
        }
    }
    pub use permissions::check_guild_permission;
    pub use permissions::is_developer;
    mod logging {
        use chrono::DateTime;
        use serde::{Deserialize, Serialize};
        use serenity::all::{ChannelId, CreateMessage, GuildId, Http};
        use tracing::warn;
        use crate::GUILD_SETTINGS;
        #[serde(rename_all = "snake_case")]
        pub enum LogType {
            MemberBan,
            MemberUnban,
            MemberCache,
            MemberKick,
            MemberMute,
            MemberUnmute,
            MemberWarn,
            MemberSoftban,
            MemberUpdate,
            ActionUpdate,
            MessageDelete,
            MessageEdit,
        }
        #[automatically_derived]
        impl ::core::hash::Hash for LogType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LogType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        LogType::MemberBan => "MemberBan",
                        LogType::MemberUnban => "MemberUnban",
                        LogType::MemberCache => "MemberCache",
                        LogType::MemberKick => "MemberKick",
                        LogType::MemberMute => "MemberMute",
                        LogType::MemberUnmute => "MemberUnmute",
                        LogType::MemberWarn => "MemberWarn",
                        LogType::MemberSoftban => "MemberSoftban",
                        LogType::MemberUpdate => "MemberUpdate",
                        LogType::ActionUpdate => "ActionUpdate",
                        LogType::MessageDelete => "MessageDelete",
                        LogType::MessageEdit => "MessageEdit",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LogType {
            #[inline]
            fn clone(&self) -> LogType {
                match self {
                    LogType::MemberBan => LogType::MemberBan,
                    LogType::MemberUnban => LogType::MemberUnban,
                    LogType::MemberCache => LogType::MemberCache,
                    LogType::MemberKick => LogType::MemberKick,
                    LogType::MemberMute => LogType::MemberMute,
                    LogType::MemberUnmute => LogType::MemberUnmute,
                    LogType::MemberWarn => LogType::MemberWarn,
                    LogType::MemberSoftban => LogType::MemberSoftban,
                    LogType::MemberUpdate => LogType::MemberUpdate,
                    LogType::ActionUpdate => LogType::ActionUpdate,
                    LogType::MessageDelete => LogType::MessageDelete,
                    LogType::MessageEdit => LogType::MessageEdit,
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for LogType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        LogType::MemberBan => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                0u32,
                                "member_ban",
                            )
                        }
                        LogType::MemberUnban => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                1u32,
                                "member_unban",
                            )
                        }
                        LogType::MemberCache => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                2u32,
                                "member_cache",
                            )
                        }
                        LogType::MemberKick => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                3u32,
                                "member_kick",
                            )
                        }
                        LogType::MemberMute => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                4u32,
                                "member_mute",
                            )
                        }
                        LogType::MemberUnmute => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                5u32,
                                "member_unmute",
                            )
                        }
                        LogType::MemberWarn => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                6u32,
                                "member_warn",
                            )
                        }
                        LogType::MemberSoftban => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                7u32,
                                "member_softban",
                            )
                        }
                        LogType::MemberUpdate => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                8u32,
                                "member_update",
                            )
                        }
                        LogType::ActionUpdate => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                9u32,
                                "action_update",
                            )
                        }
                        LogType::MessageDelete => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                10u32,
                                "message_delete",
                            )
                        }
                        LogType::MessageEdit => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LogType",
                                11u32,
                                "message_edit",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for LogType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 12",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "member_ban" => _serde::__private::Ok(__Field::__field0),
                                "member_unban" => _serde::__private::Ok(__Field::__field1),
                                "member_cache" => _serde::__private::Ok(__Field::__field2),
                                "member_kick" => _serde::__private::Ok(__Field::__field3),
                                "member_mute" => _serde::__private::Ok(__Field::__field4),
                                "member_unmute" => _serde::__private::Ok(__Field::__field5),
                                "member_warn" => _serde::__private::Ok(__Field::__field6),
                                "member_softban" => _serde::__private::Ok(__Field::__field7),
                                "member_update" => _serde::__private::Ok(__Field::__field8),
                                "action_update" => _serde::__private::Ok(__Field::__field9),
                                "message_delete" => {
                                    _serde::__private::Ok(__Field::__field10)
                                }
                                "message_edit" => _serde::__private::Ok(__Field::__field11),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"member_ban" => _serde::__private::Ok(__Field::__field0),
                                b"member_unban" => _serde::__private::Ok(__Field::__field1),
                                b"member_cache" => _serde::__private::Ok(__Field::__field2),
                                b"member_kick" => _serde::__private::Ok(__Field::__field3),
                                b"member_mute" => _serde::__private::Ok(__Field::__field4),
                                b"member_unmute" => _serde::__private::Ok(__Field::__field5),
                                b"member_warn" => _serde::__private::Ok(__Field::__field6),
                                b"member_softban" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                b"member_update" => _serde::__private::Ok(__Field::__field8),
                                b"action_update" => _serde::__private::Ok(__Field::__field9),
                                b"message_delete" => {
                                    _serde::__private::Ok(__Field::__field10)
                                }
                                b"message_edit" => _serde::__private::Ok(__Field::__field11),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<LogType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = LogType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum LogType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MemberBan)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MemberUnban)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MemberCache)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MemberKick)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MemberMute)
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MemberUnmute)
                                }
                                (__Field::__field6, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MemberWarn)
                                }
                                (__Field::__field7, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MemberSoftban)
                                }
                                (__Field::__field8, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MemberUpdate)
                                }
                                (__Field::__field9, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::ActionUpdate)
                                }
                                (__Field::__field10, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MessageDelete)
                                }
                                (__Field::__field11, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LogType::MessageEdit)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "member_ban",
                        "member_unban",
                        "member_cache",
                        "member_kick",
                        "member_mute",
                        "member_unmute",
                        "member_warn",
                        "member_softban",
                        "member_update",
                        "action_update",
                        "message_delete",
                        "message_edit",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "LogType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<LogType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for LogType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for LogType {
            #[inline]
            fn eq(&self, other: &LogType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for LogType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl LogType {
            pub fn title(&self) -> String {
                String::from(
                    match self {
                        LogType::MemberBan => "Member Ban",
                        LogType::MemberUnban => "Member Unban",
                        LogType::MemberCache => "Member Cache",
                        LogType::MemberKick => "Member Kick",
                        LogType::MemberMute => "Member Mute",
                        LogType::MemberUnmute => "Member Unmute",
                        LogType::MemberWarn => "Member Warn",
                        LogType::MemberSoftban => "Member Softban",
                        LogType::MemberUpdate => "Member Update",
                        LogType::ActionUpdate => "Action Update",
                        LogType::MessageDelete => "Message Delete",
                        LogType::MessageEdit => "Message Edit",
                    },
                )
            }
            pub fn all() -> Vec<LogType> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        LogType::MemberBan,
                        LogType::MemberUnban,
                        LogType::MemberCache,
                        LogType::MemberKick,
                        LogType::MemberMute,
                        LogType::MemberUnmute,
                        LogType::MemberWarn,
                        LogType::MemberSoftban,
                        LogType::MemberUpdate,
                        LogType::ActionUpdate,
                        LogType::MessageDelete,
                        LogType::MessageEdit,
                    ]),
                )
            }
            pub async fn channel_id(&self, guild: GuildId) -> Option<ChannelId> {
                let mut lock = GUILD_SETTINGS.get().unwrap().lock().await;
                let settings = lock.get(guild.get()).await.ok()?;
                settings.log.log_channel_ids.get(self).map(|c| ChannelId::new(*c))
            }
        }
        pub async fn guild_log(
            http: &Http,
            log_type: LogType,
            guild: GuildId,
            msg: CreateMessage,
        ) {
            let Some(channel) = log_type.channel_id(guild).await else {
                return;
            };
            if let Err(err) = channel.send_message(http, msg).await {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src\\utils\\logging.rs:78",
                                "Ouroboros::utils::logging",
                                ::tracing::Level::WARN,
                                ::tracing_core::__macro_support::Option::Some(
                                    "src\\utils\\logging.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(78u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "Ouroboros::utils::logging",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::WARN
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::WARN
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "Cannot not send log message; err = {0:?}",
                                                    err,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::WARN {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::tracing::__macro_support::Option::Some(
                                                                        &format_args!(
                                                                            "Cannot not send log message; err = {0:?}",
                                                                            err,
                                                                        ) as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
            }
        }
        pub fn snowflake_to_timestamp(snowflake: u64) -> chrono::DateTime<chrono::Utc> {
            let discord_epoch: i64 = 1420070400000;
            let timestamp = ((snowflake >> 22) as i64) + discord_epoch;
            DateTime::from_naive_utc_and_offset(
                DateTime::from_timestamp_millis(timestamp).unwrap().naive_utc(),
                chrono::Utc,
            )
        }
    }
    pub use logging::LogType;
    pub use logging::guild_log;
    pub use logging::snowflake_to_timestamp;
    mod random {
        use serenity::all::Timestamp;
        use tokio::sync::Mutex;
        static COUNTER: Mutex<u64> = Mutex::const_new(0);
        pub async fn random() -> u64 {
            let mut c = COUNTER.lock().await;
            if *c == 0 {
                *c = Timestamp::now().timestamp() as u64;
            }
            *c = c.wrapping_mul(54329072133).wrapping_add(9081523890);
            *c
        }
        const CHAR_MAP: &str = "ABCDEFGHJKLMNPRSTUVWXYZabcdefghjkmnpqrstuvwxyz123456789";
        pub async fn tinyid() -> String {
            let mut res = String::new();
            for _ in 1..=6 {
                let rand = (random().await % CHAR_MAP.len() as u64) as usize;
                res.push(CHAR_MAP.chars().nth(rand).unwrap());
            }
            res
        }
    }
    pub use random::tinyid;
    mod guild_settings {
        use std::collections::HashMap;
        use serde::Serialize;
        use sqlx::{prelude::FromRow, query_as, types::Json};
        use crate::{SQL, utils::{AnyError, LogType}};
        pub struct GuildSettings {
            inner: HashMap<u64, Settings>,
            invalid: bool,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for GuildSettings {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "GuildSettings",
                    "inner",
                    &self.inner,
                    "invalid",
                    &&self.invalid,
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GuildSettings {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "GuildSettings",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "inner",
                        &self.inner,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "invalid",
                        &self.invalid,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for GuildSettings {
            #[inline]
            fn clone(&self) -> GuildSettings {
                GuildSettings {
                    inner: ::core::clone::Clone::clone(&self.inner),
                    invalid: ::core::clone::Clone::clone(&self.invalid),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for GuildSettings {
            #[inline]
            fn default() -> GuildSettings {
                GuildSettings {
                    inner: ::core::default::Default::default(),
                    invalid: ::core::default::Default::default(),
                }
            }
        }
        struct GuildSettingsRow {
            guild_id: i64,
            log_bot: Option<bool>,
            log_channel_ids: Option<Json<HashMap<LogType, u64>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for GuildSettingsRow {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "GuildSettingsRow",
                    "guild_id",
                    &self.guild_id,
                    "log_bot",
                    &self.log_bot,
                    "log_channel_ids",
                    &&self.log_channel_ids,
                )
            }
        }
        #[automatically_derived]
        impl<'a, R: ::sqlx::Row> ::sqlx::FromRow<'a, R> for GuildSettingsRow
        where
            &'a ::std::primitive::str: ::sqlx::ColumnIndex<R>,
            i64: ::sqlx::decode::Decode<'a, R::Database>,
            i64: ::sqlx::types::Type<R::Database>,
            Option<bool>: ::sqlx::decode::Decode<'a, R::Database>,
            Option<bool>: ::sqlx::types::Type<R::Database>,
            Option<Json<HashMap<LogType, u64>>>: ::sqlx::decode::Decode<'a, R::Database>,
            Option<Json<HashMap<LogType, u64>>>: ::sqlx::types::Type<R::Database>,
        {
            fn from_row(__row: &'a R) -> ::sqlx::Result<Self> {
                let guild_id: i64 = __row.try_get("guild_id")?;
                let log_bot: Option<bool> = __row.try_get("log_bot")?;
                let log_channel_ids: Option<Json<HashMap<LogType, u64>>> = __row
                    .try_get("log_channel_ids")?;
                ::std::result::Result::Ok(GuildSettingsRow {
                    guild_id,
                    log_bot,
                    log_channel_ids,
                })
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for GuildSettingsRow {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for GuildSettingsRow {
            #[inline]
            fn eq(&self, other: &GuildSettingsRow) -> bool {
                self.guild_id == other.guild_id && self.log_bot == other.log_bot
                    && self.log_channel_ids == other.log_channel_ids
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for GuildSettingsRow {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
                let _: ::core::cmp::AssertParamIsEq<Option<Json<HashMap<LogType, u64>>>>;
            }
        }
        impl GuildSettings {
            pub fn new() -> Self {
                Self {
                    inner: HashMap::new(),
                    invalid: true,
                }
            }
            pub fn invalidate(&mut self) {
                self.invalid = true;
            }
            pub async fn get(&mut self, guild: u64) -> Result<Settings, AnyError> {
                if self.invalid {
                    let new_data = self.fetch_data().await?;
                    self.inner = new_data;
                    self.invalid = false;
                }
                match self.inner.get(&guild) {
                    Some(s) => Ok(s.clone()),
                    None => Err(AnyError::new("guild_not_found")),
                }
            }
            async fn fetch_data(&self) -> Result<HashMap<u64, Settings>, AnyError> {
                if let Ok(data) = {
                    {
                        #[allow(clippy::all)]
                        {
                            use ::sqlx::Arguments as _;
                            let query_args = ::core::result::Result::<
                                _,
                                ::sqlx::error::BoxDynError,
                            >::Ok(
                                <sqlx::postgres::Postgres as ::sqlx::database::Database>::Arguments::<
                                    '_,
                                >::default(),
                            );
                            ::sqlx::__query_with_result::<
                                sqlx::postgres::Postgres,
                                _,
                            >(
                                    "SELECT\n                guild_id,\n                log_bot,\n                log_channel_ids as \"log_channel_ids?: sqlx::types::Json<HashMap<LogType, u64>>\"\n            FROM guild_settings",
                                    query_args,
                                )
                                .try_map(|row: sqlx::postgres::PgRow| {
                                    use ::sqlx::Row as _;
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_guild_id = row
                                        .try_get_unchecked::<i64, _>(0usize)?
                                        .into();
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_log_bot = row
                                        .try_get_unchecked::<
                                            ::std::option::Option<bool>,
                                            _,
                                        >(1usize)?
                                        .into();
                                    #[allow(non_snake_case)]
                                    let sqlx_query_as_log_channel_ids = row
                                        .try_get_unchecked::<
                                            ::std::option::Option<
                                                sqlx::types::Json<HashMap<LogType, u64>>,
                                            >,
                                            _,
                                        >(2usize)?
                                        .into();
                                    ::std::result::Result::Ok(GuildSettingsRow {
                                        guild_id: sqlx_query_as_guild_id,
                                        log_bot: sqlx_query_as_log_bot,
                                        log_channel_ids: sqlx_query_as_log_channel_ids,
                                    })
                                })
                        }
                    }
                }
                    .fetch_all(SQL.get().unwrap())
                    .await
                {
                    let mut map: HashMap<u64, Settings> = HashMap::new();
                    data.into_iter()
                        .for_each(|record| {
                            map.insert(
                                record.guild_id as u64,
                                Settings {
                                    log: SettingsLog {
                                        log_channel_ids: record
                                            .log_channel_ids
                                            .map(|j| j.0)
                                            .unwrap_or_default(),
                                        log_bots: record.log_bot,
                                    },
                                },
                            );
                        });
                    Ok(map)
                } else {
                    Err(AnyError::new("database_faild"))
                }
            }
        }
        pub struct Settings {
            pub log: SettingsLog,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Settings {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Settings",
                    "log",
                    &&self.log,
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Settings {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Settings",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "log",
                        &self.log,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for Settings {
            #[inline]
            fn clone(&self) -> Settings {
                Settings {
                    log: ::core::clone::Clone::clone(&self.log),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Settings {
            #[inline]
            fn default() -> Settings {
                Settings {
                    log: ::core::default::Default::default(),
                }
            }
        }
        pub struct SettingsLog {
            pub log_channel_ids: HashMap<LogType, u64>,
            pub log_bots: Option<bool>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SettingsLog {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "SettingsLog",
                    "log_channel_ids",
                    &self.log_channel_ids,
                    "log_bots",
                    &&self.log_bots,
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SettingsLog {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SettingsLog",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "log_channel_ids",
                        &self.log_channel_ids,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "log_bots",
                        &self.log_bots,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for SettingsLog {
            #[inline]
            fn clone(&self) -> SettingsLog {
                SettingsLog {
                    log_channel_ids: ::core::clone::Clone::clone(&self.log_channel_ids),
                    log_bots: ::core::clone::Clone::clone(&self.log_bots),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SettingsLog {
            #[inline]
            fn default() -> SettingsLog {
                SettingsLog {
                    log_channel_ids: ::core::default::Default::default(),
                    log_bots: ::core::default::Default::default(),
                }
            }
        }
    }
    pub use guild_settings::*;
    mod error {
        use std::fmt::Display;
        pub struct AnyError {
            pub inner: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AnyError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "AnyError",
                    "inner",
                    &&self.inner,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AnyError {
            #[inline]
            fn clone(&self) -> AnyError {
                AnyError {
                    inner: ::core::clone::Clone::clone(&self.inner),
                }
            }
        }
        impl AnyError {
            pub fn new(id: &'static str) -> Self {
                Self { inner: id.to_string() }
            }
        }
        impl Display for AnyError {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("AnyError; id: {0}", self.inner))
            }
        }
        impl std::error::Error for AnyError {}
    }
    pub use error::AnyError;
    mod message {
        use std::{collections::HashMap, iter::Peekable, time::Duration, vec::IntoIter};
        use serenity::all::{
            Context, CreateAllowedMentions, CreateEmbed, CreateMessage, Message, User,
        };
        use tokio::time::sleep;
        use tracing::warn;
        use crate::{
            commands::{CommandArgument, TransformerError, TransformerReturn},
            constants::BRAND_BLUE, lexer::{Token, lex},
        };
        type TransformerFn = dyn for<'a> Fn(
            &'a Context,
            &'a Message,
            &'a mut Peekable<IntoIter<Token>>,
        ) -> TransformerReturn<'a> + Send + Sync;
        pub async fn message_and_dm(
            ctx: &Context,
            command_msg: &Message,
            dm_user: &User,
            server_msg: impl Fn(String) -> String,
            dm_msg: String,
            automatically_delete: bool,
            silent: bool,
        ) {
            let mut addition = String::new();
            if !silent {
                let dm = CreateMessage::new()
                    .add_embed(CreateEmbed::new().description(dm_msg).color(BRAND_BLUE));
                if dm_user.direct_message(&ctx.http, dm).await.is_err() {
                    addition = String::from(" | DM failed");
                }
            } else {
                addition = String::from(" | silent")
            }
            let embed = CreateEmbed::new()
                .description(server_msg(addition))
                .color(BRAND_BLUE);
            let reply = CreateMessage::new()
                .add_embed(embed)
                .reference_message(command_msg)
                .allowed_mentions(CreateAllowedMentions::new().replied_user(false));
            let msg = match command_msg.channel_id.send_message(&ctx.http, reply).await {
                Ok(m) => m,
                Err(err) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src\\utils\\message.rs:52",
                                    "Ouroboros::utils::message",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "src\\utils\\message.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(52u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "Ouroboros::utils::message",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                } <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match ::tracing::Level::WARN {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let meta = __CALLSITE.metadata();
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(meta.target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    ::tracing::__macro_support::__tracing_log(
                                                        meta,
                                                        logger,
                                                        log_meta,
                                                        &value_set,
                                                    )
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!("Could not send message; err = {0:?}", err)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &{
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::tracing::__macro_support::Option::Some(
                                                                            &format_args!("Could not send message; err = {0:?}", err)
                                                                                as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    },
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return;
                }
            };
            if automatically_delete {
                let http = ctx.http.clone();
                let cmd_msg = command_msg.clone();
                tokio::spawn(async move {
                    sleep(Duration::from_secs(5)).await;
                    let _ = msg.delete(&http).await;
                    let _ = cmd_msg.delete(&http).await;
                });
            }
        }
        pub async fn get_args<'a>(
            context: &Context,
            msg: &Message,
            contents: String,
            args: Vec<(&'a str, &'a str, &TransformerFn)>,
        ) -> Result<
            (HashMap<&'a str, (bool, CommandArgument)>, String),
            TransformerError,
        > {
            let mut found_args: HashMap<&str, (bool, CommandArgument)> = HashMap::default();
            let mut lex = lex(contents.clone()).into_iter().peekable();
            let mut to_remove = Vec::new();
            while let Some(token) = lex.next() {
                let Some((positive, arg_name)) = ({
                    if let Some(arg) = token.raw.strip_prefix("-") {
                        Some((false, arg))
                    } else if let Some(arg) = token.raw.strip_prefix("+") {
                        Some((true, arg))
                    } else {
                        None
                    }
                }) else { continue };
                for (arg, name, func) in args.iter() {
                    if *arg == arg_name {
                        let cloned = lex.clone();
                        let contents_arg = func(context, msg, &mut lex.clone())
                            .await
                            .map(|t| t.contents.unwrap_or(CommandArgument::None))
                            .unwrap_or(CommandArgument::None);
                        let last_cloned = cloned.clone().last();
                        let last_consumed = cloned
                            .zip(lex.clone())
                            .find(|(a, b)| a.position == b.position)
                            .map(|(a, _)| a)
                            .or(last_cloned);
                        found_args.insert(name, (positive, contents_arg));
                        let last_position = last_consumed
                            .clone()
                            .map(|t| t.position)
                            .unwrap_or(token.position);
                        let last_length = last_consumed
                            .map(|t| t.length)
                            .unwrap_or(token.length);
                        to_remove.push((token.position, last_position + last_length));
                    }
                }
            }
            to_remove.sort_by_key(|r| r.0);
            let mut stripped = String::new();
            let mut last_end = 0;
            for (start, end) in to_remove {
                if start > last_end {
                    stripped.push_str(&contents[last_end..start]);
                }
                last_end = end;
            }
            if last_end < contents.len() {
                stripped.push_str(&contents[last_end..]);
            }
            Ok((found_args, stripped.trim().to_string()))
        }
    }
    pub use message::message_and_dm;
    pub use message::get_args;
}
pub static START_TIME: OnceLock<Instant> = OnceLock::new();
pub static SQL: OnceLock<PgPool> = OnceLock::new();
pub static GUILD_SETTINGS: OnceLock<Mutex<GuildSettings>> = OnceLock::new();
pub static BOT_CONFIG: OnceLock<Environment> = OnceLock::new();
fn main() {
    let body = async {
        tracing_subscriber::fmt::fmt().init();
        if let Some(arg) = std::env::args()
            .collect::<Vec<String>>()
            .iter()
            .find(|a| a.starts_with("--update"))
        {
            use std::process::exit;
            use tracing::info;
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src\\main.rs:57",
                            "Ouroboros",
                            ::tracing::Level::INFO,
                            ::tracing_core::__macro_support::Option::Some(
                                "src\\main.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(57u32),
                            ::tracing_core::__macro_support::Option::Some("Ouroboros"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::INFO
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::INFO
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::INFO {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::INFO {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("Starting update process") as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::INFO {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::INFO {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Starting update process") as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
            if let Err(err) = update(arg) {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src\\main.rs:59",
                                "Ouroboros",
                                ::tracing::Level::WARN,
                                ::tracing_core::__macro_support::Option::Some(
                                    "src\\main.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(59u32),
                                ::tracing_core::__macro_support::Option::Some("Ouroboros"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::WARN
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::WARN
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                            if match ::tracing::Level::WARN {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            } <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match ::tracing::Level::WARN {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let meta = __CALLSITE.metadata();
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(meta.target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                ::tracing::__macro_support::__tracing_log(
                                                    meta,
                                                    logger,
                                                    log_meta,
                                                    &value_set,
                                                )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!("Got error while updating; err = {0:?}", err)
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                        if match ::tracing::Level::WARN {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &{
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::tracing::__macro_support::Option::Some(
                                                                        &format_args!("Got error while updating; err = {0:?}", err)
                                                                            as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                },
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    }
                };
            }
            exit(0);
        }
        if let Err(err) = cleanup() {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src\\main.rs:65",
                            "Ouroboros",
                            ::tracing::Level::WARN,
                            ::tracing_core::__macro_support::Option::Some(
                                "src\\main.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(65u32),
                            ::tracing_core::__macro_support::Option::Some("Ouroboros"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::WARN
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::WARN
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::WARN {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "Could not clean up update files; err = {0:?}",
                                                err,
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::WARN {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!(
                                                                        "Could not clean up update files; err = {0:?}",
                                                                        err,
                                                                    ) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
        }
        let _ = START_TIME.set(Instant::now());
        let mut file = File::open("./Config.toml")
            .await
            .expect("Could not find Config.toml in project root.");
        let mut contents = String::new();
        if file.read_to_string(&mut contents).await.is_err() {
            {
                ::core::panicking::panic_fmt(
                    format_args!("Could not read Config.toml."),
                );
            };
        }
        let config: Config = toml::from_str(contents.as_str())
            .unwrap_or_else(|_| {
                ::core::panicking::panic_fmt(
                    format_args!("Could not parse Config.toml."),
                );
            });
        let active_env = match config.bot.env.as_str() {
            "release" => &config.release,
            "dev" => &config.dev,
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Unknown bot.env, verify bot.env is one of release or dev",
                    ),
                );
            }
        };
        let _ = SQL
            .set({
                async {
                    PgPoolOptions::new()
                        .max_connections(active_env.max_connections)
                        .connect(&active_env.database_url)
                        .await
                        .expect(
                            "Failed to create database pool, make sure the database url in the config is valid.",
                        )
                }
                    .await
            });
        database::run_migrations().await;
        GUILD_SETTINGS.set(Mutex::new(GuildSettings::new())).unwrap();
        BOT_CONFIG.set(active_env.clone()).unwrap();
        let intents = GatewayIntents::all();
        let mut cache_settings = Settings::default();
        cache_settings.max_messages = active_env.msg_cache;
        let handler = Handler::new(active_env.prefix.clone());
        let mut client = Client::builder(&active_env.token, intents)
            .event_handler(handler)
            .cache_settings(cache_settings)
            .await
            .expect("Unable to create client");
        let shard_manager = client.shard_manager.clone();
        client.data.write().await.insert::<ShardManagerContainer>(shard_manager);
        let http = client.http.clone();
        tokio::spawn(async move {
            loop {
                sleep(Duration::from_secs(60 * 5)).await;
                tasks::check_expiring_bans(&http).await;
                tasks::check_expiring_timeouts(&http).await;
            }
        });
        if let Err(e) = client.start().await {
            {
                ::std::io::_eprint(format_args!("Client error: {0:?}\n", e));
            }
        }
    };
    #[allow(
        clippy::expect_used,
        clippy::diverging_sub_expression,
        clippy::needless_return
    )]
    {
        return tokio::runtime::Builder::new_multi_thread()
            .enable_all()
            .build()
            .expect("Failed building the Runtime")
            .block_on(body);
    }
}
#[allow(unreachable_code, dead_code)]
fn update(arg: &str) -> std::io::Result<()> {
    let exe = env::current_exe()?;
    let name = "Ouroboros.exe";
    let mut target = exe.parent().unwrap().to_path_buf();
    target.push(name);
    if target.exists() {
        fs::remove_file(&target)?;
    }
    fs::copy(&exe, &target)?;
    let id = arg.split("=").last().unwrap_or("");
    match SystemCommand::new(
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(".{0}{1}", std::path::MAIN_SEPARATOR, name),
                )
            }),
        )
        .arg(
            ::alloc::__export::must_use({
                ::alloc::fmt::format(format_args!("--id={0}", id))
            }),
        )
        .spawn()
    {
        Ok(c) => drop(c),
        Err(e) => {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "event src\\main.rs:162",
                        "Ouroboros",
                        ::tracing::Level::ERROR,
                        ::tracing_core::__macro_support::Option::Some("src\\main.rs"),
                        ::tracing_core::__macro_support::Option::Some(162u32),
                        ::tracing_core::__macro_support::Option::Some("Ouroboros"),
                        ::tracing_core::field::FieldSet::new(
                            &["message"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::EVENT,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let enabled = ::tracing::Level::ERROR
                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && ::tracing::Level::ERROR
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    let interest = __CALLSITE.interest();
                    !interest.is_never()
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                };
            if enabled {
                (|value_set: ::tracing::field::ValueSet| {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Event::dispatch(meta, &value_set);
                    if match ::tracing::Level::ERROR {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::ERROR {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &value_set,
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                })({
                    #[allow(unused_imports)]
                    use ::tracing::field::{debug, display, Value};
                    let mut iter = __CALLSITE.metadata().fields().iter();
                    __CALLSITE
                        .metadata()
                        .fields()
                        .value_set(
                            &[
                                (
                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                        .expect("FieldSet corrupted (this is a bug)"),
                                    ::tracing::__macro_support::Option::Some(
                                        &format_args!("Could not spawn new process; err = {0:?}", e)
                                            as &dyn Value,
                                    ),
                                ),
                            ],
                        )
                });
            } else {
                if match ::tracing::Level::ERROR {
                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                    _ => ::tracing::log::Level::Trace,
                } <= ::tracing::log::STATIC_MAX_LEVEL
                {
                    if !::tracing::dispatcher::has_been_set() {
                        {
                            use ::tracing::log;
                            let level = match ::tracing::Level::ERROR {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            };
                            if level <= log::max_level() {
                                let meta = __CALLSITE.metadata();
                                let log_meta = log::Metadata::builder()
                                    .level(level)
                                    .target(meta.target())
                                    .build();
                                let logger = log::logger();
                                if logger.enabled(&log_meta) {
                                    ::tracing::__macro_support::__tracing_log(
                                        meta,
                                        logger,
                                        log_meta,
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::tracing::__macro_support::Option::Some(
                                                                &format_args!("Could not spawn new process; err = {0:?}", e)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        },
                                    )
                                }
                            }
                        }
                    } else {
                        {}
                    }
                } else {
                    {}
                };
            }
        }
    };
    Ok(())
}
fn cleanup() -> std::io::Result<()> {
    let current_dir = std::env::current_dir()?;
    for entry in fs::read_dir(&current_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_file()
            && let Some(filename) = path.file_name().and_then(|f| f.to_str())
            && filename.starts_with("new_") && filename.contains("ouroboros")
        {
            fs::remove_file(&path)?;
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event src\\main.rs:181",
                            "Ouroboros",
                            ::tracing::Level::WARN,
                            ::tracing_core::__macro_support::Option::Some(
                                "src\\main.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(181u32),
                            ::tracing_core::__macro_support::Option::Some("Ouroboros"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::WARN
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::WARN
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                        if match ::tracing::Level::WARN {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        } <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    use ::tracing::log;
                                    let level = match ::tracing::Level::WARN {
                                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                        _ => ::tracing::log::Level::Trace,
                                    };
                                    if level <= log::max_level() {
                                        let meta = __CALLSITE.metadata();
                                        let log_meta = log::Metadata::builder()
                                            .level(level)
                                            .target(meta.target())
                                            .build();
                                        let logger = log::logger();
                                        if logger.enabled(&log_meta) {
                                            ::tracing::__macro_support::__tracing_log(
                                                meta,
                                                logger,
                                                log_meta,
                                                &value_set,
                                            )
                                        }
                                    }
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("Deleted file; {0}", filename) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                    if match ::tracing::Level::WARN {
                        ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                        ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                        ::tracing::Level::INFO => ::tracing::log::Level::Info,
                        ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                        _ => ::tracing::log::Level::Trace,
                    } <= ::tracing::log::STATIC_MAX_LEVEL
                    {
                        if !::tracing::dispatcher::has_been_set() {
                            {
                                use ::tracing::log;
                                let level = match ::tracing::Level::WARN {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                };
                                if level <= log::max_level() {
                                    let meta = __CALLSITE.metadata();
                                    let log_meta = log::Metadata::builder()
                                        .level(level)
                                        .target(meta.target())
                                        .build();
                                    let logger = log::logger();
                                    if logger.enabled(&log_meta) {
                                        ::tracing::__macro_support::__tracing_log(
                                            meta,
                                            logger,
                                            log_meta,
                                            &{
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!("Deleted file; {0}", filename) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            },
                                        )
                                    }
                                }
                            }
                        } else {
                            {}
                        }
                    } else {
                        {}
                    };
                }
            };
        }
    }
    Ok(())
}
